
#include <stdio.h>

#include "JSONUtils.h"
#include "MMSCURL.h"
#include <fstream>
#include <sstream>
#include <regex>
#include <iomanip>
#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <curlpp/Exception.hpp>
#include <curlpp/Infos.hpp>
#include "catralibraries/System.h"
#include "catralibraries/Encrypt.h"
#include "catralibraries/DateTime.h"
#include "catralibraries/ProcessUtility.h"
#include "catralibraries/Convert.h"
#include "PersistenceLock.h"
#include "FFMpeg.h"
#include "MMSEngineProcessor.h"
#include "CheckIngestionTimes.h"
#include "CheckEncodingTimes.h"
#include "ContentRetentionTimes.h"
#include "DBDataRetentionTimes.h"
#include "ThreadsStatisticTimes.h"
#include "CheckRefreshPartitionFreeSizeTimes.h"
#include "EMailSender.h"
#include "Magick++.h"
#include <openssl/md5.h>

#define MD5BUFFERSIZE 16384

MMSEngineProcessor::MMSEngineProcessor(
	int processorIdentifier,
	shared_ptr<spdlog::logger> logger, 
	shared_ptr<MultiEventsSet> multiEventsSet,
	shared_ptr<MMSEngineDBFacade> mmsEngineDBFacade,
	shared_ptr<MMSStorage> mmsStorage,
	shared_ptr<long> processorsThreadsNumber,
	shared_ptr<ThreadsStatistic> mmsThreadsStatistic,
	shared_ptr<MMSDeliveryAuthorization> mmsDeliveryAuthorization,
	ActiveEncodingsManager* pActiveEncodingsManager,
	mutex* cpuUsageMutex,
	deque<int>* cpuUsage,
	Json::Value configuration
)
{
    _processorIdentifier         = processorIdentifier;
    _logger             = logger;
    _configuration      = configuration;
    _multiEventsSet     = multiEventsSet;
    _mmsEngineDBFacade  = mmsEngineDBFacade;
    _mmsStorage         = mmsStorage;
    _processorsThreadsNumber = processorsThreadsNumber;
	_mmsThreadsStatistic		= mmsThreadsStatistic;
	_mmsDeliveryAuthorization	= mmsDeliveryAuthorization;
    _pActiveEncodingsManager = pActiveEncodingsManager;

    _processorMMS                   = System::getHostName();

	_cpuUsageMutex = cpuUsageMutex;
	_cpuUsage = cpuUsage;
	_cpuUsageThreadShutdown	= false;

    _processorThreads =  JSONUtils::asInt(configuration["mms"], "processorThreads", 1);
    _cpuUsageThreshold =  JSONUtils::asInt(configuration["mms"], "cpuUsageThreshold", 10);

    _maxDownloadAttemptNumber       = JSONUtils::asInt(configuration["download"], "maxDownloadAttemptNumber", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", download->maxDownloadAttemptNumber: " + to_string(_maxDownloadAttemptNumber)
    );
    _progressUpdatePeriodInSeconds  = JSONUtils::asInt(configuration["download"], "progressUpdatePeriodInSeconds", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", download->progressUpdatePeriodInSeconds: " + to_string(_progressUpdatePeriodInSeconds)
    );
    _secondsWaitingAmongDownloadingAttempt  = JSONUtils::asInt(configuration["download"], "secondsWaitingAmongDownloadingAttempt", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", download->secondsWaitingAmongDownloadingAttempt: " + to_string(_secondsWaitingAmongDownloadingAttempt)
    );
    
    _maxIngestionJobsPerEvent       = JSONUtils::asInt(configuration["mms"], "maxIngestionJobsPerEvent", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", mms->maxIngestionJobsPerEvent: " + to_string(_maxIngestionJobsPerEvent)
    );
    _maxEncodingJobsPerEvent       = JSONUtils::asInt(configuration["mms"], "maxEncodingJobsPerEvent", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", mms->maxEncodingJobsPerEvent: " + to_string(_maxEncodingJobsPerEvent)
    );

    _maxEventManagementTimeInSeconds       = JSONUtils::asInt(configuration["mms"], "maxEventManagementTimeInSeconds", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", mms->maxEventManagementTimeInSeconds: " + to_string(_maxEventManagementTimeInSeconds)
    );

    _dependencyExpirationInHours        = JSONUtils::asInt(configuration["mms"], "dependencyExpirationInHours", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", mms->dependencyExpirationInHours: " + to_string(_dependencyExpirationInHours)
    );

	_timeBeforeToPrepareResourcesInMinutes      = JSONUtils::asInt(configuration["mms"],
		"liveRecording_timeBeforeToPrepareResourcesInMinutes", 2);

    _downloadChunkSizeInMegaBytes       = JSONUtils::asInt(configuration["download"], "downloadChunkSizeInMegaBytes", 5);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", download->downloadChunkSizeInMegaBytes: " + to_string(_downloadChunkSizeInMegaBytes)
    );
    
    _emailProtocol                      = _configuration["EmailNotification"].get("protocol", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", EmailNotification->protocol: " + _emailProtocol
    );
    _emailServer                        = _configuration["EmailNotification"].get("server", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", EmailNotification->server: " + _emailServer
    );
    _emailPort                          = JSONUtils::asInt(_configuration["EmailNotification"], "port", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", EmailNotification->port: " + to_string(_emailPort)
    );
    _emailUserName                      = _configuration["EmailNotification"].get("userName", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", EmailNotification->userName: " + _emailUserName
    );
    string _emailPassword;
    {
        string encryptedPassword = _configuration["EmailNotification"].get("password", "XXX").asString();
        _emailPassword = Encrypt::opensslDecrypt(encryptedPassword);        
    }
    _emailFrom                          = _configuration["EmailNotification"].get("from", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", EmailNotification->from: " + _emailFrom
    );
    
    _facebookGraphAPIProtocol           = _configuration["FacebookGraphAPI"].get("protocol", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", FacebookGraphAPI->protocol: " + _facebookGraphAPIProtocol
    );
    _facebookGraphAPIHostName           = _configuration["FacebookGraphAPI"].get("hostName", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", FacebookGraphAPI->hostName: " + _facebookGraphAPIHostName
    );
    _facebookGraphAPIPort               = JSONUtils::asInt(_configuration["FacebookGraphAPI"], "port", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", FacebookGraphAPI->port: " + to_string(_facebookGraphAPIPort)
    );
    _facebookGraphAPIVersion           = _configuration["FacebookGraphAPI"].get("version", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", FacebookGraphAPI->version: " + _facebookGraphAPIVersion
    );
    _facebookGraphAPITimeoutInSeconds   = JSONUtils::asInt(_configuration["FacebookGraphAPI"], "timeout", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", FacebookGraphAPI->timeout: " + to_string(_facebookGraphAPITimeoutInSeconds)
    );

    _youTubeDataAPIProtocol           = _configuration["YouTubeDataAPI"].get("protocol", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->protocol: " + _youTubeDataAPIProtocol
    );
    _youTubeDataAPIHostName           = _configuration["YouTubeDataAPI"].get("hostName", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->hostName: " + _youTubeDataAPIHostName
    );
    _youTubeDataAPIPort               = JSONUtils::asInt(_configuration["YouTubeDataAPI"], "port", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->port: " + to_string(_youTubeDataAPIPort)
    );
    _youTubeDataAPIRefreshTokenURI       = _configuration["YouTubeDataAPI"].get("refreshTokenURI", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->refreshTokenURI: " + _youTubeDataAPIRefreshTokenURI
    );
    _youTubeDataAPIUploadVideoURI       = _configuration["YouTubeDataAPI"].get("uploadVideoURI", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->uploadVideoURI: " + _youTubeDataAPIUploadVideoURI
    );
    _youTubeDataAPILiveBroadcastURI		= _configuration["YouTubeDataAPI"].get("liveBroadcastURI", "")
		.asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->liveBroadcastURI: " + _youTubeDataAPILiveBroadcastURI
    );
    _youTubeDataAPILiveStreamURI		= _configuration["YouTubeDataAPI"].get("liveStreamURI", "")
		.asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->liveStreamURI: " + _youTubeDataAPILiveStreamURI
    );
    _youTubeDataAPILiveBroadcastBindURI		= _configuration["YouTubeDataAPI"].
		get("liveBroadcastBindURI", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->liveBroadcastBindURI: " + _youTubeDataAPILiveBroadcastBindURI
    );
    _youTubeDataAPITimeoutInSeconds   = JSONUtils::asInt(_configuration["YouTubeDataAPI"], "timeout", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->timeout: " + to_string(_youTubeDataAPITimeoutInSeconds)
    );
    _youTubeDataAPIClientId       = _configuration["YouTubeDataAPI"].get("clientId", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->clientId: " + _youTubeDataAPIClientId
    );
    _youTubeDataAPIClientSecret       = _configuration["YouTubeDataAPI"].get("clientSecret", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", YouTubeDataAPI->clientSecret: " + _youTubeDataAPIClientSecret
    );

    _localCopyTaskEnabled               =  JSONUtils::asBool(_configuration["mms"], "localCopyTaskEnabled", false);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", mms->localCopyTaskEnabled: " + to_string(_localCopyTaskEnabled)
    );

    string mmsAPIProtocol = _configuration["api"].get("protocol", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->protocol: " + mmsAPIProtocol
    );
    string mmsAPIHostname = _configuration["api"].get("hostname", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->hostname: " + mmsAPIHostname
    );
    int mmsAPIPort = JSONUtils::asInt(_configuration["api"], "port", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->port: " + to_string(mmsAPIPort)
    );
    string mmsAPIVersion = _configuration["api"].get("version", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->version: " + mmsAPIVersion
    );
    string mmsAPIWorkflowURI = _configuration["api"].get("workflowURI", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->workflowURI: " + mmsAPIWorkflowURI
    );
    string mmsAPIIngestionURI = _configuration["api"].get("ingestionURI", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->ingestionURI: " + mmsAPIIngestionURI
    );
    string mmsBinaryProtocol = _configuration["api"]["binary"].get("protocol", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->binary->protocol: " + mmsBinaryProtocol
    );
    string mmsBinaryHostname = _configuration["api"]["binary"].get("hostname", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->binary->hostname: " + mmsBinaryHostname
    );
    int mmsBinaryPort = JSONUtils::asInt(_configuration["api"]["binary"], "port", 0);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->binary->port: " + to_string(mmsBinaryPort)
    );
    string mmsBinaryVersion = _configuration["api"]["binary"].get("version", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->binary->version: " + mmsBinaryVersion
    );
    string mmsBinaryIngestionURI = _configuration["api"]["binary"].get("ingestionURI", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->binary->ingestionURI: " + mmsBinaryIngestionURI
    );
    _mmsAPIVODDeliveryURI = _configuration["api"].get("vodDeliveryURI", "").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->vodDeliveryURI: " + _mmsAPIVODDeliveryURI
    );
    _mmsAPITimeoutInSeconds = JSONUtils::asInt(_configuration["api"], "timeoutInSeconds", 120);
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->timeoutInSeconds: " + to_string(_mmsAPITimeoutInSeconds)
    );

    _deliveryProtocol  = _configuration["api"]["delivery"].get("deliveryProtocol", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->delivery->deliveryProtocol: " + _deliveryProtocol
    );
    _deliveryHost  = _configuration["api"]["delivery"].get("deliveryHost", "XXX").asString();
    _logger->info(__FILEREF__ + "Configuration item"
        + ", api->delivery->deliveryHost: " + _deliveryHost
    );

	_waitingNFSSync_maxMillisecondsToWait = JSONUtils::asInt(configuration["storage"],
		"waitingNFSSync_maxMillisecondsToWait", 60000);
	_logger->info(__FILEREF__ + "Configuration item"
		+ ", storage->_waitingNFSSync_maxMillisecondsToWait: " + to_string(_waitingNFSSync_maxMillisecondsToWait)
	);
	_waitingNFSSync_milliSecondsWaitingBetweenChecks = JSONUtils::asInt(configuration["storage"],
		"waitingNFSSync_milliSecondsWaitingBetweenChecks", 100);
	_logger->info(__FILEREF__ + "Configuration item"
		+ ", storage->waitingNFSSync_milliSecondsWaitingBetweenChecks: "
		+ to_string(_waitingNFSSync_milliSecondsWaitingBetweenChecks)
	);

	_mmsWorkflowIngestionURL =
		mmsAPIProtocol
		+ "://"
		+ mmsAPIHostname + ":"
		+ to_string(mmsAPIPort)
		+ "/catramms/"
		+ mmsAPIVersion
		+ mmsAPIWorkflowURI
	;

	_mmsIngestionURL =
		mmsAPIProtocol
		+ "://"
		+ mmsAPIHostname + ":"
		+ to_string(mmsAPIPort)
		+ "/catramms/"
		+ mmsAPIVersion
		+ mmsAPIIngestionURI
	;

	_mmsBinaryIngestionURL =
		mmsBinaryProtocol
		+ "://"
		+ mmsBinaryHostname + ":"
		+ to_string(mmsBinaryPort)
		+ "/catramms/"
		+ mmsBinaryVersion
		+ mmsBinaryIngestionURI
	;

    if (_processorIdentifier == 0)
    {
        try
        {
            _mmsEngineDBFacade->resetProcessingJobsIfNeeded(_processorMMS);
        }
        catch(runtime_error e)
        {
            _logger->error(__FILEREF__ + "_mmsEngineDBFacade->resetProcessingJobsIfNeeded failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", exception: " + e.what()
            );

            // throw e;
        }
        catch(exception e)
        {
            _logger->error(__FILEREF__ + "_mmsEngineDBFacade->resetProcessingJobsIfNeeded failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
            );

            // throw e;
        }
    }
}

MMSEngineProcessor::~MMSEngineProcessor()
{
    
}

bool MMSEngineProcessor::isMaintenanceMode()
{
	string maintenancePathName = "/tmp/mmsMaintenanceMode.txt";

	ifstream f(maintenancePathName.c_str());

    return f.good();
}

bool MMSEngineProcessor::isProcessorShutdown()
{
	string processorShutdownPathName = "/tmp/processorShutdown.txt";

	ifstream f(processorShutdownPathName.c_str());

    return f.good();
}

void MMSEngineProcessor::operator ()() 
{
    bool blocking = true;
    chrono::milliseconds milliSecondsToBlock(100);

    //SPDLOG_DEBUG(_logger , "Enabled only #ifdef SPDLOG_TRACE_ON..{} ,{}", 1, 3.23);
    // SPDLOG_TRACE(_logger , "Enabled only #ifdef SPDLOG_TRACE_ON..{} ,{}", 1, 3.23);
    _logger->info(__FILEREF__ + "MMSEngineProcessor thread started"
        + ", _processorIdentifier: " + to_string(_processorIdentifier)
    );

    bool processorShutdown = false;
    while(!processorShutdown)
    {
		if (isProcessorShutdown())
		{
			_logger->info(__FILEREF__ + "Processor was shutdown"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			processorShutdown = true;

			continue;
		}

        shared_ptr<Event2> event = _multiEventsSet->getAndRemoveFirstEvent(
				MMSENGINEPROCESSORNAME, blocking, milliSecondsToBlock);
        if (event == nullptr)
        {
            // cout << "No event found or event not yet expired" << endl;

            continue;
        }

		chrono::system_clock::time_point startEvent = chrono::system_clock::now();

        switch(event->getEventKey().first)
        {
            case MMSENGINE_EVENTTYPEIDENTIFIER_CHECKINGESTIONEVENT:	// 1
            {
                _logger->debug(__FILEREF__ + "1. Received MMSENGINE_EVENTTYPEIDENTIFIER_CHECKINGESTION"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                try
                {
                    handleCheckIngestionEvent ();
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleCheckIngestionEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<Event2>(event);

                _logger->debug(__FILEREF__ + "2. Received MMSENGINE_EVENTTYPEIDENTIFIER_CHECKINGESTION"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT:	// 2
            {
                _logger->debug(__FILEREF__ + "1. Received LOCALASSETINGESTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent
					= dynamic_pointer_cast<LocalAssetIngestionEvent>(event);

                try
                {
					/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
					if (_processorsThreadsNumber.use_count() > _processorThreads + _maxAdditionalProcessorThreads)
					{
						_logger->warn(__FILEREF__
							+ "Not enough available threads to manage handleLocalAssetIngestionEvent, activity is postponed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent->getIngestionJobKey())
							+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
							+ ", _processorThreads + _maxAdditionalProcessorThreads: "
							+ to_string(_processorThreads + _maxAdditionalProcessorThreads)
						);
            
						{
							shared_ptr<LocalAssetIngestionEvent>    cloneLocalAssetIngestionEvent
								= _multiEventsSet->getEventsFactory()->getFreeEvent<LocalAssetIngestionEvent>(
										MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);

							cloneLocalAssetIngestionEvent->setSource(
								localAssetIngestionEvent->getSource());
							cloneLocalAssetIngestionEvent->setDestination(
								localAssetIngestionEvent->getDestination());
							// 2019-11-15: it is important this message will expire later.
							//	Before this change (+ 5 seconds), the event expires istantly and we have file system full "
							//	because of the two messages
							//		- Not enough available threads... and
							//		- addEvent: EVENT_TYPE...
							cloneLocalAssetIngestionEvent->setExpirationTimePoint(
								chrono::system_clock::now() + chrono::seconds(5));

							cloneLocalAssetIngestionEvent->setExternalReadOnlyStorage(
								localAssetIngestionEvent->getExternalReadOnlyStorage());
							cloneLocalAssetIngestionEvent->setExternalStorageMediaSourceURL(
								localAssetIngestionEvent->getExternalStorageMediaSourceURL());
							cloneLocalAssetIngestionEvent->setIngestionJobKey(
								localAssetIngestionEvent->getIngestionJobKey());
							cloneLocalAssetIngestionEvent->setIngestionSourceFileName(
								localAssetIngestionEvent->getIngestionSourceFileName());
							cloneLocalAssetIngestionEvent->setMMSSourceFileName(
								localAssetIngestionEvent->getMMSSourceFileName());
							cloneLocalAssetIngestionEvent->setForcedAvgFrameRate(
								localAssetIngestionEvent->getForcedAvgFrameRate());
							cloneLocalAssetIngestionEvent->setWorkspace(
								localAssetIngestionEvent->getWorkspace());
							cloneLocalAssetIngestionEvent->setIngestionType(
								localAssetIngestionEvent->getIngestionType());
							cloneLocalAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(
								localAssetIngestionEvent->getIngestionRowToBeUpdatedAsSuccess());

							cloneLocalAssetIngestionEvent->setMetadataContent(
								localAssetIngestionEvent->getMetadataContent());

							shared_ptr<Event2>    cloneEvent = dynamic_pointer_cast<Event2>(
									cloneLocalAssetIngestionEvent);
							_multiEventsSet->addEvent(cloneEvent);

							_logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (INGESTASSETEVENT)"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", getEventKey().first: " + to_string(event->getEventKey().first)
								+ ", getEventKey().second: " + to_string(event->getEventKey().second));
						}
					}
					else
					*/
					{
						// handleLocalAssetIngestionEvent (localAssetIngestionEvent);
                        thread handleLocalAssetIngestionEventThread(
							&MMSEngineProcessor::handleLocalAssetIngestionEventThread,
							this, _processorsThreadsNumber, *localAssetIngestionEvent);
                        handleLocalAssetIngestionEventThread.detach();
					}
                }
                catch(runtime_error e)
                {
                    _logger->error(__FILEREF__ + "handleLocalAssetIngestionEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleLocalAssetIngestionEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<LocalAssetIngestionEvent>(
						localAssetIngestionEvent);

                _logger->debug(__FILEREF__ + "2. Received LOCALASSETINGESTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_CHECKENCODINGEVENT:	// 3
            {
                _logger->debug(__FILEREF__ + "1. Received MMSENGINE_EVENTTYPEIDENTIFIER_CHECKENCODING"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                try
                {
                    handleCheckEncodingEvent ();
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleCheckEncodingEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<Event2>(event);

                _logger->debug(__FILEREF__ + "2. Received MMSENGINE_EVENTTYPEIDENTIFIER_CHECKENCODING"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_CONTENTRETENTIONEVENT:	// 4
            {
                _logger->debug(__FILEREF__ + "1. Received MMSENGINE_EVENTTYPEIDENTIFIER_CONTENTRETENTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                try
                {
					int maxAdditionalProcessorThreads = getMaxAdditionalProcessorThreads();
                    if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
                    {
                        // content retention is a periodical event, we will wait the next one
                        
                        _logger->warn(__FILEREF__ + "Not enough available threads to manage handleContentRetentionEventThread, activity is postponed"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                            + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                        );
                    }
                    else
                    {
                        thread contentRetention(&MMSEngineProcessor::handleContentRetentionEventThread, this,
                            _processorsThreadsNumber);
                        contentRetention.detach();
                    }
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleContentRetentionEventThread failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<Event2>(event);

                _logger->debug(__FILEREF__ + "2. Received MMSENGINE_EVENTTYPEIDENTIFIER_CONTENTRETENTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_MULTILOCALASSETINGESTIONEVENT:	// 5
            {
                _logger->debug(__FILEREF__ + "1. Received MULTILOCALASSETINGESTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                shared_ptr<MultiLocalAssetIngestionEvent>    multiLocalAssetIngestionEvent
					= dynamic_pointer_cast<MultiLocalAssetIngestionEvent>(event);

                try
                {
					/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
					if (_processorsThreadsNumber.use_count() > _processorThreads + _maxAdditionalProcessorThreads)
					{
						_logger->warn(__FILEREF__
							+ "Not enough available threads to manage handleLocalAssetIngestionEvent, activity is postponed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent->getIngestionJobKey())
							+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
							+ ", _processorThreads + _maxAdditionalProcessorThreads: "
							+ to_string(_processorThreads + _maxAdditionalProcessorThreads)
						);

						{
							shared_ptr<MultiLocalAssetIngestionEvent>    cloneMultiLocalAssetIngestionEvent
								= _multiEventsSet->getEventsFactory()->getFreeEvent<MultiLocalAssetIngestionEvent>(
										MMSENGINE_EVENTTYPEIDENTIFIER_MULTILOCALASSETINGESTIONEVENT);

							cloneMultiLocalAssetIngestionEvent->setSource(
								multiLocalAssetIngestionEvent->getSource());
							cloneMultiLocalAssetIngestionEvent->setDestination(
								multiLocalAssetIngestionEvent->getDestination());
							// 2019-11-15: it is important this message will expire later.
							//	Before this change (+ 5 seconds), the event expires istantly and we have file system full "
							//	because of the two messages
							//	- Not enough available threads... and
							//	- addEvent: EVENT_TYPE...
							cloneMultiLocalAssetIngestionEvent->setExpirationTimePoint(
								chrono::system_clock::now() + chrono::seconds(5));

							cloneMultiLocalAssetIngestionEvent->setIngestionJobKey(
								multiLocalAssetIngestionEvent->getIngestionJobKey());
							cloneMultiLocalAssetIngestionEvent->setEncodingJobKey(
								multiLocalAssetIngestionEvent->getEncodingJobKey());
							cloneMultiLocalAssetIngestionEvent->setWorkspace(
								multiLocalAssetIngestionEvent->getWorkspace());
							cloneMultiLocalAssetIngestionEvent->setParametersRoot(
								multiLocalAssetIngestionEvent->getParametersRoot());

							shared_ptr<Event2>    cloneEvent = dynamic_pointer_cast<Event2>(
									cloneMultiLocalAssetIngestionEvent);
							_multiEventsSet->addEvent(cloneEvent);

							_logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (MULTIINGESTASSETEVENT)"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", getEventKey().first: " + to_string(event->getEventKey().first)
								+ ", getEventKey().second: " + to_string(event->getEventKey().second));
						}
					}
					else
					*/
					{
						// handleMultiLocalAssetIngestionEvent (multiLocalAssetIngestionEvent);
                        thread handleMultiLocalAssetIngestionEventThread(
								&MMSEngineProcessor::handleMultiLocalAssetIngestionEventThread, this,
                            _processorsThreadsNumber, *multiLocalAssetIngestionEvent);
                        handleMultiLocalAssetIngestionEventThread.detach();
					}
                }
                catch(runtime_error e)
                {
                    _logger->error(__FILEREF__ + "handleMultiLocalAssetIngestionEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleMultiLocalAssetIngestionEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<MultiLocalAssetIngestionEvent>(multiLocalAssetIngestionEvent);

                _logger->debug(__FILEREF__ + "2. Received MULTILOCALASSETINGESTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_DBDATARETENTIONEVENT:	// 7
            {
                _logger->debug(__FILEREF__ + "1. Received MMSENGINE_EVENTTYPEIDENTIFIER_DBDATARETENTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                try
                {
					/* 2019-07-10: this check was removed since this event happens once a day
                    if (_processorsThreadsNumber.use_count() > _processorThreads + _maxAdditionalProcessorThreads)
                    {
                        // content retention is a periodical event, we will wait the next one
                        
                        _logger->warn(__FILEREF__ + "Not enough available threads to manage handleContentRetentionEventThread, activity is postponed"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                            + ", _processorThreads + _maxAdditionalProcessorThreads: " + to_string(_processorThreads + _maxAdditionalProcessorThreads)
                        );
                    }
                    else
					*/
                    {
                        thread dbDataRetention(&MMSEngineProcessor::handleDBDataRetentionEventThread, this);
                        dbDataRetention.detach();
                    }
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleDBDataRetentionEventThread failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<Event2>(event);

                _logger->debug(__FILEREF__ + "2. Received MMSENGINE_EVENTTYPEIDENTIFIER_DBDATARETENTIONEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_CHECKREFRESHPARTITIONFREESIZEEVENT:	// 8
            {
                _logger->debug(__FILEREF__ + "1. Received MMSENGINE_EVENTTYPEIDENTIFIER_CHECKREFRESHPARTITIONFREESIZEEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                try
                {
					/* 2019-07-10: this check was removed since this event happens once a day
                    if (_processorsThreadsNumber.use_count() > _processorThreads + _maxAdditionalProcessorThreads)
                    {
                        // content retention is a periodical event, we will wait the next one
                        
                        _logger->warn(__FILEREF__ + "Not enough available threads to manage handleContentRetentionEventThread, activity is postponed"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                            + ", _processorThreads + _maxAdditionalProcessorThreads: " + to_string(_processorThreads + _maxAdditionalProcessorThreads)
                        );
                    }
                    else
					*/
                    {
                        thread checkRefreshPartitionFreeSize(&MMSEngineProcessor::handleCheckRefreshPartitionFreeSizeEventThread,
								this);
                        checkRefreshPartitionFreeSize.detach();
                    }
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "handleCheckRefreshPartitionFreeSizeEvent failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<Event2>(event);

                _logger->debug(__FILEREF__ + "2. Received MMSENGINE_EVENTTYPEIDENTIFIER_CHECKREFRESHPARTITIONFREESIZEEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            case MMSENGINE_EVENTTYPEIDENTIFIER_THREADSSTATISTICEVENT:	// 9
            {
                _logger->debug(__FILEREF__ + "1. Received MMSENGINE_EVENTTYPEIDENTIFIER_THREADSSTATISTICEVENT"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );

                try
                {
					_mmsThreadsStatistic->logRunningThreads();
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "_mmsThreadsStatistic->logRunningThreads failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                    );
                }

                _multiEventsSet->getEventsFactory()->releaseEvent<Event2>(event);

                _logger->debug(__FILEREF__ + "2. Received MMSENGINE_EVENTTYPEIDENTIFIER_THREADSSTATISTICEVENT:"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                );
            }
            break;
            default:
                throw runtime_error(string("Event type identifier not managed")
                        + to_string(event->getEventKey().first));
        }

		chrono::system_clock::time_point endEvent = chrono::system_clock::now();
		long elapsedInSeconds = chrono::duration_cast<chrono::seconds>(endEvent - startEvent).count();

		if (elapsedInSeconds > _maxEventManagementTimeInSeconds)
			_logger->warn(__FILEREF__ + "MMSEngineProcessor. Event management took too time"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", event id: " + to_string(event->getEventKey().first)
				+ ", _maxEventManagementTimeInSeconds: " + to_string(_maxEventManagementTimeInSeconds)
				+ ", @MMS statistics@ - elapsed in seconds: @" + to_string(elapsedInSeconds) + "@"
		);
    }

    _logger->info(__FILEREF__ + "MMSEngineProcessor thread terminated"
        + ", _processorIdentifier: " + to_string(_processorIdentifier)
    );
}

int MMSEngineProcessor::getMaxAdditionalProcessorThreads()
{
	lock_guard<mutex> locker(*_cpuUsageMutex);

	// int maxAdditionalProcessorThreads = VECTOR_MAX_CAPACITY;	// it could be done
	int maxAdditionalProcessorThreads = 20;	// it could be done

	for(int cpuUsage: *_cpuUsage)
	{
		if (cpuUsage > _cpuUsageThreshold)
		{
			maxAdditionalProcessorThreads = 0;			// no to be done

			break;
		}
	}

	string lastCPUUsage;
	for(int cpuUsage: *_cpuUsage)
		lastCPUUsage += (to_string(cpuUsage) + " ");
    _logger->info(__FILEREF__ + "getMaxAdditionalProcessorThreads"
        + ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", lastCPUUsage: " + lastCPUUsage
        + ", maxAdditionalProcessorThreads: " + to_string(maxAdditionalProcessorThreads)
    );


	return maxAdditionalProcessorThreads;
}

void MMSEngineProcessor::cpuUsageThread()
{

	int64_t counter = 0;

	while(!_cpuUsageThreadShutdown)
	{
		this_thread::sleep_for(chrono::milliseconds(50));

		try
		{
			lock_guard<mutex> locker(*_cpuUsageMutex);

			_cpuUsage->pop_back();
			_cpuUsage->push_front(_getCpuUsage.getCpuUsage());
			// *_cpuUsage = _getCpuUsage.getCpuUsage();

			if (++counter % 100 == 0)
			{
				string lastCPUUsage;
				for(int cpuUsage: *_cpuUsage)
					lastCPUUsage += (to_string(cpuUsage) + " ");

				_logger->info(__FILEREF__ + "cpuUsageThread"
					+ ", lastCPUUsage: " + lastCPUUsage
				);
			}
		}
		catch(runtime_error e)
		{
			string errorMessage = string ("cpuUsage thread failed")
				+ ", e.what(): " + e.what()
			;

			_logger->error(__FILEREF__ + errorMessage);
		}
		catch(exception e)
		{
			string errorMessage = string ("cpuUsage thread failed")
				+ ", e.what(): " + e.what()
			;

			_logger->error(__FILEREF__ + errorMessage);
		}
	}
}

void MMSEngineProcessor::stopCPUUsageThread()
{

	_cpuUsageThreadShutdown = true;

	this_thread::sleep_for(chrono::seconds(1));
}

void MMSEngineProcessor::handleCheckIngestionEvent()
{

    try
    {
		if (isMaintenanceMode())
		{
			_logger->info(__FILEREF__
				+ "Received handleCheckIngestionEvent, not managed it because of MaintenanceMode"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			return;
		}

        vector<tuple<int64_t, string, shared_ptr<Workspace>, string, string,
			MMSEngineDBFacade::IngestionType, MMSEngineDBFacade::IngestionStatus>> 
                ingestionsToBeManaged;

        try
        {
			// getIngestionsToBeManaged
			//	- in case we reached the max number of threads in MMS Engine,
			//		we still have to call getIngestionsToBeManaged
			//		but it has to return ONLY tasks that do not involve creation of threads
			//		(a lot of important tasks
			//		do not involve threads in MMS Engine)
			//	That is to avoid to block every thing in case we reached the max number of threads
			//	in MMS Engine
			bool onlyTasksNotInvolvingMMSEngineThreads = false;

			int maxAdditionalProcessorThreads = getMaxAdditionalProcessorThreads();
			if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
			{
				_logger->warn(__FILEREF__
					+ "Not enough available threads to manage Tasks involving more threads"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", _processorsThreadsNumber.use_count(): "
						+ to_string(_processorsThreadsNumber.use_count())
					+ ", _processorThreads + maxAdditionalProcessorThreads: "
						+ to_string(_processorThreads + maxAdditionalProcessorThreads)
				);

				onlyTasksNotInvolvingMMSEngineThreads = true;
			}

			_mmsEngineDBFacade->getIngestionsToBeManaged(ingestionsToBeManaged, 
				_processorMMS, _maxIngestionJobsPerEvent, _timeBeforeToPrepareResourcesInMinutes,
				onlyTasksNotInvolvingMMSEngineThreads
            );

            _logger->info(__FILEREF__ + "getIngestionsToBeManaged result"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionsToBeManaged.size: " + to_string(ingestionsToBeManaged.size())
            );
        }
        catch(AlreadyLocked e)
        {
            _logger->warn(__FILEREF__ + "getIngestionsToBeManaged failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", exception: " + e.what()
            );

			return;
            // throw e;
        }
        catch(runtime_error e)
        {
            _logger->error(__FILEREF__ + "getIngestionsToBeManaged failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", exception: " + e.what()
            );

            throw e;
        }
        catch(exception e)
        {
            _logger->error(__FILEREF__ + "getIngestionsToBeManaged failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", exception: " + e.what()
            );

            throw e;
        }
        
        for (tuple<int64_t, string, shared_ptr<Workspace>, string, string,
				MMSEngineDBFacade::IngestionType, MMSEngineDBFacade::IngestionStatus> 
                ingestionToBeManaged: ingestionsToBeManaged)
        {
            int64_t ingestionJobKey;
            try
            {
                string ingestionJobLabel;
                shared_ptr<Workspace> workspace;
                string ingestionDate;
                string metaDataContent;
                string sourceReference;
                MMSEngineDBFacade::IngestionType ingestionType;
                MMSEngineDBFacade::IngestionStatus ingestionStatus;

                tie(ingestionJobKey, ingestionJobLabel, workspace, ingestionDate, metaDataContent,
					ingestionType, ingestionStatus) = ingestionToBeManaged;

                _logger->info(__FILEREF__ + "json to be processed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", ingestionJobLabel: " + ingestionJobLabel
                    + ", workspace->_workspaceKey: " + to_string(workspace->_workspaceKey)
                    + ", ingestionDate: " + ingestionDate
                    + ", ingestionType: " + MMSEngineDBFacade::toString(ingestionType)
                    + ", ingestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                    + ", metaDataContent: " + metaDataContent
                );

                try
                {
					if (ingestionType != MMSEngineDBFacade::IngestionType::RemoveContent)
					{
						_mmsEngineDBFacade->checkWorkspaceStorageAndMaxIngestionNumber (
                            workspace->_workspaceKey);
					}
                }
                catch(runtime_error e)
                {
                    _logger->error(__FILEREF__ + "checkWorkspaceStorageAndMaxIngestionNumber failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", exception: " + e.what()
                    );
                    string errorMessage = e.what();

                    _logger->info(__FILEREF__ + "Update IngestionJob"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", IngestionStatus: " + "End_WorkspaceReachedMaxStorageOrIngestionNumber"
                        + ", errorMessage: " + e.what()
                    );                            
					try
					{
						_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                            MMSEngineDBFacade::IngestionStatus::End_WorkspaceReachedMaxStorageOrIngestionNumber,
                            e.what()
						);
					}
					catch(runtime_error& re)
					{
						_logger->info(__FILEREF__ + "Update IngestionJob failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_WorkspaceReachedMaxStorageOrIngestionNumber"
							+ ", errorMessage: " + re.what()
						);
					}
					catch(exception ex)
					{
						_logger->info(__FILEREF__ + "Update IngestionJob failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_WorkspaceReachedMaxStorageOrIngestionNumber"
							+ ", errorMessage: " + ex.what()
						);
					}

                    throw e;
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "checkWorkspaceStorageAndMaxIngestionNumber failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", exception: " + e.what()
                    );
                    string errorMessage = e.what();

                    _logger->info(__FILEREF__ + "Update IngestionJob"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", IngestionStatus: " + "End_WorkspaceReachedMaxStorageOrIngestionNumber"
                        + ", errorMessage: " + e.what()
                    );                            
					try
					{
						_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                            MMSEngineDBFacade::IngestionStatus::End_WorkspaceReachedMaxStorageOrIngestionNumber,
                            e.what()
						);
					}
					catch(runtime_error& re)
					{
						_logger->info(__FILEREF__ + "Update IngestionJob failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_WorkspaceReachedMaxStorageOrIngestionNumber"
							+ ", errorMessage: " + re.what()
						);
					}
					catch(exception ex)
					{
						_logger->info(__FILEREF__ + "Update IngestionJob failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_WorkspaceReachedMaxStorageOrIngestionNumber"
							+ ", errorMessage: " + ex.what()
						);
					}

                    throw e;
                }
                
                if (ingestionStatus == MMSEngineDBFacade::IngestionStatus::SourceDownloadingInProgress
                        || ingestionStatus == MMSEngineDBFacade::IngestionStatus::SourceMovingInProgress
                        || ingestionStatus == MMSEngineDBFacade::IngestionStatus::SourceCopingInProgress
                        || ingestionStatus == MMSEngineDBFacade::IngestionStatus::SourceUploadingInProgress)
                {
                    // source binary download or uploaded terminated

                    string sourceFileName = to_string(ingestionJobKey) + "_source";

                    {
                        shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent
							= _multiEventsSet->getEventsFactory()
								->getFreeEvent<LocalAssetIngestionEvent>(
										MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);

                        localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
                        localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
                        localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

						localAssetIngestionEvent->setExternalReadOnlyStorage(false);
                        localAssetIngestionEvent->setIngestionJobKey(ingestionJobKey);
                        localAssetIngestionEvent->setIngestionSourceFileName(sourceFileName);
                        localAssetIngestionEvent->setMMSSourceFileName("");
                        localAssetIngestionEvent->setWorkspace(workspace);
                        localAssetIngestionEvent->setIngestionType(ingestionType);
                        localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(true);

                        localAssetIngestionEvent->setMetadataContent(metaDataContent);

                        shared_ptr<Event2>    event = dynamic_pointer_cast<Event2>(
							localAssetIngestionEvent);
                        _multiEventsSet->addEvent(event);

                        _logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (INGESTASSETEVENT)"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", getEventKey().first: " + to_string(event->getEventKey().first)
                            + ", getEventKey().second: " + to_string(event->getEventKey().second));
                    }
                }
                else    // Start_TaskQueued
                {
                    Json::Value parametersRoot;
                    try
                    {
                        Json::CharReaderBuilder builder;
                        Json::CharReader* reader = builder.newCharReader();
                        string errors;

                        bool parsingSuccessful = reader->parse(metaDataContent.c_str(),
                                metaDataContent.c_str() + metaDataContent.size(), 
                                &parametersRoot, &errors);
                        delete reader;

                        if (!parsingSuccessful)
                        {
                            string errorMessage = __FILEREF__ + "failed to parse the metadata"
                                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", errors: " + errors
                                    + ", metaDataContent: " + metaDataContent
                                    ;
                            _logger->error(errorMessage);

                            throw runtime_error(errorMessage);
                        }
                    }
                    catch(...)
                    {
                        string errorMessage = string("metadata json is not well format")
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", metaDataContent: " + metaDataContent
                                ;
                        _logger->error(__FILEREF__ + errorMessage);

                        _logger->info(__FILEREF__ + "Update IngestionJob"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
                            + ", errorMessage: " + errorMessage
                            + ", processorMMS: " + ""
                        );
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed, 
                                errorMessage
							);
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
								+ ", errorMessage: " + re.what()
							);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
								+ ", errorMessage: " + ex.what()
							);
						}

                        throw runtime_error(errorMessage);
                    }

                    vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType,
						bool>> dependencies;

                    try
                    {
                        Validator validator(_logger, _mmsEngineDBFacade, _configuration);
						if (ingestionType == MMSEngineDBFacade::IngestionType::GroupOfTasks)
							validator.validateGroupOfTasksMetadata(
                                workspace->_workspaceKey, parametersRoot);                        
						else
							dependencies = validator.validateSingleTaskMetadata(
                                workspace->_workspaceKey, ingestionType, parametersRoot);
                    }
                    catch(runtime_error e)
                    {
                        _logger->error(__FILEREF__ + "validateMetadata failed"
                                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", exception: " + e.what()
                        );

                        string errorMessage = e.what();

                        _logger->info(__FILEREF__ + "Update IngestionJob"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
                            + ", errorMessage: " + errorMessage
                            + ", processorMMS: " + ""
                        );
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed, 
                                errorMessage
							);
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
								+ ", errorMessage: " + re.what()
							);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
								+ ", errorMessage: " + ex.what()
							);
						}

                        throw runtime_error(errorMessage);
                    }
                    catch(exception e)
                    {
                        _logger->error(__FILEREF__ + "validateMetadata failed"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", exception: " + e.what()
                        );

                        string errorMessage = e.what();

                        _logger->info(__FILEREF__ + "Update IngestionJob"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
                            + ", errorMessage: " + errorMessage
                            + ", processorMMS: " + ""
                        );
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed, 
                                errorMessage
							);
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
								+ ", errorMessage: " + re.what()
							);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
								+ ", errorMessage: " + ex.what()
							);
						}

                        throw runtime_error(errorMessage);
                    }

                    {
                        if (ingestionType == MMSEngineDBFacade::IngestionType::GroupOfTasks)
                        {
                            try
                            {
                                manageGroupOfTasks(
									ingestionJobKey, 
									workspace, 
									parametersRoot);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageGroupOfTasks failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageGroupOfTasks failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
						else if (ingestionType == MMSEngineDBFacade::IngestionType::AddContent)
                        {
                            MMSEngineDBFacade::IngestionStatus nextIngestionStatus;
                            string mediaSourceURL;
                            string mediaFileFormat;
                            string md5FileCheckSum;
                            int fileSizeInBytes;
							bool externalReadOnlyStorage;
                            try
                            {
                                tuple<MMSEngineDBFacade::IngestionStatus, string, string, string, int, bool>
									mediaSourceDetails = getMediaSourceDetails(
                                        ingestionJobKey, workspace,
                                        ingestionType, parametersRoot);

                                tie(nextIngestionStatus, mediaSourceURL, mediaFileFormat, 
									md5FileCheckSum, fileSizeInBytes, externalReadOnlyStorage) =
									mediaSourceDetails;                        
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "getMediaSourceDetails failed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "getMediaSourceDetails failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }

                            try
                            {
								if (externalReadOnlyStorage)
								{
									shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent =
										_multiEventsSet->getEventsFactory()->
										getFreeEvent<LocalAssetIngestionEvent>(
											MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);

									localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
									localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
									localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

									localAssetIngestionEvent->setExternalReadOnlyStorage(true);
									localAssetIngestionEvent->setExternalStorageMediaSourceURL(mediaSourceURL);
									localAssetIngestionEvent->setIngestionJobKey(ingestionJobKey);
									// localAssetIngestionEvent->setIngestionSourceFileName(sourceFileName);
									// localAssetIngestionEvent->setMMSSourceFileName("");
									localAssetIngestionEvent->setWorkspace(workspace);
									localAssetIngestionEvent->setIngestionType(ingestionType);
									localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(true);

									localAssetIngestionEvent->setMetadataContent(metaDataContent);

									shared_ptr<Event2>    event = dynamic_pointer_cast<Event2>(localAssetIngestionEvent);
									_multiEventsSet->addEvent(event);

									_logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (INGESTASSETEVENT)"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", getEventKey().first: " + to_string(event->getEventKey().first)
										+ ", getEventKey().second: " + to_string(event->getEventKey().second));
								}
								else
								{
									// 0: no m3u8
									// 1: m3u8 by .tar.gz
									// 2: m3u8 by streaming (it will be saved as .mp4)
									int m3u8TarGzOrM3u8Streaming = 0;
									if (mediaFileFormat == "m3u8-tar.gz")
										m3u8TarGzOrM3u8Streaming = 1;
									else if (mediaFileFormat == "m3u8-streaming")
										m3u8TarGzOrM3u8Streaming = 2;

									if (nextIngestionStatus ==
										MMSEngineDBFacade::IngestionStatus::SourceDownloadingInProgress)
									{
										/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
										* 2021-06-19: we still have to check the thread limit because,
										*		in case handleCheckIngestionEvent gets 20 events,
										*		we have still to postpone all the events overcoming the thread limit
										*/
										int maxAdditionalProcessorThreads =
											getMaxAdditionalProcessorThreads();
										if (_processorsThreadsNumber.use_count() >
											_processorThreads + maxAdditionalProcessorThreads)
										{
											_logger->warn(__FILEREF__ + "Not enough available threads to manage downloadMediaSourceFileThread, activity is postponed"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
												+ ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
											);

											string errorMessage = "";
											string processorMMS = "";

											_logger->info(__FILEREF__ + "Update IngestionJob"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
												+ ", errorMessage: " + errorMessage
												+ ", processorMMS: " + processorMMS
											);
											_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                                ingestionStatus,
                                                errorMessage,
                                                processorMMS
                                                );
										}
										else
										{
											string errorMessage = "";
											string processorMMS = "";

											_logger->info(__FILEREF__ + "Update IngestionJob"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", IngestionStatus: " + MMSEngineDBFacade::toString(nextIngestionStatus)
												+ ", errorMessage: " + errorMessage
												+ ", processorMMS: " + processorMMS
											);                            
											_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                                nextIngestionStatus,
                                                errorMessage,
                                                processorMMS
                                                );

											// 2021-09-02: regenerateTimestamps is used only
											//	in case of m3u8-streaming
											//	(see docs/TASK_01_Add_Content_JSON_Format.txt)
											bool regenerateTimestamps = false;
											if (mediaFileFormat == "m3u8-streaming")
												regenerateTimestamps = JSONUtils::asBool(
													parametersRoot, "RegenerateTimestamps", false);

											thread downloadMediaSource(&MMSEngineProcessor::downloadMediaSourceFileThread, this, 
												_processorsThreadsNumber, mediaSourceURL, regenerateTimestamps, m3u8TarGzOrM3u8Streaming,
												ingestionJobKey, workspace);
											downloadMediaSource.detach();
										}
									}
									else if (nextIngestionStatus ==
										MMSEngineDBFacade::IngestionStatus::SourceMovingInProgress)
									{
										/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
										* 2021-06-19: we still have to check the thread limit because,
										*		in case handleCheckIngestionEvent gets 20 events,
										*		we have still to postpone all the events overcoming the thread limit
										*/
										int maxAdditionalProcessorThreads =
											getMaxAdditionalProcessorThreads();
										if (_processorsThreadsNumber.use_count() >
											_processorThreads + maxAdditionalProcessorThreads)
										{
											_logger->warn(__FILEREF__
												+ "Not enough available threads to manage moveMediaSourceFileThread, activity is postponed"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", _processorsThreadsNumber.use_count(): "
												+ to_string(_processorsThreadsNumber.use_count())
												+ ", _processorThreads + maxAdditionalProcessorThreads: "
												+ to_string(_processorThreads + maxAdditionalProcessorThreads)
											);

											string errorMessage = "";
											string processorMMS = "";

											_logger->info(__FILEREF__ + "Update IngestionJob"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
												+ ", errorMessage: " + errorMessage
												+ ", processorMMS: " + processorMMS
											);
											_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                                ingestionStatus,
                                                errorMessage,
                                                processorMMS
                                                );
										}
										else
										{
											string errorMessage = "";
											string processorMMS = "";

											_logger->info(__FILEREF__ + "Update IngestionJob"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", IngestionStatus: " + MMSEngineDBFacade::toString(nextIngestionStatus)
												+ ", errorMessage: " + errorMessage
												+ ", processorMMS: " + processorMMS
											);
											_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                                nextIngestionStatus,
                                                errorMessage,
                                                processorMMS
                                                );
                                        
											thread moveMediaSource(&MMSEngineProcessor::moveMediaSourceFileThread, this, 
												_processorsThreadsNumber, mediaSourceURL, m3u8TarGzOrM3u8Streaming, ingestionJobKey, workspace);
											moveMediaSource.detach();
										}
									}
									else if (nextIngestionStatus ==
										MMSEngineDBFacade::IngestionStatus::SourceCopingInProgress)
									{
										/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
										* 2021-06-19: we still have to check the thread limit because,
										*		in case handleCheckIngestionEvent gets 20 events,
										*		we have still to postpone all the events overcoming the thread limit
										*/
										int maxAdditionalProcessorThreads =
											getMaxAdditionalProcessorThreads();
										if (_processorsThreadsNumber.use_count() >
											_processorThreads + maxAdditionalProcessorThreads)
										{
											_logger->warn(__FILEREF__
												+ "Not enough available threads to manage copyMediaSourceFileThread, activity is postponed"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", _processorsThreadsNumber.use_count(): "
												+ to_string(_processorsThreadsNumber.use_count())
												+ ", _processorThreads + maxAdditionalProcessorThreads: "
												+ to_string(_processorThreads + maxAdditionalProcessorThreads)
											);

											string errorMessage = "";
											string processorMMS = "";

											_logger->info(__FILEREF__ + "Update IngestionJob"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
												+ ", errorMessage: " + errorMessage
												+ ", processorMMS: " + processorMMS
											);                            
											_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                                ingestionStatus, 
                                                errorMessage,
                                                processorMMS
                                                );
										}
										else
										{
											string errorMessage = "";
											string processorMMS = "";

											_logger->info(__FILEREF__ + "Update IngestionJob"
												+ ", _processorIdentifier: " + to_string(_processorIdentifier)
												+ ", ingestionJobKey: " + to_string(ingestionJobKey)
												+ ", IngestionStatus: "
												+ MMSEngineDBFacade::toString(nextIngestionStatus)
												+ ", errorMessage: " + errorMessage
												+ ", processorMMS: " + processorMMS
											);
											_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                                nextIngestionStatus, 
                                                errorMessage,
                                                processorMMS
                                                );

											thread copyMediaSource(&MMSEngineProcessor::copyMediaSourceFileThread, this, 
												_processorsThreadsNumber, mediaSourceURL, m3u8TarGzOrM3u8Streaming, ingestionJobKey, workspace);
											copyMediaSource.detach();
										}
									}
									else // if (nextIngestionStatus == MMSEngineDBFacade::IngestionStatus::SourceUploadingInProgress)
									{
										string errorMessage = "";
										string processorMMS = "";

										_logger->info(__FILEREF__ + "Update IngestionJob"
											+ ", _processorIdentifier: " + to_string(_processorIdentifier)
											+ ", ingestionJobKey: " + to_string(ingestionJobKey)
											+ ", IngestionStatus: " + MMSEngineDBFacade::toString(nextIngestionStatus)
											+ ", errorMessage: " + errorMessage
											+ ", processorMMS: " + processorMMS
										);                            
										_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            nextIngestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
									}
								}
                            }
                            catch(exception e)
                            {
                                string errorMessage = string("Downloading media source or update Ingestion job failed")
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                ;
                                _logger->error(__FILEREF__ + errorMessage);

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::RemoveContent)
                        {
                            // mediaItemKeysDependency is present because checked by
							// _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/*
                                removeContentTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage removeContentThread, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread removeContentThread(&MMSEngineProcessor::removeContentThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
                                            workspace, 
                                            parametersRoot,
                                            dependencies    // it cannot be passed as reference because it will change soon by the parent thread
                                            );
                                    removeContentThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "removeContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									 _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "removeContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::FTPDelivery)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/*
                                ftpDeliveryContentTask(
                                        ingestionJobKey, 
                                        ingestionStatus,
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage ftpDeliveryContentThread, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
									thread ftpDeliveryContentThread(&MMSEngineProcessor::ftpDeliveryContentThread,
										this, _processorsThreadsNumber, ingestionJobKey, 
										workspace, parametersRoot,
										dependencies    // it cannot be passed as reference because it will change soon by the parent thread
									);
                                    ftpDeliveryContentThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "ftpDeliveryContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									 _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "ftpDeliveryContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::LocalCopy)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
                                if (!_localCopyTaskEnabled)
                                {
                                    string errorMessage = string("Local-Copy Task is not enabled in this MMS deploy")
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    ;
                                    _logger->error(__FILEREF__ + errorMessage);

                                    throw runtime_error(errorMessage);
                                }

								/*
								// threads check is done inside localCopyContentTask
                                localCopyContentTask(
                                        ingestionJobKey,
                                        ingestionStatus,
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage localCopyContent, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
									thread localCopyContentThread(&MMSEngineProcessor::localCopyContentThread,
										this, _processorsThreadsNumber, ingestionJobKey, 
										workspace, parametersRoot,
										dependencies    // it cannot be passed as reference because it will change soon by the parent thread
									);
                                    localCopyContentThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "localCopyContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "localCopyContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::HTTPCallback)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/*
								// threads check is done inside httpCallbackTask
                                httpCallbackTask(
                                        ingestionJobKey,
                                        ingestionStatus,
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage http callback, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
									thread httpCallbackThread(&MMSEngineProcessor::httpCallbackThread,
										this, _processorsThreadsNumber, ingestionJobKey, 
										workspace, parametersRoot,
										dependencies    // it cannot be passed as reference because it will change soon by the parent thread
									);
                                    httpCallbackThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "httpCallbackThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "httpCallbackThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::Encode)
                        {
                            try
                            {
                                manageEncodeTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageEncodeTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageEncodeTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::VideoSpeed)
                        {
                            try
                            {
                                manageVideoSpeedTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageVideoSpeedTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageVideoSpeedTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::PictureInPicture)
                        {
                            try
                            {
                                managePictureInPictureTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "managePictureInPictureTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "managePictureInPictureTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::IntroOutroOverlay)
                        {
                            try
                            {
                                manageIntroOutroOverlayTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageIntroOutroOverlayTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageIntroOutroOverlayTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::Frame
							|| ingestionType == MMSEngineDBFacade::IngestionType::PeriodicalFrames
							|| ingestionType == MMSEngineDBFacade::IngestionType::IFrames
							|| ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByPeriodicalFrames
							|| ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByIFrames
							)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
                                if (ingestionType == MMSEngineDBFacade::IngestionType::PeriodicalFrames
                                    || ingestionType == MMSEngineDBFacade::IngestionType::IFrames
                                    || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByPeriodicalFrames
                                    || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByIFrames)
                                {
									// adds an encoding job
                                    manageGenerateFramesTask(
                                        ingestionJobKey,
                                        workspace,
                                        ingestionType,
                                        parametersRoot,
                                        dependencies);
                                }
                                else // Frame
                                {
									/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
									* 2021-06-19: we still have to check the thread limit because,
									*		in case handleCheckIngestionEvent gets 20 events,
									*		we have still to postpone all the events overcoming the thread limit
									*/
									int maxAdditionalProcessorThreads =
										getMaxAdditionalProcessorThreads();
									if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
									{
										_logger->warn(__FILEREF__
											+ "Not enough available threads to manage changeFileFormatThread, activity is postponed"
											+ ", _processorIdentifier: " + to_string(_processorIdentifier)
											+ ", ingestionJobKey: " + to_string(ingestionJobKey)
											+ ", _processorsThreadsNumber.use_count(): "
												+ to_string(_processorsThreadsNumber.use_count())
											+ ", _processorThreads + maxAdditionalProcessorThreads: "
											+ to_string(_processorThreads + maxAdditionalProcessorThreads)
										);

										string errorMessage = "";
										string processorMMS = "";

										_logger->info(__FILEREF__ + "Update IngestionJob"
											+ ", _processorIdentifier: " + to_string(_processorIdentifier)
											+ ", ingestionJobKey: " + to_string(ingestionJobKey)
											+ ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
											+ ", errorMessage: " + errorMessage
											+ ", processorMMS: " + processorMMS
										);                            
										_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
									}
									else
									{
										thread generateAndIngestFrameThread(
											&MMSEngineProcessor::generateAndIngestFrameThread,
											this, _processorsThreadsNumber, ingestionJobKey, workspace,
											ingestionType,
											parametersRoot,
											// it cannot be passed as reference because it will change soon by the parent thread
											dependencies
										);
										generateAndIngestFrameThread.detach();
										/*
										generateAndIngestFramesTask(
											ingestionJobKey, 
											workspace, 
											ingestionType,
											parametersRoot, 
											dependencies);
										*/
									}
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestFramesTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestFramesTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::Slideshow)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
                                manageSlideShowTask(
                                        ingestionJobKey,
                                        workspace,
                                        parametersRoot,
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageSlideShowTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageSlideShowTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::ConcatDemuxer)
                        {
                            // mediaItemKeysDependency is present because checked by
							// _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
										_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage generateAndIngestConcatenationThread, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): "
											+ to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: "
											+ to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread generateAndIngestConcatenationThread(
										&MMSEngineProcessor::generateAndIngestConcatenationThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
										workspace, 
										parametersRoot,
										
										// it cannot be passed as reference because it will change soon
										// by the parent thread
										dependencies
									);
									generateAndIngestConcatenationThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestConcatenationThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestConcatenationThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::Cut)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage generateAndIngestCutMediaThread, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
									thread generateAndIngestCutMediaThread(
										&MMSEngineProcessor::generateAndIngestCutMediaThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
										workspace, 
										parametersRoot,
										dependencies    // it cannot be passed as reference because it will change soon by the parent thread
									);
									generateAndIngestCutMediaThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestCutMediaThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestCutMediaThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
							/*
                            try
                            {
                                generateAndIngestCutMediaTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestCutMediaTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "generateAndIngestCutMediaTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
							*/
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::ExtractTracks)
                        {
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage extractTracksContentThread, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread extractTracksContentThread(
										&MMSEngineProcessor::extractTracksContentThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
										workspace, 
										parametersRoot,
										dependencies    // it cannot be passed as reference because it will change soon by the parent thread
									);
                                    extractTracksContentThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "extractTracksContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "extractTracksContentThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::OverlayImageOnVideo)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
                                manageOverlayImageOnVideoTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageOverlayImageOnVideoTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageOverlayImageOnVideoTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::OverlayTextOnVideo)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
                                manageOverlayTextOnVideoTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageOverlayTextOnVideoTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageOverlayTextOnVideoTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::EmailNotification)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage email notification, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread emailNotificationThread(&MMSEngineProcessor::emailNotificationThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
                                            workspace, 
                                            parametersRoot,
                                            dependencies    // it cannot be passed as reference because it will change soon by the parent thread
                                            );
                                    emailNotificationThread.detach();
                                }
								/*
                                manageEmailNotificationTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "emailNotificationThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "emailNotificationThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::CheckStreaming)
                        {
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage check streaming, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread checkStreamingThread(&MMSEngineProcessor::checkStreamingThread,
										this, _processorsThreadsNumber, ingestionJobKey, 
										workspace, 
										parametersRoot
									);
                                    checkStreamingThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "checkStreamingThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "checkStreamingThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::MediaCrossReference)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
                                manageMediaCrossReferenceTask(
                                        ingestionJobKey, 
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageMediaCrossReferenceTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageMediaCrossReferenceTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::PostOnFacebook)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage post on facebook, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: " + to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread postOnFacebookThread(&MMSEngineProcessor::postOnFacebookThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
                                            workspace, 
                                            parametersRoot,
                                            dependencies    // it cannot be passed as reference because it will change soon by the parent thread
                                            );
                                    postOnFacebookThread.detach();
                                }
								/*
                                postOnFacebookTask(
                                        ingestionJobKey, 
                                        ingestionStatus,
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "postOnFacebookThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "postOnFacebookThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType ==
							MMSEngineDBFacade::IngestionType::PostOnYouTube)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads = getMaxAdditionalProcessorThreads();
                                if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__ + "Not enough available threads to manage post on youtube, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): "
											+ to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: "
											+ to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
                                }
                                else
                                {
                                    thread postOnYouTubeThread(&MMSEngineProcessor::postOnYouTubeThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
                                            workspace, 
                                            parametersRoot,
                                            dependencies    // it cannot be passed as reference because it will change soon by the parent thread
                                            );
                                    postOnYouTubeThread.detach();
                                }
								/*
                                postOnYouTubeTask(
                                        ingestionJobKey, 
                                        ingestionStatus,
                                        workspace, 
                                        parametersRoot, 
                                        dependencies);
								*/
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "postOnYouTubeTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "postOnYouTubeTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::FaceRecognition)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								manageFaceRecognitionMediaTask(
									ingestionJobKey, 
									ingestionStatus,
									workspace, 
									parametersRoot, 
									dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageFaceRecognitionMediaTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageFaceRecognitionMediaTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::FaceIdentification)
                        {
                            // mediaItemKeysDependency is present because checked
							// by _mmsEngineDBFacade->getIngestionsToBeManaged
                            try
                            {
								manageFaceIdentificationMediaTask(
									ingestionJobKey, 
									ingestionStatus,
									workspace, 
									parametersRoot, 
									dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageFaceIdentificationMediaTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageFaceIdentificationMediaTask failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::LiveRecorder)
                        {
                            try
                            {
								manageLiveRecorder(
									ingestionJobKey, 
									ingestionJobLabel,
									ingestionStatus,
									workspace, 
									parametersRoot);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageLiveRecorder failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageLiveRecorder failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType ==
							MMSEngineDBFacade::IngestionType::LiveProxy)
                        {
                            try
                            {
								manageLiveProxy(
									ingestionJobKey, 
									ingestionStatus,
									workspace, 
									parametersRoot);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageLiveProxy failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageLiveProxy failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::VODProxy)
                        {
                            try
                            {
								manageVODProxy(
									ingestionJobKey, 
									ingestionStatus,
									workspace, 
									parametersRoot,
									dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageVODProxy failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageVODProxy failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::Countdown)
                        {
                            try
                            {
								manageCountdown(
									ingestionJobKey, 
									ingestionStatus,
									ingestionDate,
									workspace, 
									parametersRoot,
									dependencies);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageCountdown failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageCountdown failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::LiveGrid)
                        {
                            try
                            {
								manageLiveGrid(
									ingestionJobKey, 
									ingestionStatus,
									workspace, 
									parametersRoot);
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "manageLiveGrid failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "manageLiveGrid failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::LiveCut)
                        {
							try
							{
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
								if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
								{
									_logger->warn(__FILEREF__ + "Not enough available threads to manage liveCutThread, activity is postponed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
										+ ", _processorThreads + maxAdditionalProcessorThreads: "
											+ to_string(_processorThreads + maxAdditionalProcessorThreads)
									);

									string errorMessage = "";
									string processorMMS = "";

									_logger->info(__FILEREF__ + "Update IngestionJob"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
										+ ", errorMessage: " + errorMessage
										+ ", processorMMS: " + processorMMS
									);                            
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
										ingestionStatus, 
										errorMessage,
										processorMMS
									);
								}
								else
								{
									string segmenterType = "hlsSegmenter";
									// string segmenterType = "streamSegmenter";
									if (segmenterType == "hlsSegmenter")
									{
										thread liveCutThread(
											&MMSEngineProcessor::liveCutThread_hlsSegmenter, this, 
											_processorsThreadsNumber,
											ingestionJobKey, ingestionJobLabel,
											workspace,
											parametersRoot
										);
										liveCutThread.detach();
									}
									else
									{
										thread liveCutThread(&MMSEngineProcessor::liveCutThread_streamSegmenter, this, 
											_processorsThreadsNumber, ingestionJobKey,
											workspace,
											parametersRoot
										);
										liveCutThread.detach();
									}
								}
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "liveCutThread failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", exception: " + e.what()
								);

								string errorMessage = e.what();

								_logger->info(__FILEREF__ + "Update IngestionJob"
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", IngestionStatus: " + "End_IngestionFailure"
									+ ", errorMessage: " + errorMessage
									+ ", processorMMS: " + ""
								);                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
										MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
										errorMessage
									);
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

								throw runtime_error(errorMessage);
							}
							catch(exception e)
							{
								_logger->error(__FILEREF__ + "liveCutThread failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", exception: " + e.what()
								);

								string errorMessage = e.what();

								_logger->info(__FILEREF__ + "Update IngestionJob"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", IngestionStatus: " + "End_IngestionFailure"
									+ ", errorMessage: " + errorMessage
									+ ", processorMMS: " + ""
								);                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
										MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
										errorMessage
									);
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

								throw runtime_error(errorMessage);
							}
						}
                        else if (ingestionType ==
							MMSEngineDBFacade::IngestionType::YouTubeLiveBroadcast)
                        {
							try
							{
								/* 2021-02-19: check on threads is already done
								 * in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming
								 *		the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
								if (_processorsThreadsNumber.use_count() >
									_processorThreads + maxAdditionalProcessorThreads)
								{
									_logger->warn(__FILEREF__
										+ "Not enough available threads to manage liveCutThread, activity is postponed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", _processorsThreadsNumber.use_count(): "
											+ to_string(_processorsThreadsNumber.use_count())
										+ ", _processorThreads + maxAdditionalProcessorThreads: "
											+ to_string(_processorThreads + maxAdditionalProcessorThreads)
									);

									string errorMessage = "";
									string processorMMS = "";

									_logger->info(__FILEREF__ + "Update IngestionJob"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: "
											+ MMSEngineDBFacade::toString(ingestionStatus)
										+ ", errorMessage: " + errorMessage
										+ ", processorMMS: " + processorMMS
									);                            
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
										ingestionStatus, 
										errorMessage,
										processorMMS
									);
								}
								else
								{
									thread youTubeLiveBroadcastThread(
										&MMSEngineProcessor::youTubeLiveBroadcastThread, this, 
										_processorsThreadsNumber,
										ingestionJobKey, ingestionJobLabel,
										workspace,
										parametersRoot
									);
									youTubeLiveBroadcastThread.detach();
								}
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "youTubeLiveBroadcastThread failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", exception: " + e.what()
								);

								string errorMessage = e.what();

								_logger->info(__FILEREF__ + "Update IngestionJob"
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", IngestionStatus: " + "End_IngestionFailure"
									+ ", errorMessage: " + errorMessage
									+ ", processorMMS: " + ""
								);                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
										MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
										errorMessage
									);
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

								throw runtime_error(errorMessage);
							}
							catch(exception e)
							{
								_logger->error(__FILEREF__ + "youTubeLiveBroadcastThread failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", exception: " + e.what()
								);

								string errorMessage = e.what();

								_logger->info(__FILEREF__ + "Update IngestionJob"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", IngestionStatus: " + "End_IngestionFailure"
									+ ", errorMessage: " + errorMessage
									+ ", processorMMS: " + ""
								);                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
										MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
										errorMessage
									);
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

								throw runtime_error(errorMessage);
							}
						}
                        else if (ingestionType == MMSEngineDBFacade::IngestionType::ChangeFileFormat)
                        {
                            try
                            {
								/* 2021-02-19: check on threads is already done in handleCheckIngestionEvent
								 * 2021-06-19: we still have to check the thread limit because,
								 *		in case handleCheckIngestionEvent gets 20 events,
								 *		we have still to postpone all the events overcoming the thread limit
								 */
								int maxAdditionalProcessorThreads =
									getMaxAdditionalProcessorThreads();
								if (_processorsThreadsNumber.use_count() > _processorThreads + maxAdditionalProcessorThreads)
                                {
                                    _logger->warn(__FILEREF__
											+ "Not enough available threads to manage changeFileFormatThread, activity is postponed"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
                                        + ", _processorThreads + maxAdditionalProcessorThreads: "
											+ to_string(_processorThreads + maxAdditionalProcessorThreads)
                                    );

                                    string errorMessage = "";
                                    string processorMMS = "";

                                    _logger->info(__FILEREF__ + "Update IngestionJob"
                                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", IngestionStatus: " + MMSEngineDBFacade::toString(ingestionStatus)
                                        + ", errorMessage: " + errorMessage
                                        + ", processorMMS: " + processorMMS
                                    );                            
                                    _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                            ingestionStatus, 
                                            errorMessage,
                                            processorMMS
                                            );
								}
								else
                                {
                                    thread changeFileFormatThread(&MMSEngineProcessor::changeFileFormatThread, this, 
                                        _processorsThreadsNumber, ingestionJobKey, 
                                            workspace, 
                                            parametersRoot,
                                            dependencies    // it cannot be passed as reference because it will change soon by the parent thread
                                            );
                                    changeFileFormatThread.detach();
                                }
                            }
                            catch(runtime_error e)
                            {
                                _logger->error(__FILEREF__ + "changeFileFormatThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                            catch(exception e)
                            {
                                _logger->error(__FILEREF__ + "changeFileFormatThread failed"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                        + ", exception: " + e.what()
                                );

                                string errorMessage = e.what();

                                _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", IngestionStatus: " + "End_IngestionFailure"
                                    + ", errorMessage: " + errorMessage
                                    + ", processorMMS: " + ""
                                );                            
								try
								{
									_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                        MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                                        errorMessage
                                        );
								}
								catch(runtime_error& re)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + re.what()
									);
								}
								catch(exception ex)
								{
									_logger->info(__FILEREF__ + "Update IngestionJob failed"
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", IngestionStatus: " + "End_IngestionFailure"
										+ ", errorMessage: " + ex.what()
									);
								}

                                throw runtime_error(errorMessage);
                            }
                        }
                        else
                        {
                            string errorMessage = string("Unknown IngestionType")
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                    + ", ingestionType: " + MMSEngineDBFacade::toString(ingestionType);
                            _logger->error(__FILEREF__ + errorMessage);

                            _logger->info(__FILEREF__ + "Update IngestionJob"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
                                + ", errorMessage: " + errorMessage
                                + ", processorMMS: " + ""
                            );                            
							try
							{
								_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                                    MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed, 
                                    errorMessage
                                    );
							}
							catch(runtime_error& re)
							{
								_logger->info(__FILEREF__ + "Update IngestionJob failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
									+ ", errorMessage: " + re.what()
								);
							}
							catch(exception ex)
							{
								_logger->info(__FILEREF__ + "Update IngestionJob failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
									+ ", errorMessage: " + ex.what()
								);
							}

                            throw runtime_error(errorMessage);
                        }
                    }
                }
            }
            catch(runtime_error e)
            {
                _logger->error(__FILEREF__ + "Exception managing the Ingestion entry"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", exception: " + e.what()
                );
            }
            catch(exception e)
            {
                _logger->error(__FILEREF__ + "Exception managing the Ingestion entry"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", exception: " + e.what()
                );
            }
        }

		if (ingestionsToBeManaged.size() >= _maxIngestionJobsPerEvent)
		{
			shared_ptr<Event2>    event = _multiEventsSet->getEventsFactory()->getFreeEvent<Event2>(
				MMSENGINE_EVENTTYPEIDENTIFIER_CHECKINGESTIONEVENT);

			event->setSource(MMSENGINEPROCESSORNAME);
			event->setDestination(MMSENGINEPROCESSORNAME);
			event->setExpirationTimePoint(chrono::system_clock::now());

			_multiEventsSet->addEvent(event);

			_logger->debug(__FILEREF__ + "addEvent: EVENT_TYPE"
					+ ", MMSENGINE_EVENTTYPEIDENTIFIER_CHECKINGESTION"
					+ ", getEventKey().first: " + to_string(event->getEventKey().first)
					+ ", getEventKey().second: " + to_string(event->getEventKey().second)
			);
		}
    }
    catch(...)
    {
        _logger->error(__FILEREF__ + "handleCheckIngestionEvent failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
        );
    }
}

void MMSEngineProcessor::handleLocalAssetIngestionEventThread (
		shared_ptr<long> processorsThreadsNumber,
    LocalAssetIngestionEvent localAssetIngestionEvent)
{

	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"handleLocalAssetIngestionEventThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		localAssetIngestionEvent.getIngestionJobKey()
	);

	_logger->info(__FILEREF__ + "handleLocalAssetIngestionEventThread"
		+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
		+ ", _processorsThreadsNumber.use_count(): "
			+ to_string(_processorsThreadsNumber.use_count())
	);

    Json::Value parametersRoot;
    try
    {
        Json::CharReaderBuilder builder;
        Json::CharReader* reader = builder.newCharReader();
        string errors;

        string sMetadataContent = localAssetIngestionEvent.getMetadataContent();
        
        // LF and CR create problems to the json parser...
        while (sMetadataContent.size() > 0
			&& (sMetadataContent.back() == 10 || sMetadataContent.back() == 13))
            sMetadataContent.pop_back();
        
        bool parsingSuccessful = reader->parse(sMetadataContent.c_str(),
                sMetadataContent.c_str() + sMetadataContent.size(), 
                &parametersRoot, &errors);
        delete reader;

        if (!parsingSuccessful)
        {
			string errorMessage = __FILEREF__ + "failed to parse the metadata"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errors: " + errors
				+ ", metaDataContent: " + sMetadataContent
			;
			_logger->error(errorMessage);

			throw runtime_error(errorMessage);
        }
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "parsing parameters failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
			+ ", localAssetIngestionEvent.getMetadataContent(): " + localAssetIngestionEvent.getMetadataContent()
			+ ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "validateMetadata failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				 MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed,
				 e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }

	string binaryPathName;
	string externalStorageRelativePathName;
    try
    {
		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			string workspaceIngestionBinaryPathName;

			workspaceIngestionBinaryPathName = _mmsStorage->getWorkspaceIngestionRepository(
				localAssetIngestionEvent.getWorkspace());
			workspaceIngestionBinaryPathName
				.append("/")
				.append(localAssetIngestionEvent.getIngestionSourceFileName())
			;

			binaryPathName = workspaceIngestionBinaryPathName;

			string field = "FileFormat";
			string fileFormat = parametersRoot.get(field, "").asString();
			if (fileFormat == "m3u8-streaming")
			{
				// .mp4 is used in
				// 1. downloadMediaSourceFileThread (when the m3u8-streaming is downloaded in a .mp4 file
				// 2. here, handleLocalAssetIngestionEventThread (when the IngestionRepository file name
				//		is built "consistent" with the above step no. 1)
				// 3. handleLocalAssetIngestionEventThread (when the MMS file name is generated)
				binaryPathName += ".mp4";
			}
		}
		else
		{
			string mediaSourceURL =
				localAssetIngestionEvent.getExternalStorageMediaSourceURL();

			string externalStoragePrefix("externalStorage://");
			if (!(mediaSourceURL.size() >= externalStoragePrefix.size()
					&& 0 == mediaSourceURL.compare(0, externalStoragePrefix.size(),
						externalStoragePrefix)))
			{
				string errorMessage = string("mediaSourceURL is not an externalStorage reference")
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", mediaSourceURL: " + mediaSourceURL 
				;

				_logger->error(__FILEREF__ + errorMessage);
            
				throw runtime_error(errorMessage);
			}
			externalStorageRelativePathName = mediaSourceURL.substr(externalStoragePrefix.length());
			binaryPathName = _mmsStorage->getMMSRootRepository()
				+"ExternalStorage_" + localAssetIngestionEvent.getWorkspace()->_directoryName
				+ externalStorageRelativePathName;
		}
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "binaryPathName initialization failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "binaryPathName initialization failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				 MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed,
				 e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }

	_logger->info(__FILEREF__ + "binaryPathName"
		+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
		+ ", binaryPathName: " + binaryPathName);

    string      metadataFileContent;
    Validator validator(_logger, _mmsEngineDBFacade, _configuration);
    try
    {
		vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies;

		dependencies = validator.validateSingleTaskMetadata(
			localAssetIngestionEvent.getWorkspace()->_workspaceKey,
			localAssetIngestionEvent.getIngestionType(),
			parametersRoot);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "validateMetadata failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", localAssetIngestionEvent.getMetadataContent(): " + localAssetIngestionEvent.getMetadataContent()
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", binaryPathName: " + binaryPathName
				);

				FileIO::remove(binaryPathName);
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "validateMetadata failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMetadataFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				 MMSEngineDBFacade::IngestionStatus::End_ValidationMetadataFailed,
				 e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMetadataFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", binaryPathName: " + binaryPathName
				);

				FileIO::remove(binaryPathName);
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
    }

    MMSEngineDBFacade::IngestionStatus nextIngestionStatus;
    string mediaFileFormat;
    string md5FileCheckSum;
    int fileSizeInBytes;
	bool externalReadOnlyStorage;
    try
    {
		string mediaSourceURL;

        tuple<MMSEngineDBFacade::IngestionStatus, string, string, string, int, bool>
            mediaSourceDetails = getMediaSourceDetails(
                localAssetIngestionEvent.getIngestionJobKey(),
                localAssetIngestionEvent.getWorkspace(),
                localAssetIngestionEvent.getIngestionType(), parametersRoot);
        
        tie(nextIngestionStatus,
                mediaSourceURL, mediaFileFormat, 
                md5FileCheckSum, fileSizeInBytes, externalReadOnlyStorage) = mediaSourceDetails;

		// in case of youtube url, the real URL to be used has to be calcolated
		// Here the mediaFileFormat is retrieved
		{
			string youTubePrefix1 ("https://www.youtube.com/");
			string youTubePrefix2 ("https://youtu.be/");
			if (
				(mediaSourceURL.size() >= youTubePrefix1.size()
					&& 0 == mediaSourceURL.compare(0, youTubePrefix1.size(), youTubePrefix1))
				||
				(mediaSourceURL.size() >= youTubePrefix2.size()
					&& 0 == mediaSourceURL.compare(0, youTubePrefix2.size(), youTubePrefix2))
				)
			{
				FFMpeg ffmpeg (_configuration, _logger);
				pair<string, string> streamingURLDetails =
					ffmpeg.retrieveStreamingYouTubeURL(
					localAssetIngestionEvent.getIngestionJobKey(),
					-1,
					mediaSourceURL);

				tie(ignore, mediaFileFormat) = streamingURLDetails;


				_logger->info(__FILEREF__ + "Retrieve streaming YouTube URL"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", initial YouTube URL: " + mediaSourceURL
				);
			}
		}
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "getMediaSourceDetails failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", binaryPathName: " + binaryPathName
				);

				FileIO::remove(binaryPathName);
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "getMediaSourceDetails failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", binaryPathName: " + binaryPathName
				);

				FileIO::remove(binaryPathName);
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
    }

    try
    {
        validateMediaSourceFile(
                localAssetIngestionEvent.getIngestionJobKey(),
                binaryPathName, mediaFileFormat,
                md5FileCheckSum, fileSizeInBytes);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "validateMediaSourceFile failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", binaryPathName: " + binaryPathName
				);

				FileIO::remove(binaryPathName);
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "validateMediaSourceFile failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", exception: " + e.what()
        );

        string errorMessage = e.what();

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_ValidationMediaSourceFailed,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_ValidationMediaSourceFailed"
				+ ", errorMessage: " + ex.what()
				);
		}

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", binaryPathName: " + binaryPathName
				);

				FileIO::remove(binaryPathName);
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
    }

	string mediaSourceFileName;
	string mmsAssetPathName;
	string relativePathToBeUsed;
	long mmsPartitionUsed;
	FileIO::DirectoryEntryType_t sourceFileType;
	try
	{
		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			mediaSourceFileName = localAssetIngestionEvent.getMMSSourceFileName();
			if (mediaSourceFileName == "")
			{
				mediaSourceFileName = localAssetIngestionEvent.getIngestionSourceFileName();
				// .mp4 is used in
				// 1. downloadMediaSourceFileThread (when the m3u8-streaming is downloaded in a .mp4 file
				// 2. handleLocalAssetIngestionEventThread (when the IngestionRepository file name
				//		is built "consistent" with the above step no. 1)
				// 3. here, handleLocalAssetIngestionEventThread (when the MMS file name is generated)
				if (mediaFileFormat == "m3u8-streaming")
					mediaSourceFileName += ".mp4";
				else
					mediaSourceFileName += ("." + mediaFileFormat);
			}

			relativePathToBeUsed = _mmsEngineDBFacade->nextRelativePathToBeUsed (
                localAssetIngestionEvent.getWorkspace()->_workspaceKey);
        
			unsigned long mmsPartitionIndexUsed;
			bool deliveryRepositoriesToo        = true;
			mmsAssetPathName = _mmsStorage->moveAssetInMMSRepository(
				localAssetIngestionEvent.getIngestionJobKey(),
				binaryPathName,
				localAssetIngestionEvent.getWorkspace()->_directoryName,
				mediaSourceFileName,
				relativePathToBeUsed,
				&mmsPartitionIndexUsed,
				&sourceFileType,
				deliveryRepositoriesToo,
				localAssetIngestionEvent.getWorkspace()->_territories
            );
			mmsPartitionUsed = mmsPartitionIndexUsed;

			// if (mediaFileFormat == "m3u8")
			if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
			{
				relativePathToBeUsed += (mediaSourceFileName + "/");
			}
		}
		else
		{
			mmsAssetPathName = binaryPathName;
			mmsPartitionUsed = -1;

			size_t fileNameIndex = externalStorageRelativePathName.find_last_of("/");
			if (fileNameIndex == string::npos)
			{
				string errorMessage = __FILEREF__ + "No fileName found in externalStorageRelativePathName"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", externalStorageRelativePathName: " + externalStorageRelativePathName
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			relativePathToBeUsed = externalStorageRelativePathName.substr(0, fileNameIndex + 1);
			mediaSourceFileName = externalStorageRelativePathName.substr(fileNameIndex + 1);
		}
	}
	catch(runtime_error e)
	{
		_logger->error(__FILEREF__ + "_mmsStorage->moveAssetInMMSRepository failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", errorMessage: " + e.what()
		);
       
		_logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
			+ ", IngestionStatus: " + "End_IngestionFailure"
			+ ", errorMessage: " + e.what()
		);                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
			);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
			);
		}
       
		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", binaryPathName: " + binaryPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(binaryPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", binaryPathName: " + binaryPathName
					);

					FileIO::remove(binaryPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
	}
	catch(exception e)
	{
		_logger->error(__FILEREF__ + "_mmsStorage->moveAssetInMMSRepository failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
		);
       
		_logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
			+ ", IngestionStatus: " + "End_IngestionFailure"
			+ ", errorMessage: " + e.what()
		);                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
			);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
			);
		}
       
		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", binaryPathName: " + binaryPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(binaryPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", binaryPathName: " + binaryPathName
					);

					FileIO::remove(binaryPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        // throw e;
		return;	// return because it is a thread
	}

	string m3u8FileName;
	if (mediaFileFormat == "m3u8-tar.gz")
	{
		// in this case mmsAssetPathName refers a directory and we need to find out the m3u8 file name

		try
		{
			FileIO::DirectoryEntryType_t detDirectoryEntryType;
			shared_ptr<FileIO::Directory> directory = FileIO::openDirectory (
				mmsAssetPathName + "/");
			bool scanDirectoryFinished = false;
			while (!scanDirectoryFinished)
			{
				string directoryEntry;
				try
				{
					string directoryEntry = FileIO::readDirectory (directory,
						&detDirectoryEntryType);

					if (detDirectoryEntryType != FileIO::TOOLS_FILEIO_REGULARFILE)
						continue;

					string m3u8Suffix(".m3u8");
					if (directoryEntry.size() >= m3u8Suffix.size()
							&& 0 == directoryEntry.compare(
								directoryEntry.size()-m3u8Suffix.size(),
								m3u8Suffix.size(), m3u8Suffix))
					{
						m3u8FileName = directoryEntry;

						scanDirectoryFinished = true;
					}
				}
				catch(DirectoryListFinished e)
				{
					scanDirectoryFinished = true;
				}
				catch(runtime_error e)
				{
					string errorMessage = __FILEREF__ + "listing directory failed"
						+ ", e.what(): " + e.what()
					;
					_logger->error(errorMessage);

					throw e;
				}
				catch(exception e)
				{
					string errorMessage = __FILEREF__ + "listing directory failed"
						+ ", e.what(): " + e.what()
					;
					_logger->error(errorMessage);

					throw e;
				}
			}

			FileIO::closeDirectory (directory);

			if (m3u8FileName == "")
			{
				string errorMessage = __FILEREF__ + "m3u8 file not found"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", mmsAssetPathName: " + mmsAssetPathName
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			mediaSourceFileName = m3u8FileName;
		}
        catch(runtime_error e)
        {
            _logger->error(__FILEREF__ + "retrieving m3u8 file failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", mmsAssetPathName: " + mmsAssetPathName
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure,
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

			// throw e;
			return;	// return because it is a thread
        }
        catch(exception e)
        {
            _logger->error(__FILEREF__ + "retrieving m3u8 file failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", mmsAssetPathName: " + mmsAssetPathName
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

			// throw e;
			return;	// return because it is a thread
        }        
	}

    MMSEngineDBFacade::ContentType contentType;

	pair<int64_t, long> mediaInfoDetails;
	vector<tuple<int, int64_t, string, string, int, int, string, long>> videoTracks;
	vector<tuple<int, int64_t, string, long, int, long, string>> audioTracks;

    int imageWidth = -1;
    int imageHeight = -1;
    string imageFormat;
    int imageQuality = -1;
    if (validator.isVideoAudioFileFormat(mediaFileFormat))
    {
        try
        {
            FFMpeg ffmpeg (_configuration, _logger);
            // tuple<int64_t,long,string,string,int,int,string,long,string,long,int,long> mediaInfo;

			bool isMMSAssetPathName = true;
			if (mediaFileFormat == "m3u8-tar.gz")
				mediaInfoDetails = ffmpeg.getMediaInfo(localAssetIngestionEvent.getIngestionJobKey(),
					isMMSAssetPathName, mmsAssetPathName + "/" + m3u8FileName,
					videoTracks, audioTracks);
			else
				mediaInfoDetails = ffmpeg.getMediaInfo(localAssetIngestionEvent.getIngestionJobKey(),
					isMMSAssetPathName, mmsAssetPathName, videoTracks, audioTracks);

			int64_t durationInMilliSeconds = -1;
			long bitRate = -1;
			tie(durationInMilliSeconds, bitRate) = mediaInfoDetails;

			_logger->info(__FILEREF__ + "ffmpeg.getMediaInfo"
				+ ", mmsAssetPathName: " + mmsAssetPathName
				+ ", durationInMilliSeconds: " + to_string(durationInMilliSeconds)
				+ ", bitRate: " + to_string(bitRate)
				+ ", videoTracks.size: " + to_string(videoTracks.size())
				+ ", audioTracks.size: " + to_string(audioTracks.size())
			);

			/*
            tie(durationInMilliSeconds, bitRate, 
                videoCodecName, videoProfile, videoWidth, videoHeight, videoAvgFrameRate, videoBitRate,
                audioCodecName, audioSampleRate, audioChannels, audioBitRate) = mediaInfo;
			*/

			/*
			 * 2019-10-13: commented because I guess the avg frame rate returned by ffmpeg is OK
			 * avg frame rate format is: total duration / total # of frames
            if (localAssetIngestionEvent.getForcedAvgFrameRate() != "")
            {
                _logger->info(__FILEREF__ + "handleLocalAssetIngestionEvent. Forced Avg Frame Rate"
                    + ", current avgFrameRate: " + videoAvgFrameRate
                    + ", forced avgFrameRate: " + localAssetIngestionEvent.getForcedAvgFrameRate()
                );
                
                videoAvgFrameRate = localAssetIngestionEvent.getForcedAvgFrameRate();
            }
			*/

            if (videoTracks.size() == 0)
                contentType = MMSEngineDBFacade::ContentType::Audio;
            else
                contentType = MMSEngineDBFacade::ContentType::Video;
        }
        catch(runtime_error e)
        {
            _logger->error(__FILEREF__ + "EncoderVideoAudioProxy::getMediaInfo failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure,
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

			// throw e;
			return;	// return because it is a thread
        }
        catch(exception e)
        {
            _logger->error(__FILEREF__ + "EncoderVideoAudioProxy::getVideoOrAudioDurationInMilliSeconds failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

			// throw e;
			return;	// return because it is a thread
        }        
    }
    else if (validator.isImageFileFormat(mediaFileFormat))
    {
        try
        {
            _logger->info(__FILEREF__ + "Processing through Magick"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", mmsAssetPathName: " + mmsAssetPathName
            );
            Magick::Image      imageToEncode;

            imageToEncode.read (mmsAssetPathName.c_str());

            imageWidth	= imageToEncode.columns();
            imageHeight	= imageToEncode.rows();
            imageFormat = imageToEncode.magick();
            imageQuality = imageToEncode.quality();
            
            contentType = MMSEngineDBFacade::ContentType::Image;
        }
        catch( Magick::WarningCoder &e )
        {
            // Process coder warning while loading file (e.g. TIFF warning)
            // Maybe the user will be interested in these warnings (or not).
            // If a warning is produced while loading an image, the image
            // can normally still be used (but not if the warning was about
            // something important!)
            _logger->error(__FILEREF__ + "ImageMagick failed to retrieve width and height failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", e.what(): " + e.what()
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

            // throw runtime_error(e.what());
			// throw e;
			return;	// return because it is a thread
        }
        catch( Magick::Warning &e )
        {
            _logger->error(__FILEREF__ + "ImageMagick failed to retrieve width and height failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", e.what(): " + e.what()
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

            // throw runtime_error(e.what());
			// throw e;
			return;	// return because it is a thread
        }
        catch( Magick::ErrorFileOpen &e ) 
        { 
            _logger->error(__FILEREF__ + "ImageMagick failed to retrieve width and height failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", e.what(): " + e.what()
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

            // throw runtime_error(e.what());
			// throw e;
			return;	// return because it is a thread
        }
        catch (Magick::Error &e)
        { 
            _logger->error(__FILEREF__ + "ImageMagick failed to retrieve width and height failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", e.what(): " + e.what()
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

            // throw runtime_error(e.what());
			// throw e;
			return;	// return because it is a thread
        }
        catch(exception e)
        {
            _logger->error(__FILEREF__ + "ImageMagick failed to retrieve width and height failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            );

			if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
			{
				try
				{
					if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
					{
						_logger->info(__FILEREF__ + "Remove directory"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						Boolean_t bRemoveRecursively = true;
						FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
					}
					else
					{
						_logger->info(__FILEREF__ + "Remove file"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
							+ ", mmsAssetPathName: " + mmsAssetPathName
						);

						FileIO::remove(mmsAssetPathName);
					}
				}
				catch(runtime_error e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
				catch(exception e)
				{
					_logger->info(__FILEREF__ + "remove failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", errorMessage: " + e.what()
					);
				}
			}

            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
                + ", IngestionStatus: " + "End_IngestionFailure"
                + ", errorMessage: " + e.what()
            );                            
			try
			{
				_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                    MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                    e.what()
				);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + re.what()
					);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + ex.what()
					);
			}

            // throw e;
			// throw e;
			return;	// return because it is a thread
        }
    }
    else
    {
        string errorMessage = string("Unknown mediaFileFormat")
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
			+ ", mmsAssetPathName: " + mmsAssetPathName
        ;

        _logger->error(__FILEREF__ + errorMessage);
        
		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					FileIO::remove(mmsAssetPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + errorMessage
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (localAssetIngestionEvent.getIngestionJobKey(),
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                errorMessage
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw runtime_error(errorMessage);
		return;	// return because it is a thread
    }

    // int64_t mediaItemKey;
	try
	{
		bool inCaseOfLinkHasItToBeRead = false;
		unsigned long long sizeInBytes;
		if (mediaFileFormat == "m3u8-tar.gz")
			sizeInBytes = FileIO::getDirectorySizeInBytes(mmsAssetPathName);   
		else
			sizeInBytes = FileIO::getFileSizeInBytes(mmsAssetPathName, inCaseOfLinkHasItToBeRead);   

		int64_t variantOfMediaItemKey = -1;
		{
			string variantOfMediaItemKeyField = "variantOfMediaItemKey";
			string variantOfUniqueNameField = "variantOfUniqueName";
			string variantOfIngestionJobKeyField = "VariantOfIngestionJobKey";
			if (JSONUtils::isMetadataPresent(parametersRoot, variantOfMediaItemKeyField))
			{
				variantOfMediaItemKey = JSONUtils::asInt64(parametersRoot, variantOfMediaItemKeyField, -1);
			}
			else if (JSONUtils::isMetadataPresent(parametersRoot, variantOfUniqueNameField))
			{
				bool warningIfMissing = false;

				string variantOfUniqueName = parametersRoot.get(variantOfUniqueNameField, "").asString();

				pair<int64_t, MMSEngineDBFacade::ContentType> mediaItemKeyDetails =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByUniqueName(
					localAssetIngestionEvent.getWorkspace()->_workspaceKey,
					variantOfUniqueName, warningIfMissing);
				tie(variantOfMediaItemKey, ignore) = mediaItemKeyDetails;
			}
			else if (JSONUtils::isMetadataPresent(parametersRoot, variantOfIngestionJobKeyField))
			{
				int64_t variantOfIngestionJobKey = JSONUtils::asInt64(parametersRoot, variantOfIngestionJobKeyField, -1);
				vector<tuple<int64_t,int64_t,MMSEngineDBFacade::ContentType>> mediaItemsDetails;
				bool warningIfMissing = false;

				_mmsEngineDBFacade->getMediaItemDetailsByIngestionJobKey(
					localAssetIngestionEvent.getWorkspace()->_workspaceKey, variantOfIngestionJobKey,
					-1, mediaItemsDetails, warningIfMissing);

				if (mediaItemsDetails.size() != 1)
				{
					string errorMessage = string("IngestionJob does not refer the correct media Items number")
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", variantOfIngestionJobKey: " + to_string(variantOfIngestionJobKey)
						+ ", workspaceKey: " + to_string(localAssetIngestionEvent.getWorkspace()->_workspaceKey)
						+ ", mediaItemsDetails.size(): " + to_string(mediaItemsDetails.size())
					;
					_logger->error(__FILEREF__ + errorMessage);
        
					throw runtime_error(errorMessage);
				}

				tuple<int64_t,int64_t,MMSEngineDBFacade::ContentType> mediaItemsDetailsReturn
					= mediaItemsDetails[0];
				tie(variantOfMediaItemKey, ignore, ignore) = mediaItemsDetailsReturn;
			}
		}

		if (variantOfMediaItemKey == -1)
		{
			_logger->info(__FILEREF__ + "_mmsEngineDBFacade->saveSourceContentMetadata..."
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", contentType: " + MMSEngineDBFacade::toString(contentType)
				+ ", ExternalReadOnlyStorage: " + to_string(localAssetIngestionEvent.getExternalReadOnlyStorage())
				+ ", relativePathToBeUsed: " + relativePathToBeUsed
				+ ", mediaSourceFileName: " + mediaSourceFileName
				+ ", mmsPartitionUsed: " + to_string(mmsPartitionUsed)
				+ ", sizeInBytes: " + to_string(sizeInBytes)

				+ ", videoTracks.size: " + to_string(videoTracks.size())
				+ ", audioTracks.size: " + to_string(audioTracks.size())

				+ ", imageWidth: " + to_string(imageWidth)
				+ ", imageHeight: " + to_string(imageHeight)
				+ ", imageFormat: " + imageFormat
				+ ", imageQuality: " + to_string(imageQuality)
			);

			pair<int64_t,int64_t> mediaItemKeyAndPhysicalPathKey =
                _mmsEngineDBFacade->saveSourceContentMetadata (
                    localAssetIngestionEvent.getWorkspace(),
                    localAssetIngestionEvent.getIngestionJobKey(),
                    localAssetIngestionEvent.getIngestionRowToBeUpdatedAsSuccess(),
                    contentType,
                    parametersRoot,
					localAssetIngestionEvent.getExternalReadOnlyStorage(),
                    relativePathToBeUsed,
                    mediaSourceFileName,
                    mmsPartitionUsed,
                    sizeInBytes,
                
                    // video-audio
					mediaInfoDetails,
					videoTracks,
					audioTracks,

                    // image
                    imageWidth,
                    imageHeight,
                    imageFormat,
                    imageQuality
			);

			int64_t mediaItemKey = mediaItemKeyAndPhysicalPathKey.first;

			_logger->info(__FILEREF__ + "Added a new ingested content"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: "
					+ to_string(localAssetIngestionEvent.getIngestionJobKey())
				+ ", mediaItemKey: " + to_string(mediaItemKeyAndPhysicalPathKey.first)
				+ ", physicalPathKey: " + to_string(mediaItemKeyAndPhysicalPathKey.second)
			);
		}
		else
		{
			int64_t liveRecordingIngestionJobKey = -1;
			int64_t encodingProfileKey = -1;

			{
				string field = "variantEncodingProfileKey";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					encodingProfileKey = JSONUtils::asInt64(parametersRoot, field, -1);
			}

			string externalDeliveryTechnology;
			string externalDeliveryURL;
			{
				string field = "ExternalDeliveryTechnology";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					externalDeliveryTechnology = parametersRoot.get(field, "").asString();

				field = "ExternalDeliveryURL";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					externalDeliveryURL = parametersRoot.get(field, "").asString();
			}

			int64_t physicalItemRetentionInMinutes = -1;
			{
				string field = "PhysicalItemRetention";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string retention = parametersRoot.get(field, "1d").asString();
					physicalItemRetentionInMinutes =
						MMSEngineDBFacade::parseRetention(retention);
				}
			}

			_logger->info(__FILEREF__ + "_mmsEngineDBFacade->saveVariantContentMetadata.."
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", workspaceKey: " + to_string(
					localAssetIngestionEvent.getWorkspace()->_workspaceKey)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", liveRecordingIngestionJobKey: " + to_string(
					liveRecordingIngestionJobKey)
				+ ", variantOfMediaItemKey: " + to_string(variantOfMediaItemKey)
				+ ", ExternalReadOnlyStorage: " + to_string(
					localAssetIngestionEvent.getExternalReadOnlyStorage())
				+ ", externalDeliveryTechnology: " + externalDeliveryTechnology
				+ ", externalDeliveryURL: " + externalDeliveryURL

				+ ", mediaSourceFileName: " + mediaSourceFileName
				+ ", relativePathToBeUsed: " + relativePathToBeUsed
				+ ", mmsPartitionUsed: " + to_string(mmsPartitionUsed)
				+ ", sizeInBytes: " + to_string(sizeInBytes)
				+ ", encodingProfileKey: " + to_string(encodingProfileKey)
				+ ", physicalItemRetentionInMinutes: " + to_string(
					physicalItemRetentionInMinutes)

				+ ", videoTracks.size: " + to_string(videoTracks.size())
				+ ", audioTracks.size: " + to_string(audioTracks.size())

				+ ", imageWidth: " + to_string(imageWidth)
				+ ", imageHeight: " + to_string(imageHeight)
				+ ", imageFormat: " + imageFormat
				+ ", imageQuality: " + to_string(imageQuality)
			);

			int64_t physicalPathKey = _mmsEngineDBFacade->saveVariantContentMetadata (
                    localAssetIngestionEvent.getWorkspace()->_workspaceKey,
                    localAssetIngestionEvent.getIngestionJobKey(),
					liveRecordingIngestionJobKey,
					variantOfMediaItemKey,
					localAssetIngestionEvent.getExternalReadOnlyStorage(),
					externalDeliveryTechnology,
					externalDeliveryURL,

                    mediaSourceFileName,
                    relativePathToBeUsed,
                    mmsPartitionUsed,
                    sizeInBytes,
					encodingProfileKey,
					physicalItemRetentionInMinutes,
                
                    // video-audio
					mediaInfoDetails,
					videoTracks,
					audioTracks,

                    // image
                    imageWidth,
                    imageHeight,
                    imageFormat,
                    imageQuality
			);
			_logger->info(__FILEREF__ + "Added a new variant content"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", variantOfMediaItemKey,: " + to_string(variantOfMediaItemKey)
				+ ", physicalPathKey: " + to_string(physicalPathKey)
			);

			_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
			);                            
			_mmsEngineDBFacade->updateIngestionJob (
				localAssetIngestionEvent.getIngestionJobKey(),
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
			);
		}
    }
    catch(DeadlockFound e)
    {
        _logger->error(__FILEREF__
			+ "_mmsEngineDBFacade->getMediaItemDetailsByIngestionJobKey failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", workspaceKey: " + to_string(
				localAssetIngestionEvent.getWorkspace()->_workspaceKey)
			+ ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
			+ ", e.what: " + e.what()
        );

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					FileIO::remove(mmsAssetPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
			+ ", IngestionStatus: " + "End_IngestionFailure"
			+ ", errorMessage: " + e.what()
		);                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (
				localAssetIngestionEvent.getIngestionJobKey(),
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(MediaItemKeyNotFound e)	// getMediaItemDetailsByIngestionJobKey failure
    {
        _logger->error(__FILEREF__
			+ "_mmsEngineDBFacade->getMediaItemDetailsByIngestionJobKey failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", workspaceKey: " + to_string(
				localAssetIngestionEvent.getWorkspace()->_workspaceKey)
			+ ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
			+ ", e.what: " + e.what()
        );

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					FileIO::remove(mmsAssetPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
			+ ", IngestionStatus: " + "End_IngestionFailure"
			+ ", errorMessage: " + e.what()
		);                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (
				localAssetIngestionEvent.getIngestionJobKey(),
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__
			+ "_mmsEngineDBFacade->saveSourceContentMetadata failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
            + ", e.what: " + e.what()
        );

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					FileIO::remove(mmsAssetPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (
				localAssetIngestionEvent.getIngestionJobKey(),
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__
			+ "_mmsEngineDBFacade->saveSourceContentMetadata failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
        );

		if (!localAssetIngestionEvent.getExternalReadOnlyStorage())
		{
			try
			{
				if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
				{
					_logger->info(__FILEREF__ + "Remove directory"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					Boolean_t bRemoveRecursively = true;
					FileIO::removeDirectory(mmsAssetPathName, bRemoveRecursively);
				}
				else
				{
					_logger->info(__FILEREF__ + "Remove file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(
							localAssetIngestionEvent.getIngestionJobKey())
						+ ", mmsAssetPathName: " + mmsAssetPathName
					);

					FileIO::remove(mmsAssetPathName);
				}
			}
			catch(runtime_error e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->info(__FILEREF__ + "remove failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(
						localAssetIngestionEvent.getIngestionJobKey())
					+ ", errorMessage: " + e.what()
				);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(
				localAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (
				localAssetIngestionEvent.getIngestionJobKey(),
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(
					localAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        // throw e;
		return;	// return because it is a thread
    }
}

/*
void MMSEngineProcessor::exploidTarGzContentFile(
	string tarGzBinaryPathName,
	string workspaceIngestionBinaryPathName,
	int64_t ingestionJobKey)
{
	// string binaryPathName;

	try
	{
		string tarGzSuffix(".tar.gz");
		if (tarGzBinaryPathName.size() >= tarGzSuffix.size() && 0 == tarGzBinaryPathName.compare(
			tarGzBinaryPathName.size()-tarGzSuffix.size(), tarGzSuffix.size(), tarGzSuffix))
		{
			size_t binaryPathNameIndex = tarGzBinaryPathName.find_last_of(".tar.gz");
			if (binaryPathNameIndex == string::npos)
			{
				// error
			}

			binaryPathName = tarGzBinaryPathName.substr(0, binaryPathNameIndex);
		}
		else
		{
			// error
		}


		string m3u8FileName;
		{
			try
			{
				FileIO::DirectoryEntryType_t detDirectoryEntryType;
				shared_ptr<FileIO::Directory> directory = FileIO::openDirectory (
					binaryPathName + "/");
				bool scanDirectoryFinished = false;
				while (!scanDirectoryFinished)
				{
					string directoryEntry;
					try
					{
						string directoryEntry = FileIO::readDirectory (directory,
							&detDirectoryEntryType);

						if (detDirectoryEntryType != FileIO::TOOLS_FILEIO_REGULARFILE)
							continue;

						string m3u8Suffix(".m3u8");
						if (directoryEntry.size() >= m3u8Suffix.size()
								&& 0 == directoryEntry.compare(
									directoryEntry.size()-m3u8Suffix.size(),
									m3u8Suffix.size(), m3u8Suffix))
						{
							m3u8FileName = directoryEntry;

							scanDirectoryFinished = true;
						}
					}
					catch(DirectoryListFinished e)
					{
						scanDirectoryFinished = true;
					}
					catch(runtime_error e)
					{
						string errorMessage = __FILEREF__ + "listing directory failed"
							+ ", e.what(): " + e.what()
						;
						_logger->error(errorMessage);

						throw e;
					}
					catch(exception e)
					{
						string errorMessage = __FILEREF__ + "listing directory failed"
							+ ", e.what(): " + e.what()
						;
						_logger->error(errorMessage);

						throw e;
					}
				}

				FileIO::closeDirectory (directory);
			}
			catch(runtime_error e)
			{
				// error
			}
			catch(exception e)
			{
				// error
			}
		}

		if (m3u8FileName == "")
		{
			// error
		}

		binaryPathName += ("/" + m3u8FileName);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "exploidTarGzContentFile failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "exploidTarGzContentFile failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );

        throw e;
    }

	// return binaryPathName;
}
*/

void MMSEngineProcessor::manageGroupOfTasks(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot)
{
    try
    {
		vector<pair<int64_t, int64_t>>	referencesOutput;

		Validator validator(_logger, _mmsEngineDBFacade, _configuration);
		// ReferencesOutput tag is always present:
		// 1. because it is already set by the Workflow (by the user)
		// 2. because it is automatically set by API_Ingestion.cpp using the list of Tasks.
		//	This is when it was not found into the Workflow
		validator.fillReferencesOutput(workspace->_workspaceKey, parametersRoot,
				referencesOutput);

		int64_t liveRecordingIngestionJobKey = -1;
		for (pair<int64_t, int64_t>  referenceOutput: referencesOutput)
		{
			/*
			 * 2020-06-08. I saw a scenario where:
			 *	1. MediaItems were coming from a LiveRecorder with high availability
			 *	2. a media item was present during validator.fillReferencesOutput
			 *	3. just before the calling of the below statement _mmsEngineDBFacade->addIngestionJobOutput
			 *		it was removed (because it was not validated
			 *	4. _mmsEngineDBFacade->addIngestionJobOutput raised an exception
			 *		Cannot add or update a child row: a foreign key constraint fails
			 *		(`vedatest`.`MMS_IngestionJobOutput`, CONSTRAINT `MMS_IngestionJobOutput_FK`
			 *		FOREIGN KEY (`physicalPathKey`) REFERENCES `MMS_PhysicalPath` (`physicalPathKey`)
			 *		ON DELETE CASCADE)
			 * This scenario should never happen because the EncoderVideoAudioProxy::processLiveRecorder method
			 * wait that the high availability is completely managed.
			 *
			 * Anyway to be sure we will not interrupt our workflow, we will add a try catch
			 */
			try
			{
				_logger->info(__FILEREF__ + "References.Output"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", mediaItemKey: " + to_string(referenceOutput.first)
					+ ", physicalPathKey: " + to_string(referenceOutput.second)
				);

				_mmsEngineDBFacade->addIngestionJobOutput(ingestionJobKey,
					referenceOutput.first, referenceOutput.second, liveRecordingIngestionJobKey);
			}
			catch(runtime_error e)
			{
				_logger->error(__FILEREF__ + "_mmsEngineDBFacade->addIngestionJobOutput failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", mediaItemKey: " + to_string(referenceOutput.first)
					+ ", physicalPathKey: " + to_string(referenceOutput.second)
					+ ", e.what(): " + e.what()
				);
			}
			catch(exception e)
			{
				_logger->error(__FILEREF__ + "_mmsEngineDBFacade->addIngestionJobOutput failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", mediaItemKey: " + to_string(referenceOutput.first)
					+ ", physicalPathKey: " + to_string(referenceOutput.second)
				);
			}
		}

		/*
		 * 2019-09-23: It is not clean now how to manage the status of the GroupOfTasks:
		 *	- depend on the status of his children (first level of Tasks of the GroupOfTasks)
		 *		as calculated below (now commented)?
		 *	- depend on the ReferencesOutput?
		 *
		 *	Since this is not clean, I left it always Success
		 *
		 */
		/*
		// GroupOfTasks Ingestion Status is by default Failure;
		// It will be Success if at least just one Status of the children is Success
		MMSEngineDBFacade::IngestionStatus groupOfTasksIngestionStatus
			= MMSEngineDBFacade::IngestionStatus::End_IngestionFailure;
		{
			vector<pair<int64_t, MMSEngineDBFacade::IngestionStatus>> groupOfTasksChildrenStatus;

			_mmsEngineDBFacade->getGroupOfTasksChildrenStatus(ingestionJobKey, groupOfTasksChildrenStatus);

			for (pair<int64_t, MMSEngineDBFacade::IngestionStatus> groupOfTasksChildStatus: groupOfTasksChildrenStatus)
			{
				int64_t childIngestionJobKey = groupOfTasksChildStatus.first;
				MMSEngineDBFacade::IngestionStatus childStatus = groupOfTasksChildStatus.second;

				_logger->info(__FILEREF__ + "manageGroupOfTasks, child status"
						+ ", group of tasks ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", childIngestionJobKey: " + to_string(childIngestionJobKey)
						+ ", IngestionStatus: " + MMSEngineDBFacade::toString(childStatus)
				);

				if (!MMSEngineDBFacade::isIngestionStatusFinalState(childStatus))
				{
					_logger->error(__FILEREF__ + "manageGroupOfTasks, child status is not a final status. It should never happens because when this GroupOfTasks is executed, all the children should be finished"
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", IngestionStatus: " + MMSEngineDBFacade::toString(childStatus)
					);

					continue;
				}

				if (childStatus == MMSEngineDBFacade::IngestionStatus::End_TaskSuccess)
				{
					groupOfTasksIngestionStatus = MMSEngineDBFacade::IngestionStatus::End_TaskSuccess;

					break;
				}
			}
		}
		*/
		MMSEngineDBFacade::IngestionStatus groupOfTasksIngestionStatus
			= MMSEngineDBFacade::IngestionStatus::End_TaskSuccess;

		string errorMessage = "";
		if (groupOfTasksIngestionStatus != MMSEngineDBFacade::IngestionStatus::End_TaskSuccess)
			errorMessage = "Failed because there is no one child with Status Success";

        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + MMSEngineDBFacade::toString(groupOfTasksIngestionStatus)
            + ", errorMessage: " + errorMessage
        );
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                groupOfTasksIngestionStatus,
                errorMessage
        );
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageGroupOfTasks failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageGroupOfTasks failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::removeContentThread(
	shared_ptr<long> processorsThreadsNumber, int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
		dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"removeContentThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
		_logger->info(__FILEREF__ + "removeContentThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        if (dependencies.size() == 0)
        {
			string errorMessage = __FILEREF__ + "No configured any media to be removed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", dependencies.size: " + to_string(dependencies.size());
			_logger->warn(errorMessage);

			// throw runtime_error(errorMessage);
        }

		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
				int64_t key;
				MMSEngineDBFacade::ContentType referenceContentType;
				Validator::DependencyType dependencyType;

				tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				// check if there are ingestion dependencies on this media item
				{
					if (dependencyType == Validator::DependencyType::MediaItemKey)
					{
						bool warningIfMissing = false;
						tuple<MMSEngineDBFacade::ContentType, string, string, string, int64_t, int64_t>
							contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey =
							_mmsEngineDBFacade->getMediaItemKeyDetails(
								workspace->_workspaceKey, key, warningIfMissing);

						MMSEngineDBFacade::ContentType localContentType;
						string localTitle;
						string localUserData;
						string localIngestionDate;
						int64_t localIngestionJobKey;
						tie(localContentType, localTitle, localUserData, localIngestionDate, ignore,
							localIngestionJobKey)
							= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;

						int ingestionDependenciesNumber = 
							_mmsEngineDBFacade->getNotFinishedIngestionDependenciesNumberByIngestionJobKey(
								localIngestionJobKey);
						if (ingestionDependenciesNumber > 0)
						{
							string errorMessage = __FILEREF__ + "MediaItem cannot be removed because there are still ingestion dependencies"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", ingestionDependenciesNumber: " + to_string(ingestionDependenciesNumber);
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
					}
					else
					{
						bool warningIfMissing = false;
						tuple<int64_t, MMSEngineDBFacade::ContentType, string, string, string, int64_t,
							string, string> mediaItemDetails =
							_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
								workspace->_workspaceKey, key, warningIfMissing);

						int64_t localMediaItemKey;
						MMSEngineDBFacade::ContentType localContentType;
						string localTitle;
						string localUserData;
						string localIngestionDate;
						int64_t localIngestionJobKey;
						tie(localMediaItemKey, localContentType, localTitle, localUserData, localIngestionDate,
							localIngestionJobKey, ignore, ignore) = mediaItemDetails;

						int ingestionDependenciesNumber = 
						_mmsEngineDBFacade->getNotFinishedIngestionDependenciesNumberByIngestionJobKey(
								localIngestionJobKey);
						if (ingestionDependenciesNumber > 0)
						{
							string errorMessage = __FILEREF__ + "MediaItem cannot be removed because there are still ingestion dependencies"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", ingestionDependenciesNumber: " + to_string(ingestionDependenciesNumber);
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
					}
				}

				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					_logger->info(__FILEREF__ + "removeMediaItem"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", mediaItemKey: " + to_string(key)
					);
					_mmsStorage->removeMediaItem(key);
				}
				else
				{
					_logger->info(__FILEREF__ + "removePhysicalPath"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", physicalPathKey: " + to_string(key)
					);
					_mmsStorage->removePhysicalPath(key);
				}
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "Remove Content failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "Remove Content failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
		}

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "removeContentThread failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "removeContentThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
}

void MMSEngineProcessor::ftpDeliveryContentThread(
		shared_ptr<long> processorsThreadsNumber,
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"ftpDeliveryContentThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No configured any media to be uploaded (FTP)"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        string configurationLabel;
        {
            string field = "ConfigurationLabel";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            configurationLabel = parametersRoot.get(field, "XXX").asString();
        }
        
        string ftpServer;
        int ftpPort;
        string ftpUserName;
        string ftpPassword;
        string ftpRemoteDirectory;

        tuple<string, int, string, string, string> ftp =
			_mmsEngineDBFacade->getFTPByConfigurationLabel(
					workspace->_workspaceKey, configurationLabel);            
        tie(ftpServer, ftpPort, ftpUserName, ftpPassword, ftpRemoteDirectory) = ftp;

		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
				int64_t key;
				MMSEngineDBFacade::ContentType referenceContentType;
				Validator::DependencyType dependencyType;
            
				tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				string mmsAssetPathName;
				string fileName;
				int64_t sizeInBytes;
				string deliveryFileName;
				int64_t mediaItemKey;
				int64_t physicalPathKey;
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					mediaItemKey = key;

					int64_t encodingProfileKey = -1;
               
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string>
						physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName
						= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
					tie(physicalPathKey, mmsAssetPathName, ignore, ignore, fileName, sizeInBytes, deliveryFileName)
						= physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName;
				}
				else
				{
					physicalPathKey = key;

					{
						bool warningIfMissing = false;
						tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
							mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
							_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
								workspace->_workspaceKey, physicalPathKey, warningIfMissing);            
						tie(mediaItemKey, ignore, ignore, ignore, ignore, ignore, ignore, ignore) =
							mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
					}

					tuple<string, int, string, string, int64_t, string>
						physicalPathFileNameSizeInBytesAndDeliveryFileName =
						_mmsStorage->getPhysicalPathDetails(key);
					tie(mmsAssetPathName, ignore, ignore, fileName, sizeInBytes, deliveryFileName)
						= physicalPathFileNameSizeInBytesAndDeliveryFileName;
				}

				ftpUploadMediaSource(mmsAssetPathName, fileName, sizeInBytes,
					ingestionJobKey, workspace, mediaItemKey, physicalPathKey,
					ftpServer, ftpPort, ftpUserName, ftpPassword,
					ftpRemoteDirectory, deliveryFileName);
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "FTP Content failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "FTP Content failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
		}

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "ftpDeliveryContentTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "ftpDeliveryContentTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
}

void MMSEngineProcessor::localCopyContentThread(
	shared_ptr<long> processorsThreadsNumber, int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace, Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>> dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"localCopyContentThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No configured any media to be copied"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        string localPath;
        string localFileName;
        {
            string field = "LocalPath";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            localPath = parametersRoot.get(field, "XXX").asString();

            field = "LocalFileName";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                localFileName = parametersRoot.get(field, "XXX").asString();
            }
        }
        
		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
				int64_t key;
				MMSEngineDBFacade::ContentType referenceContentType;
				Validator::DependencyType dependencyType;
            
				tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				string mmsAssetPathName;
				string fileFormat;
				int64_t physicalPathKey;
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					int64_t encodingProfileKey = -1;
                
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string>
						physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName
						= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
					tie(ignore, mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
						= physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName;
				}
				else
				{
					physicalPathKey = key;

					tuple<string, int, string, string, int64_t, string>
						physicalPathFileNameSizeInBytesAndDeliveryFileName =
						_mmsStorage->getPhysicalPathDetails(key);
					tie(mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
						= physicalPathFileNameSizeInBytesAndDeliveryFileName;
				}

				copyContent(ingestionJobKey, mmsAssetPathName, localPath, localFileName);
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "local copy Content failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "local copy Content failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
        }

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "localCopyContentThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
                
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "localCopyContentThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
}

void MMSEngineProcessor::extractTracksContentThread(
        shared_ptr<long> processorsThreadsNumber, int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"extractTracksContentThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try 
    {
		_logger->info(__FILEREF__ + "extractTracksContentThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No configured media to be used to extract a track"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        vector<pair<string,int>> tracksToBeExtracted;
        string outputFileFormat;
        {
            {
                string field = "Tracks";
                Json::Value tracksToot = parametersRoot[field];
                if (tracksToot.size() == 0)
                {
                    string errorMessage = __FILEREF__ + "No correct number of Tracks"
                            + ", tracksToot.size: " + to_string(tracksToot.size());
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
                for (int trackIndex = 0; trackIndex < tracksToot.size(); trackIndex++)
                {
                    Json::Value trackRoot = tracksToot[trackIndex];

                    field = "TrackType";
                    if (!JSONUtils::isMetadataPresent(trackRoot, field))
                    {
                        Json::StreamWriterBuilder wbuilder;
                        string sTrackRoot = Json::writeString(wbuilder, trackRoot);

                        string errorMessage = __FILEREF__ + "Field is not present or it is null"
                                + ", Field: " + field
                                + ", sTrackRoot: " + sTrackRoot
                                ;
                        _logger->error(errorMessage);

                        throw runtime_error(errorMessage);
                    }
                    string trackType = trackRoot.get(field, "XXX").asString();

                    int trackNumber = 0;
                    field = "TrackNumber";
                    if (JSONUtils::isMetadataPresent(trackRoot, field))
                        trackNumber = JSONUtils::asInt(trackRoot, field, 0);

                    tracksToBeExtracted.push_back(make_pair(trackType, trackNumber));
                }
            }

            string field = "OutputFileFormat";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            outputFileFormat = parametersRoot.get(field, "XXX").asString();
        }

		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
				int64_t key;
				MMSEngineDBFacade::ContentType referenceContentType;
				Validator::DependencyType dependencyType;
            
				tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				string mmsAssetPathName;
            
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					int64_t encodingProfileKey = -1;
                
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails
						= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey,
							warningIfMissing);
					tie(ignore, mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
						= physicalPathDetails;
				}
				else
				{
					tuple<string, int, string, string, int64_t, string> physicalPathDetails =
						_mmsStorage->getPhysicalPathDetails(key);
					tie(mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
						= physicalPathDetails;
				}

				{
					string localSourceFileName;
					string extractTrackMediaPathName;
					{
						localSourceFileName = to_string(ingestionJobKey)
                            + "_" + to_string(key)
                            + "_extractTrack"
                            + "." + outputFileFormat
                            ;

						string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(
							workspace);
						extractTrackMediaPathName = workspaceIngestionRepository + "/" 
                            + localSourceFileName;
					}

					FFMpeg ffmpeg (_configuration, _logger);

					ffmpeg.extractTrackMediaToIngest(
						ingestionJobKey,
						mmsAssetPathName,
						tracksToBeExtracted,
						extractTrackMediaPathName);

					_logger->info(__FILEREF__ + "extractTrackMediaToIngest done"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", extractTrackMediaPathName: " + extractTrackMediaPathName
					);

					string title;
					int64_t imageOfVideoMediaItemKey = -1;
					int64_t cutOfVideoMediaItemKey = -1;
					int64_t cutOfAudioMediaItemKey = -1;
					double startTimeInSeconds = 0.0;
					double endTimeInSeconds = 0.0;
					string mediaMetaDataContent = generateMediaMetadataToIngest(
						ingestionJobKey,
						outputFileFormat,
						title,
						imageOfVideoMediaItemKey,
						cutOfVideoMediaItemKey, cutOfAudioMediaItemKey, startTimeInSeconds, endTimeInSeconds,
						parametersRoot
					);

					{
						shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent 
							= make_shared<LocalAssetIngestionEvent>();
						/*
						shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent
							= _multiEventsSet->getEventsFactory()->getFreeEvent<LocalAssetIngestionEvent>(
								MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);
						*/

						localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
						localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
						localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

						localAssetIngestionEvent->setExternalReadOnlyStorage(false);
						localAssetIngestionEvent->setIngestionJobKey(ingestionJobKey);
						localAssetIngestionEvent->setIngestionSourceFileName(localSourceFileName);
						localAssetIngestionEvent->setMMSSourceFileName(localSourceFileName);
						localAssetIngestionEvent->setWorkspace(workspace);
						localAssetIngestionEvent->setIngestionType(MMSEngineDBFacade::IngestionType::AddContent);            
						localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(
							/* it + 1 == dependencies.end() ? true : */ false);

						// to manage a ffmpeg bug generating a corrupted/wrong avgFrameRate, we will
						// force the concat file to have the same avgFrameRate of the source media
						// Uncomment next statements in case the problem is still present event in case of the ExtractTracks task
						// if (forcedAvgFrameRate != "" && concatContentType == MMSEngineDBFacade::ContentType::Video)
						//    localAssetIngestionEvent->setForcedAvgFrameRate(forcedAvgFrameRate);            

						localAssetIngestionEvent->setMetadataContent(mediaMetaDataContent);

						handleLocalAssetIngestionEventThread (
							processorsThreadsNumber, *localAssetIngestionEvent);
						/*
						shared_ptr<Event2>    event = dynamic_pointer_cast<Event2>(localAssetIngestionEvent);
						_multiEventsSet->addEvent(event);

						_logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (INGESTASSETEVENT)"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", getEventKey().first: " + to_string(event->getEventKey().first)
							+ ", getEventKey().second: " + to_string(event->getEventKey().second));
						*/
					}
				}
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "extract track failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "extract track failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
        }

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch (runtime_error& e) 
    {
        _logger->error(__FILEREF__ + "Extracting tracks failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
        return;
    }
    catch (exception e)
    {
        _logger->error(__FILEREF__ + "Extracting tracks failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

        return;
    }
}

void MMSEngineProcessor::httpCallbackThread(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
		dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"httpCallbackThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
        if (dependencies.size() == 0)
        {
			string errorMessage = __FILEREF__
				+ "No configured any media to be notified (HTTP Callback)"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", dependencies.size: " + to_string(dependencies.size());
			_logger->warn(errorMessage);

			// throw runtime_error(errorMessage);
		}

        string httpProtocol;
        string httpHostName;
        string userName;
        string password;
        int httpPort;
        string httpURI;
        string httpURLParameters;
        string httpMethod;
        long callbackTimeoutInSeconds;
		int maxRetries;
        string httpBody;
        Json::Value httpHeadersRoot(Json::arrayValue);
        {
            string field = "protocol";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
                httpProtocol = "http";
            else
            {
                httpProtocol = parametersRoot.get(field, "").asString();
                if (httpProtocol == "")
                    httpProtocol = "http";
            }

            field = "userName";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                userName = parametersRoot.get(field, "").asString();

            field = "password";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                password = parametersRoot.get(field, "").asString();

            field = "hostName";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            httpHostName = parametersRoot.get(field, "").asString();

            field = "port";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                if (httpProtocol == "http")
                    httpPort = 80;
                else
                    httpPort = 443;
            }
            else
                httpPort = JSONUtils::asInt(parametersRoot, field, 0);

            field = "timeout";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
                callbackTimeoutInSeconds = 120;
            else
                callbackTimeoutInSeconds = JSONUtils::asInt(parametersRoot, field, 0);
            
            field = "uri";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            httpURI = parametersRoot.get(field, "").asString();

            field = "parameters";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                httpURLParameters = parametersRoot.get(field, "XXX").asString();

            field = "method";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
                httpMethod = "POST";
            else
            {
                httpMethod = parametersRoot.get(field, "").asString();
                if (httpMethod == "")
                    httpMethod = "POST";
            }

			field = "httpBody";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				httpBody = parametersRoot.get(field, "").asString();

            field = "headers";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
            {
				// semicolon as separator
				stringstream ss(parametersRoot.get(field, "").asString());
				string token;
				char delim = ';';
				while (getline(ss, token, delim))
				{
					if (!token.empty())
						httpHeadersRoot.append(token);
				}
                // httpHeadersRoot = parametersRoot[field];
            }

            field = "maxRetries";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				maxRetries = 2;
            else
			{
                maxRetries = JSONUtils::asInt(parametersRoot, field, 3);
				if (maxRetries == 0)
					maxRetries = 2;
			}
        }

		if ((httpMethod == "POST" || httpMethod == "PUT") && httpBody != "")
		{
			_logger->info(__FILEREF__ + "POST/PUT with httpBody"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", dependencies.size: " + to_string(dependencies.size())
			);

			int dependencyIndex = 0;
			for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
			{
				bool stopIfReferenceProcessingError = false;

				try
				{
					int64_t key;
					Validator::DependencyType dependencyType;

					tie(key, ignore, dependencyType,
						stopIfReferenceProcessingError) = keyAndDependencyType;

					int64_t physicalPathKey;
					int64_t mediaItemKey;

					if (dependencyType == Validator::DependencyType::MediaItemKey)
					{
						mediaItemKey = key;

						int64_t encodingProfileKey = -1;
                
						bool warningIfMissing = false;
						tuple<int64_t, string, int, string, string, int64_t, string>
							physicalPathDetails = _mmsStorage->getPhysicalPathDetails(key,
							encodingProfileKey, warningIfMissing);
						tie(physicalPathKey, ignore, ignore, ignore, ignore, ignore, ignore)
							= physicalPathDetails;
					}
					else
					{
						physicalPathKey = key;

						{
							bool warningIfMissing = false;
							tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,
								string,int64_t, string, string>
								mediaItemDetails =
								_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
									workspace->_workspaceKey, key, warningIfMissing);

							tie(mediaItemKey, ignore, ignore, ignore, ignore, ignore,
								ignore, ignore) = mediaItemDetails;
						}
					}

					httpBody = regex_replace(httpBody, regex("\\$\\{mediaItemKey\\}"),
						to_string(mediaItemKey));
					httpBody = regex_replace(httpBody, regex("\\$\\{physicalPathKey\\}"),
						to_string(physicalPathKey));

					_logger->info(__FILEREF__ + "userHttpCallback"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", httpProtocol: " + httpProtocol
						+ ", httpHostName: " + httpHostName
						+ ", httpURI: " + httpURI
						+ ", httpURLParameters: " + httpURLParameters
						+ ", httpMethod: " + httpMethod
						+ ", httpBody: " + httpBody
					);

					userHttpCallback(ingestionJobKey, httpProtocol, httpHostName, 
						httpPort, httpURI, httpURLParameters, httpMethod,
						callbackTimeoutInSeconds, httpHeadersRoot, httpBody,
						userName, password, maxRetries);
				}
				catch(runtime_error e)
				{
					string errorMessage = __FILEREF__ + "http callback failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", dependencyIndex: " + to_string(dependencyIndex)
						+ ", dependencies.size(): " + to_string(dependencies.size())
						+ ", e.what(): " + e.what()
					;
					_logger->error(errorMessage);

					if (dependencies.size() > 1)
					{
						if (stopIfReferenceProcessingError)
							throw runtime_error(errorMessage);
					}
					else
						throw runtime_error(errorMessage);
				}
				catch (exception e)
				{
					string errorMessage = __FILEREF__ + "http callback failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", dependencyIndex: " + to_string(dependencyIndex);
						+ ", dependencies.size(): " + to_string(dependencies.size())
					;
					_logger->error(errorMessage);

					if (dependencies.size() > 1)
					{
						if (stopIfReferenceProcessingError)
							throw runtime_error(errorMessage);
					}
					else
						throw runtime_error(errorMessage);
				}

				dependencyIndex++;
			}
		}
		else
		{
			int dependencyIndex = 0;
			for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
			{
				bool stopIfReferenceProcessingError = false;

				try
				{
					int64_t key;
					MMSEngineDBFacade::ContentType referenceContentType;
					Validator::DependencyType dependencyType;

					tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
						= keyAndDependencyType;

					Json::Value callbackMedatada;
					if (httpMethod == "POST")
					{
						callbackMedatada["workspaceKey"] = (int64_t) (workspace->_workspaceKey);

						MMSEngineDBFacade::ContentType contentType;
						int64_t physicalPathKey;
						int64_t mediaItemKey;

						if (dependencyType == Validator::DependencyType::MediaItemKey)
						{
							mediaItemKey = key;

							callbackMedatada["mediaItemKey"] = mediaItemKey;

							{
								bool warningIfMissing = false;
								tuple<MMSEngineDBFacade::ContentType, string, string, string, int64_t, int64_t>
									contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey =
									_mmsEngineDBFacade->getMediaItemKeyDetails(
										workspace->_workspaceKey, mediaItemKey, warningIfMissing);

								string localTitle;
								string userData;
								tie(contentType, localTitle, userData, ignore, ignore, ignore)
									= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;

								callbackMedatada["title"] = localTitle;

								if (userData == "")
									callbackMedatada["userData"] = Json::nullValue;
								else
								{
									Json::Value userDataRoot;
									{
										Json::CharReaderBuilder builder;
										Json::CharReader* reader = builder.newCharReader();
										string errors;

										bool parsingSuccessful = reader->parse(userData.c_str(),
											userData.c_str() + userData.size(), 
											&userDataRoot, &errors);
										delete reader;

										if (!parsingSuccessful)
										{
											string errorMessage = __FILEREF__ + "failed to parse the userData"
												+ ", errors: " + errors
												+ ", userData: " + userData
												;
											_logger->error(errorMessage);

											throw runtime_error(errors);
										}
									}

									callbackMedatada["userData"] = userDataRoot;
								}
							}

							{
								int64_t encodingProfileKey = -1;
								bool warningIfMissing = false;
								tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails =
									_mmsStorage->getPhysicalPathDetails(key, encodingProfileKey,
									warningIfMissing);

								string physicalPath;
								string fileName;
								int64_t sizeInBytes;
								string deliveryFileName;

								tie(physicalPathKey, physicalPath, ignore, ignore, fileName, ignore, ignore)
									= physicalPathDetails;

								callbackMedatada["physicalPathKey"] = physicalPathKey;
								callbackMedatada["fileName"] = fileName;
								// callbackMedatada["physicalPath"] = physicalPath;
							}
						}
						else
						{
							physicalPathKey = key;

							callbackMedatada["physicalPathKey"] = physicalPathKey;

							{
								bool warningIfMissing = false;
								tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
									mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
									_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
										workspace->_workspaceKey, physicalPathKey, warningIfMissing);

								string localTitle;
								string userData;
								tie(mediaItemKey, contentType, localTitle, userData, ignore, ignore, ignore, ignore)
									= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;

								callbackMedatada["mediaItemKey"] = mediaItemKey;
								callbackMedatada["title"] = localTitle;

								if (userData == "")
									callbackMedatada["userData"] = Json::nullValue;
								else
								{
									Json::Value userDataRoot;
									{
										Json::CharReaderBuilder builder;
										Json::CharReader* reader = builder.newCharReader();
										string errors;

										bool parsingSuccessful = reader->parse(userData.c_str(),
											userData.c_str() + userData.size(), 
											&userDataRoot, &errors);
										delete reader;

										if (!parsingSuccessful)
										{
											string errorMessage = __FILEREF__ + "failed to parse the userData"
												+ ", errors: " + errors
												+ ", userData: " + userData
												;
											_logger->error(errorMessage);

											throw runtime_error(errors);
										}
									}

									callbackMedatada["userData"] = userDataRoot;
								}
							}

							{
								int64_t encodingProfileKey = -1;
								tuple<string, int, string, string, int64_t, string> physicalPathDetails =
									_mmsStorage->getPhysicalPathDetails(physicalPathKey);

								string physicalPath;
								string fileName;
								int64_t sizeInBytes;
								string deliveryFileName;

								tie(physicalPath, ignore, ignore, fileName, ignore, ignore) = physicalPathDetails;

								callbackMedatada["fileName"] = fileName;
								// callbackMedatada["physicalPath"] = physicalPath;
							}
						}

						if (contentType == MMSEngineDBFacade::ContentType::Video
							|| contentType == MMSEngineDBFacade::ContentType::Audio)
						{
							try
							{
								int64_t durationInMilliSeconds =
									_mmsEngineDBFacade->getMediaDurationInMilliseconds(
									mediaItemKey, physicalPathKey);

								float durationInSeconds = durationInMilliSeconds / 1000;

								callbackMedatada["durationInSeconds"] = durationInSeconds;
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "getMediaDurationInMilliseconds failed"
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", mediaItemKey: " + to_string(mediaItemKey)
									+ ", physicalPathKey: " + to_string(physicalPathKey)
									+ ", exception: " + e.what()
								);
							}
							catch(exception e)
							{
								_logger->error(__FILEREF__ + "getMediaDurationInMilliseconds failed"
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", mediaItemKey: " + to_string(mediaItemKey)
									+ ", physicalPathKey: " + to_string(physicalPathKey)
								);
							}
						}
					}
					else
						callbackMedatada = Json::nullValue;

					string data;
					if (callbackMedatada != Json::nullValue)
					{
						Json::StreamWriterBuilder wbuilder;

						data = Json::writeString(wbuilder, callbackMedatada);
					}

					userHttpCallback(ingestionJobKey, httpProtocol, httpHostName, 
						httpPort, httpURI, httpURLParameters, httpMethod,
						callbackTimeoutInSeconds, httpHeadersRoot, data,
						userName, password, maxRetries);
				}
				catch(runtime_error e)
				{
					string errorMessage = __FILEREF__ + "http callback failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", dependencyIndex: " + to_string(dependencyIndex)
						+ ", dependencies.size(): " + to_string(dependencies.size())
						+ ", e.what(): " + e.what()
					;
					_logger->error(errorMessage);

					if (dependencies.size() > 1)
					{
						if (stopIfReferenceProcessingError)
							throw runtime_error(errorMessage);
					}
					else
						throw runtime_error(errorMessage);
				}
				catch (exception e)
				{
					string errorMessage = __FILEREF__ + "http callback failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", dependencyIndex: " + to_string(dependencyIndex);
						+ ", dependencies.size(): " + to_string(dependencies.size())
					;
					_logger->error(errorMessage);

					if (dependencies.size() > 1)
					{
						if (stopIfReferenceProcessingError)
							throw runtime_error(errorMessage);
					}
					else
						throw runtime_error(errorMessage);
				}

				dependencyIndex++;
			}
		}

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "httpCallbackTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "httpCallbackTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
}

void MMSEngineProcessor::postOnFacebookThread(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
		dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"postOnFacebookThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No configured any media to be posted on Facebook"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        string facebookConfigurationLabel;
        string facebookNodeId;
        {
            string field = "ConfigurationLabel";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            facebookConfigurationLabel = parametersRoot.get(field, "XXX").asString();

            field = "NodeId";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            facebookNodeId = parametersRoot.get(field, "XXX").asString();
        }
        
		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
                int64_t key;
                MMSEngineDBFacade::ContentType referenceContentType;
                Validator::DependencyType dependencyType;

                tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				string mmsAssetPathName;
				int64_t sizeInBytes;
				MMSEngineDBFacade::ContentType contentType;
            
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					int64_t encodingProfileKey = -1;
                
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string>
						physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName
						= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
					tie(ignore, mmsAssetPathName, ignore, ignore, ignore, sizeInBytes, ignore)
						= physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName;

					{
						bool warningIfMissing = false;
						tuple<MMSEngineDBFacade::ContentType, string, string, string, int64_t, int64_t>
							contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey =
							_mmsEngineDBFacade->getMediaItemKeyDetails(
								workspace->_workspaceKey, key, warningIfMissing);

						tie(contentType, ignore, ignore, ignore, ignore, ignore)
							= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;
					}
				}
				else
				{
					tuple<string, int, string, string, int64_t, string>
						physicalPathFileNameSizeInBytesAndDeliveryFileName =
						_mmsStorage->getPhysicalPathDetails(key);
					tie(mmsAssetPathName, ignore, ignore, ignore, sizeInBytes, ignore)
						= physicalPathFileNameSizeInBytesAndDeliveryFileName;
                
					{
						bool warningIfMissing = false;
						tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
							mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
							_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
								workspace->_workspaceKey, key, warningIfMissing);

						tie(ignore, contentType, ignore, ignore, ignore, ignore, ignore, ignore)
                            = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
					}
				}

				// check on thread availability was done at the beginning in this method
				if (contentType == MMSEngineDBFacade::ContentType::Video)
				{
					postVideoOnFacebook(mmsAssetPathName, 
						sizeInBytes, ingestionJobKey, workspace,
						facebookNodeId, facebookConfigurationLabel);
				}
				else // if (contentType == ContentType::Audio)
				{
				}
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "post on facebook failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "post on facebook failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
		}

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "postOnFacebookTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "postOnFacebookTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
}

void MMSEngineProcessor::postOnYouTubeThread(
        shared_ptr<long> processorsThreadsNumber,
		int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"postOnYouTubeThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No configured any media to be posted on YouTube"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        string youTubeConfigurationLabel;
        string youTubeTitle;
        string youTubeDescription;
        Json::Value youTubeTags = Json::nullValue;
        int youTubeCategoryId = -1;
        string youTubePrivacyStatus;
        {
            string field = "ConfigurationLabel";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            youTubeConfigurationLabel = parametersRoot.get(field, "XXX").asString();

            field = "Title";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                youTubeTitle = parametersRoot.get(field, "XXX").asString();

            field = "Description";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                youTubeDescription = parametersRoot.get(field, "XXX").asString();
            
            field = "Tags";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                youTubeTags = parametersRoot[field];
            
            field = "CategoryId";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                youTubeCategoryId = JSONUtils::asInt(parametersRoot, field, 0);

            field = "PrivacyStatus";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
                youTubePrivacyStatus = parametersRoot.get(field, "").asString();
            else
                youTubePrivacyStatus = "private";
        }
        
		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
                int64_t key;
                MMSEngineDBFacade::ContentType referenceContentType;
                Validator::DependencyType dependencyType;

                tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				string mmsAssetPathName;
				int64_t sizeInBytes;
				MMSEngineDBFacade::ContentType contentType;
				string title;
            
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					int64_t encodingProfileKey = -1;
                
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails
						= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey,
							warningIfMissing);
					tie(ignore, mmsAssetPathName, ignore, ignore, ignore, sizeInBytes, ignore)
						= physicalPathDetails;

					{
						bool warningIfMissing = false;
						tuple<MMSEngineDBFacade::ContentType, string, string, string, int64_t, int64_t>
							contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey =
							_mmsEngineDBFacade->getMediaItemKeyDetails(
								workspace->_workspaceKey, key, warningIfMissing);

						tie(contentType, ignore, ignore, ignore, ignore, ignore)
							= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;
					}
				}
				else
				{
					tuple<string, int, string, string, int64_t, string>
						physicalPathFileNameSizeInBytesAndDeliveryFileName =
						_mmsStorage->getPhysicalPathDetails(key);
					tie(mmsAssetPathName, ignore, ignore, ignore, sizeInBytes, ignore)
						= physicalPathFileNameSizeInBytesAndDeliveryFileName;
                
					{
						bool warningIfMissing = false;
						tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
							mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
							_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
								workspace->_workspaceKey, key, warningIfMissing);

						tie(ignore, contentType, ignore, ignore, ignore, ignore, ignore, ignore)
								= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
					}
				}
            
				if (youTubeTitle == "")
					youTubeTitle = title;

				postVideoOnYouTube(mmsAssetPathName, 
					sizeInBytes, ingestionJobKey, workspace,
					youTubeConfigurationLabel, youTubeTitle,
					youTubeDescription, youTubeTags,
					youTubeCategoryId, youTubePrivacyStatus);
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "post on youtube failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "post on youtube failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
		}

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "postOnYouTubeTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "postOnYouTubeTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
}

void MMSEngineProcessor::changeFileFormatThread(
        shared_ptr<long> processorsThreadsNumber, int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies)

{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"changeFileFormatThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try 
    {
		_logger->info(__FILEREF__ + "changeFileFormatThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No configured media to be used to changeFileFormat"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        string outputFileFormat;
        {
            string field = "OutputFileFormat";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            outputFileFormat = parametersRoot.get(field, "").asString();
        }

		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
                int64_t key;
                MMSEngineDBFacade::ContentType referenceContentType;
                Validator::DependencyType dependencyType;

                tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				int64_t mediaItemKey;
				int64_t physicalPathKey;
				string mmsSourceAssetPathName;
				string relativePath;

				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					mediaItemKey = key;
					int64_t encodingProfileKey = -1;
                
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string>
						physicalPathDetails
						= _mmsStorage->getPhysicalPathDetails(mediaItemKey,
							encodingProfileKey, warningIfMissing);
					tie(physicalPathKey, mmsSourceAssetPathName, ignore, relativePath,
						ignore, ignore, ignore) = physicalPathDetails;
				}
				else
				{
					physicalPathKey = key;

					tuple<string, int, string, string, int64_t, string>
						physicalPathDetails =
						_mmsStorage->getPhysicalPathDetails(physicalPathKey);
					tie(mmsSourceAssetPathName, ignore, relativePath, ignore, ignore, ignore)
						= physicalPathDetails;

					bool warningIfMissing = false;
					tuple<int64_t, MMSEngineDBFacade::ContentType, string, string, string,
						int64_t, string, string> mediaItemDetails =
						_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
							workspace->_workspaceKey, physicalPathKey, warningIfMissing);
					tie(mediaItemKey, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
						= mediaItemDetails;
				}

				vector<tuple<int64_t, int, int64_t, int, int, string, string, long,
					string>> videoTracks;
				vector<tuple<int64_t, int, int64_t, long, string, long, int,
					string>> audioTracks;

				_mmsEngineDBFacade->getVideoDetails(mediaItemKey, physicalPathKey,
					videoTracks, audioTracks);

				// add the new file as a new variant of the MIK
				{
					string changeFormatFileName = to_string(ingestionJobKey)
						+ "_" + to_string(mediaItemKey)
						+ "_changeFileFormat"
					;
					if (outputFileFormat == "m3u8-tar.gz" || outputFileFormat == "m3u8-streaming")
						changeFormatFileName +=	".m3u8";
					else
						changeFormatFileName +=	(string(".") + outputFileFormat);

					string stagingChangeFileFormatAssetPathName;
					{
						bool removeLinuxPathIfExist = true;
						bool neededForTranscoder = false;
						stagingChangeFileFormatAssetPathName = _mmsStorage->getStagingAssetPathName(
							neededForTranscoder,
							workspace->_directoryName,
							to_string(ingestionJobKey),
							"/",
							changeFormatFileName,
							-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
							-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
							removeLinuxPathIfExist);
					}

					try
					{
						_logger->info(__FILEREF__ + "Calling ffmpeg.changeFileFormat"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mediaItemKey: " + to_string(mediaItemKey)
							+ ", mmsSourceAssetPathName: " + mmsSourceAssetPathName
							+ ", changeFormatFileName: " + changeFormatFileName
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
						);

						FFMpeg ffmpeg (_configuration, _logger);

						ffmpeg.changeFileFormat(
							ingestionJobKey,
							physicalPathKey,
							mmsSourceAssetPathName, videoTracks, audioTracks,
							stagingChangeFileFormatAssetPathName,
							outputFileFormat);

						_logger->info(__FILEREF__ + "ffmpeg.changeFileFormat done"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mediaItemKey: " + to_string(mediaItemKey)
							+ ", mmsSourceAssetPathName: " + mmsSourceAssetPathName
							+ ", changeFormatFileName: " + changeFormatFileName
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
						);
					}
					catch(runtime_error e)
					{
						_logger->error(__FILEREF__ + "ffmpeg.changeFileFormat failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mediaItemKey: " + to_string(mediaItemKey)
							+ ", mmsSourceAssetPathName: " + mmsSourceAssetPathName
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
							+ ", e.what(): " + e.what()
						);

						throw e;
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "ffmpeg.changeFileFormat failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mediaItemKey: " + to_string(mediaItemKey)
							+ ", mmsSourceAssetPathName: " + mmsSourceAssetPathName
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
							+ ", e.what(): " + e.what()
						);

						throw e;
					}

					pair<int64_t, long> mediaInfoDetails;
					vector<tuple<int, int64_t, string, string, int, int, string, long>> videoTracks;
					vector<tuple<int, int64_t, string, long, int, long, string>> audioTracks;

					int imageWidth = -1;
					int imageHeight = -1;
					string imageFormat;
					int imageQuality = -1;
					try
					{
						_logger->info(__FILEREF__ + "Calling ffmpeg.getMediaInfo"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
						);
						bool isMMSAssetPathName = true;
						FFMpeg ffmpeg (_configuration, _logger);
						mediaInfoDetails = ffmpeg.getMediaInfo(ingestionJobKey,
							isMMSAssetPathName, stagingChangeFileFormatAssetPathName,
							videoTracks, audioTracks);

						// tie(durationInMilliSeconds, bitRate, 
						// 	videoCodecName, videoProfile, videoWidth, videoHeight, videoAvgFrameRate, videoBitRate,
						// 	audioCodecName, audioSampleRate, audioChannels, audioBitRate) = mediaInfo;
					}
					catch(runtime_error e)
					{
						_logger->error(__FILEREF__ + "getMediaInfo failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
							+ ", _workspace->_directoryName: " + workspace->_directoryName
							+ ", e.what(): " + e.what()
						);

						{
							string directoryPathName;
							try
							{
								size_t endOfDirectoryIndex = stagingChangeFileFormatAssetPathName.find_last_of("/");
								if (endOfDirectoryIndex != string::npos)
								{
									directoryPathName = stagingChangeFileFormatAssetPathName.substr(0, endOfDirectoryIndex);

									_logger->info(__FILEREF__ + "removeDirectory"
										+ ", directoryPathName: " + directoryPathName
									);
									Boolean_t bRemoveRecursively = true;
									FileIO::removeDirectory(directoryPathName, bRemoveRecursively);
								}
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "removeDirectory failed"
									+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
									+ ", directoryPathName: " + directoryPathName
									+ ", exception: " + e.what()
								);
							}
						}

						throw e;
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "getMediaInfo failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
							+ ", workspace->_directoryName: " + workspace->_directoryName
						);

						{
							string directoryPathName;
							try
							{
								size_t endOfDirectoryIndex = stagingChangeFileFormatAssetPathName.find_last_of("/");
								if (endOfDirectoryIndex != string::npos)
								{
									directoryPathName = stagingChangeFileFormatAssetPathName.substr(0, endOfDirectoryIndex);

									_logger->info(__FILEREF__ + "removeDirectory"
										+ ", directoryPathName: " + directoryPathName
									);
									Boolean_t bRemoveRecursively = true;
									FileIO::removeDirectory(directoryPathName, bRemoveRecursively);
								}
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "removeDirectory failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
									+ ", directoryPathName: " + directoryPathName
									+ ", exception: " + e.what()
								);
							}
						}

						throw e;
					}

					string mmsChangeFileFormatAssetPathName;
					unsigned long mmsPartitionIndexUsed;
					FileIO::DirectoryEntryType_t sourceFileType;
					try
					{
						bool deliveryRepositoriesToo = true;

						mmsChangeFileFormatAssetPathName = _mmsStorage->moveAssetInMMSRepository(
							ingestionJobKey,
							stagingChangeFileFormatAssetPathName,
							workspace->_directoryName,
							changeFormatFileName,
							relativePath,

							&mmsPartitionIndexUsed, // OUT
							&sourceFileType,

							deliveryRepositoriesToo,
							workspace->_territories
						);
					}
					catch(runtime_error e)
					{
						_logger->error(__FILEREF__ + "_mmsStorage->moveAssetInMMSRepository failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mediaItemKey: " + to_string(mediaItemKey)
							+ ", mmsSourceAssetPathName: " + mmsSourceAssetPathName
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
							+ ", e.what(): " + e.what()
						);

						{
							string directoryPathName;
							try
							{
								size_t endOfDirectoryIndex = stagingChangeFileFormatAssetPathName.find_last_of("/");
								if (endOfDirectoryIndex != string::npos)
								{
									directoryPathName = stagingChangeFileFormatAssetPathName.substr(0, endOfDirectoryIndex);

									_logger->info(__FILEREF__ + "removeDirectory"
										+ ", directoryPathName: " + directoryPathName
									);
									Boolean_t bRemoveRecursively = true;
									FileIO::removeDirectory(directoryPathName, bRemoveRecursively);
								}
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "removeDirectory failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
									+ ", directoryPathName: " + directoryPathName
									+ ", exception: " + e.what()
								);
							}
						}

						throw e;
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "_mmsStorage->moveAssetInMMSRepository failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mediaItemKey: " + to_string(mediaItemKey)
							+ ", mmsSourceAssetPathName: " + mmsSourceAssetPathName
							+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
							+ ", e.what(): " + e.what()
						);

						{
							string directoryPathName;
							try
							{
								size_t endOfDirectoryIndex = stagingChangeFileFormatAssetPathName.find_last_of("/");
								if (endOfDirectoryIndex != string::npos)
								{
									directoryPathName = stagingChangeFileFormatAssetPathName.substr(0, endOfDirectoryIndex);

									_logger->info(__FILEREF__ + "removeDirectory"
										+ ", directoryPathName: " + directoryPathName
									);
									Boolean_t bRemoveRecursively = true;
									FileIO::removeDirectory(directoryPathName, bRemoveRecursively);
								}
							}
							catch(runtime_error e)
							{
								_logger->error(__FILEREF__ + "removeDirectory failed"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
									+ ", directoryPathName: " + directoryPathName
									+ ", exception: " + e.what()
								);
							}
						}

						throw e;
					}

					// remove staging directory
					{
						string directoryPathName;
						try
						{
							size_t endOfDirectoryIndex = stagingChangeFileFormatAssetPathName.find_last_of("/");
							if (endOfDirectoryIndex != string::npos)
							{
								directoryPathName = stagingChangeFileFormatAssetPathName.substr(0,
									endOfDirectoryIndex);

								_logger->info(__FILEREF__ + "removeDirectory"
									+ ", directoryPathName: " + directoryPathName
								);
								Boolean_t bRemoveRecursively = true;
								FileIO::removeDirectory(directoryPathName, bRemoveRecursively);
							}
						}
						catch(runtime_error e)
						{
							_logger->error(__FILEREF__ + "removeDirectory failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", stagingChangeFileFormatAssetPathName: " + stagingChangeFileFormatAssetPathName
								+ ", directoryPathName: " + directoryPathName
								+ ", exception: " + e.what()
							);
						}
					}

					try
					{
						int64_t physicalItemRetentionInMinutes = -1;
						{
							string field = "PhysicalItemRetention";
							if (JSONUtils::isMetadataPresent(parametersRoot, field))
							{
								string retention = parametersRoot.get(field, "1d").asString();
								physicalItemRetentionInMinutes = MMSEngineDBFacade::parseRetention(retention);
							}
						}

						unsigned long long mmsAssetSizeInBytes;
						{
							bool inCaseOfLinkHasItToBeRead = false;
							mmsAssetSizeInBytes = FileIO::getFileSizeInBytes(mmsChangeFileFormatAssetPathName,
								inCaseOfLinkHasItToBeRead);   
						}

						bool externalReadOnlyStorage = false;
						string externalDeliveryTechnology;
						string externalDeliveryURL;
						int64_t liveRecordingIngestionJobKey = -1;
						int64_t changeFormatPhysicalPathKey = _mmsEngineDBFacade->saveVariantContentMetadata(
							workspace->_workspaceKey,
							ingestionJobKey,
							liveRecordingIngestionJobKey,
							mediaItemKey,
							externalReadOnlyStorage,
							externalDeliveryTechnology,
							externalDeliveryURL,
							changeFormatFileName,
							relativePath,
							mmsPartitionIndexUsed,
							mmsAssetSizeInBytes,
							-1,	// encodingProfileKey,
							physicalItemRetentionInMinutes,

							mediaInfoDetails,
							videoTracks,
							audioTracks,

							imageWidth,
							imageHeight,
							imageFormat,
							imageQuality
						);

						_logger->info(__FILEREF__ + "Saved the Encoded content"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", changeFormatPhysicalPathKey: " + to_string(changeFormatPhysicalPathKey)
						);
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "_mmsEngineDBFacade->saveVariantContentMetadata failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
						);

						if (sourceFileType == FileIO::TOOLS_FILEIO_DIRECTORY)
						{
							if (FileIO::directoryExisting(mmsChangeFileFormatAssetPathName))
							{
								_logger->info(__FILEREF__ + "Remove directory"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", mmsChangeFileFormatAssetPathName: " + mmsChangeFileFormatAssetPathName
								);

								Boolean_t bRemoveRecursively = true;
								FileIO::removeDirectory(mmsChangeFileFormatAssetPathName, bRemoveRecursively);
							}
						}
						else
						{
							if (FileIO::fileExisting(mmsChangeFileFormatAssetPathName))
							{
								_logger->info(__FILEREF__ + "Remove"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", mmsChangeFileFormatAssetPathName: " + mmsChangeFileFormatAssetPathName
								);

								FileIO::remove(mmsChangeFileFormatAssetPathName);
							}

							throw e;
						}
					}
				}
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "change file format failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "change file format failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
		}

		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
    }
    catch (runtime_error& e) 
    {
        _logger->error(__FILEREF__ + "ChangeFileFormat failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
        return;
    }
    catch (exception e)
    {
        _logger->error(__FILEREF__ + "ChangeFileFormat failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

        return;
    }
}


// this is to generate one Frame
void MMSEngineProcessor::generateAndIngestFrameThread(
        shared_ptr<long> processorsThreadsNumber, int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        MMSEngineDBFacade::IngestionType ingestionType,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"generateAndIngestFrameThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
		_logger->info(__FILEREF__ + "generateAndIngestFrameThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        string field;
        
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No video found"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", dependencies.size: " + to_string(dependencies.size());
            _logger->warn(errorMessage);

            // throw runtime_error(errorMessage);
        }

        string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(
			workspace);

		int dependencyIndex = 0;
        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
			bool stopIfReferenceProcessingError = false;

			try
			{
				int64_t key;
				MMSEngineDBFacade::ContentType referenceContentType;
				Validator::DependencyType dependencyType;

				tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				if (referenceContentType != MMSEngineDBFacade::ContentType::Video)
				{
					string errorMessage = __FILEREF__ + "ContentTpe is not a Video"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}

				int64_t sourceMediaItemKey;
				int64_t sourcePhysicalPathKey;
				string sourcePhysicalPath;
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					int64_t encodingProfileKey = -1;
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails
						= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey,
							warningIfMissing);
					tie(sourcePhysicalPathKey, sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore)
						= physicalPathDetails;

					sourceMediaItemKey = key;
				}
				else
				{
					sourcePhysicalPathKey = key;

					bool warningIfMissing = false;
					tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
						mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
						_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
							workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);
					tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
							= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;

					tuple<string, int, string, string, int64_t, string> physicalPathDetails =
						_mmsStorage->getPhysicalPathDetails(sourcePhysicalPathKey);
					tie(sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore)
						= physicalPathDetails;
				}

				int periodInSeconds;
				double startTimeInSeconds;
				int maxFramesNumber;
				string videoFilter;
				bool mjpeg;
				int imageWidth;
				int imageHeight;
				int64_t durationInMilliSeconds;
				fillGenerateFramesParameters(
					workspace,
					ingestionJobKey,
					ingestionType,
					parametersRoot,
					sourceMediaItemKey, sourcePhysicalPathKey,
                
					periodInSeconds, startTimeInSeconds,
					maxFramesNumber, videoFilter,
					mjpeg, imageWidth, imageHeight,
					durationInMilliSeconds);
        
				string fileFormat = "jpg";
				string frameFileName = to_string(ingestionJobKey) + "." + fileFormat;
				string frameAssetPathName = workspaceIngestionRepository + "/" + frameFileName;

				pid_t childPid;
				FFMpeg ffmpeg (_configuration, _logger);
				ffmpeg.generateFrameToIngest(
					ingestionJobKey,
					sourcePhysicalPath,
					durationInMilliSeconds,
					startTimeInSeconds,
					frameAssetPathName,
					imageWidth, 
					imageHeight,
					&childPid
				);

				{
					_logger->info(__FILEREF__ + "Generated Frame to ingest"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", frameAssetPathName: " + frameAssetPathName
						+ ", fileFormat: " + fileFormat
					);

					string title;
					int64_t imageOfVideoMediaItemKey = sourceMediaItemKey;
					int64_t cutOfVideoMediaItemKey = -1;
					int64_t cutOfAudioMediaItemKey = -1;
					double startTimeInSeconds = 0.0;
					double endTimeInSeconds = 0.0;
					string imageMetaDataContent = generateMediaMetadataToIngest(
						ingestionJobKey,
						fileFormat,
						title,
						imageOfVideoMediaItemKey,
						cutOfVideoMediaItemKey, cutOfAudioMediaItemKey, startTimeInSeconds, endTimeInSeconds,
						parametersRoot
					);

					try
					{
						shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent 
							= make_shared<LocalAssetIngestionEvent>();

						localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
						localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
						localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

						localAssetIngestionEvent->setExternalReadOnlyStorage(false);
						localAssetIngestionEvent->setIngestionJobKey(ingestionJobKey);
						localAssetIngestionEvent->setIngestionSourceFileName(frameFileName);
						// localAssetIngestionEvent->setMMSSourceFileName(mmsSourceFileName);
						localAssetIngestionEvent->setMMSSourceFileName(frameFileName);
						localAssetIngestionEvent->setWorkspace(workspace);
						localAssetIngestionEvent->setIngestionType(
							MMSEngineDBFacade::IngestionType::AddContent);
						localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(true);

						localAssetIngestionEvent->setMetadataContent(imageMetaDataContent);

						handleLocalAssetIngestionEventThread (
							processorsThreadsNumber, *localAssetIngestionEvent);
					}
					catch(runtime_error e)
					{
						_logger->error(__FILEREF__ + "handleLocalAssetIngestionEvent failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", exception: " + e.what()
						);

						{
							_logger->info(__FILEREF__ + "Remove file"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", frameAssetPathName: " + frameAssetPathName
							);
							FileIO::remove(frameAssetPathName);
						}

						throw e;
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "handleLocalAssetIngestionEvent failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", exception: " + e.what()
						);

						{
							_logger->info(__FILEREF__ + "Remove file"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", frameAssetPathName: " + frameAssetPathName
							);
							FileIO::remove(frameAssetPathName);
						}

						throw e;
					}
				}
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "generate and ingest frame failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex)
					+ ", dependencies.size(): " + to_string(dependencies.size())
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}
			catch (exception e)
			{
				string errorMessage = __FILEREF__ + "generate and ingest frame failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", dependencyIndex: " + to_string(dependencyIndex);
					+ ", dependencies.size(): " + to_string(dependencies.size())
				;
				_logger->error(errorMessage);

				if (dependencies.size() > 1)
				{
					if (stopIfReferenceProcessingError)
						throw runtime_error(errorMessage);
				}
				else
					throw runtime_error(errorMessage);
			}

			dependencyIndex++;
        }

		/*
		_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_TaskSuccess"
				+ ", errorMessage: " + ""
		);
		_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
			MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
			"" // errorMessage
		);
		*/
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "generateAndIngestFrame failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		// it's a thread, no throw
        // throw e;
		return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "generateAndIngestFrame failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
		// it's a thread, no throw
        // throw e;
        return;
    }
}

void MMSEngineProcessor::manageFaceRecognitionMediaTask(
        int64_t ingestionJobKey,
        MMSEngineDBFacade::IngestionStatus ingestionStatus,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong medias number to be processed for Face Recognition"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		MMSEngineDBFacade::EncodingPriority encodingPriority;
		string field = "EncodingPriority";
		if (!JSONUtils::isMetadataPresent(parametersRoot, field))
		{
			encodingPriority = 
				static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
		}
		else
		{
			encodingPriority =
				MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
		}

        string faceRecognitionCascadeName;
        string faceRecognitionOutput;
		long initialFramesNumberToBeSkipped;
		bool oneFramePerSecond;
        {
            string field = "CascadeName";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            faceRecognitionCascadeName = parametersRoot.get(field, "XXX").asString();

            field = "Output";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            faceRecognitionOutput = parametersRoot.get(field, "XXX").asString();

			initialFramesNumberToBeSkipped = 0;
			oneFramePerSecond = true;
			if (faceRecognitionOutput == "FrameContainingFace")
			{
				field = "InitialFramesNumberToBeSkipped";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					initialFramesNumberToBeSkipped = JSONUtils::asInt(parametersRoot, field, 0);

				field = "OneFramePerSecond";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					oneFramePerSecond = JSONUtils::asBool(parametersRoot, field, false);
			}
        }
        
        {
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType	= dependencies[0];

			string mmsAssetPathName;
            MMSEngineDBFacade::ContentType contentType;
            string title;
			int64_t sourceMediaItemKey;
			int64_t sourcePhysicalPathKey;
            
            int64_t key;
            MMSEngineDBFacade::ContentType referenceContentType;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;
            
            tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

            if (dependencyType == Validator::DependencyType::MediaItemKey)
            {
                int64_t encodingProfileKey = -1;
                
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string>
					physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName
					= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
				tie(sourcePhysicalPathKey, mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName;

				sourceMediaItemKey = key;

                {
                    bool warningIfMissing = false;
                    tuple<MMSEngineDBFacade::ContentType,string,string,string, int64_t, int64_t>
						contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey =
                        _mmsEngineDBFacade->getMediaItemKeyDetails(
                            workspace->_workspaceKey, key, warningIfMissing);

                    tie(contentType, ignore, ignore, ignore, ignore, ignore)
						= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;
                }
            }
            else
            {
				tuple<string, int, string, string, int64_t, string>
					physicalPathFileNameSizeInBytesAndDeliveryFileName =
					_mmsStorage->getPhysicalPathDetails(key);
				tie(mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathFileNameSizeInBytesAndDeliveryFileName;

				sourcePhysicalPathKey = key;

                {
                    bool warningIfMissing = false;
                    tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
						mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                        _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                            workspace->_workspaceKey, key, warningIfMissing);

                    tie(sourceMediaItemKey, contentType, ignore, ignore, ignore, ignore, ignore, ignore)
                            = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
                }
            }
            
			_mmsEngineDBFacade->addEncoding_FaceRecognitionJob(workspace, ingestionJobKey,
                sourceMediaItemKey, sourcePhysicalPathKey, mmsAssetPathName,
				faceRecognitionCascadeName, faceRecognitionOutput, encodingPriority,
				initialFramesNumberToBeSkipped, oneFramePerSecond);
        }
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageFaceRecognitionMediaTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageFaceRecognitionMediaTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageFaceIdentificationMediaTask(
        int64_t ingestionJobKey,
        MMSEngineDBFacade::IngestionStatus ingestionStatus,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong medias number to be processed for Face Identification"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		MMSEngineDBFacade::EncodingPriority encodingPriority;
		string field = "EncodingPriority";
		if (!JSONUtils::isMetadataPresent(parametersRoot, field))
		{
			encodingPriority = 
				static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
		}
		else
		{
			encodingPriority =
				MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
		}

		string faceIdentificationCascadeName;
        string deepLearnedModelTagsCommaSeparated;
        {
            string field = "CascadeName";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            faceIdentificationCascadeName = parametersRoot.get(field, "XXX").asString();

            field = "DeepLearnedModelTags";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            deepLearnedModelTagsCommaSeparated = parametersRoot.get(field, "XXX").asString();
        }
        
        {
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType	= dependencies[0];

			string mmsAssetPathName;
            MMSEngineDBFacade::ContentType contentType;
            string title;
            
            int64_t key;
            MMSEngineDBFacade::ContentType referenceContentType;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;
            
            tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

            if (dependencyType == Validator::DependencyType::MediaItemKey)
            {
                int64_t encodingProfileKey = -1;
                
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string>
					physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName
					= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
				tie(ignore, mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName;

                {
                    bool warningIfMissing = false;
                    tuple<MMSEngineDBFacade::ContentType,string,string,string, int64_t, int64_t>
						contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey =
                        _mmsEngineDBFacade->getMediaItemKeyDetails(
                            workspace->_workspaceKey, key, warningIfMissing);

                    tie(contentType, ignore, ignore, ignore, ignore, ignore)
						= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;
                }
            }
            else
            {
				tuple<string, int, string, string, int64_t, string>
					physicalPathFileNameSizeInBytesAndDeliveryFileName =
					_mmsStorage->getPhysicalPathDetails(key);
				tie(mmsAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathFileNameSizeInBytesAndDeliveryFileName;
                {
                    bool warningIfMissing = false;
                    tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
						mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                        _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                            workspace->_workspaceKey, key, warningIfMissing);

                    tie(ignore, contentType, ignore, ignore, ignore, ignore, ignore, ignore)
                            = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
                }
            }
            
			_mmsEngineDBFacade->addEncoding_FaceIdentificationJob(workspace, ingestionJobKey,
                mmsAssetPathName, faceIdentificationCascadeName, deepLearnedModelTagsCommaSeparated,
				encodingPriority);
        }
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageFaceIdendificationMediaTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageFaceIdendificationMediaTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageLiveRecorder(
        int64_t ingestionJobKey,
		string ingestionJobLabel,
        MMSEngineDBFacade::IngestionStatus ingestionStatus,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot
)
{
    try
    {
		MMSEngineDBFacade::EncodingPriority encodingPriority;
		string field = "EncodingPriority";
		if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			encodingPriority = static_cast<MMSEngineDBFacade::EncodingPriority>(
				workspace->_maxEncodingPriority);
		else
			encodingPriority = MMSEngineDBFacade::toEncodingPriority(
				parametersRoot.get(field, "").asString());

		string configurationLabel;

		int64_t confKey = -1;
		string streamSourceType;
		string encodersPoolLabel;
		string pullUrl;
		string pushProtocol;
		int64_t pushEncoderKey = -1;
		string pushServerName;
		int pushServerPort = -1;
		string pushUri;
		int pushListenTimeout = -1;
		int captureVideoDeviceNumber = -1;
		string captureVideoInputFormat;
		int captureFrameRate = -1;
		int captureWidth = -1;
		int captureHeight = -1;
		int captureAudioDeviceNumber = -1;
		int captureChannelsNumber = -1;
		int64_t tvSourceTVConfKey = -1;

		int64_t deliveryCode;

		string userAgent;
        string recordingPeriodStart;
        string recordingPeriodEnd;
        bool autoRenew;
		int segmentDurationInSeconds;
		string outputFileFormat;
		bool liveRecorderVirtualVOD = false;
		int liveRecorderVirtualVODMaxDurationInMinutes = 30;
		int64_t virtualVODEncodingProfileKey = -1;
		int virtualVODSegmentDurationInSeconds = 10;
		bool monitorHLS = false;
		int monitorPlaylistEntriesNumber = 0;
		int monitorSegmentDurationInSeconds = 0;
		int64_t monitorEncodingProfileKey = -1;
		Json::Value outputsRoot = Json::nullValue;
		Json::Value framesToBeDetectedRoot = Json::nullValue;
        {
			{
				field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				configurationLabel = parametersRoot.get(field, "").asString();

				{
					bool warningIfMissing = false;
					tuple<int64_t, string, string, string, string, int64_t, string, int, string, int,
						int, string, int, int, int, int, int, int64_t>
						channelConfDetails = _mmsEngineDBFacade->getStreamDetails(
						workspace->_workspaceKey, configurationLabel, warningIfMissing);
					tie(confKey, streamSourceType,
						encodersPoolLabel,
						pullUrl,
						pushProtocol, pushEncoderKey, pushServerName, pushServerPort, pushUri,
						pushListenTimeout,
						captureVideoDeviceNumber,
						captureVideoInputFormat,
						captureFrameRate, captureWidth, captureHeight,
						captureAudioDeviceNumber, captureChannelsNumber,
						tvSourceTVConfKey) = channelConfDetails;

					// default is IP_PULL
					if (streamSourceType == "")
						streamSourceType = "IP_PULL";
				}
			}

			// EncodersPool override the one included in ChannelConf if present
            field = "EncodersPool";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				encodersPoolLabel = parametersRoot.get(field, "").asString();

            field = "UserAgent";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				userAgent = parametersRoot.get(field, "").asString();

            field = "schedule";
			Json::Value recordingPeriodRoot = parametersRoot[field];

            field = "start";
            if (!JSONUtils::isMetadataPresent(recordingPeriodRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            recordingPeriodStart = recordingPeriodRoot.get(field, "").asString();

            field = "end";
            if (!JSONUtils::isMetadataPresent(recordingPeriodRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            recordingPeriodEnd = recordingPeriodRoot.get(field, "").asString();

            field = "autoRenew";
            if (!JSONUtils::isMetadataPresent(recordingPeriodRoot, field))
				autoRenew = false;
			else
				autoRenew = JSONUtils::asBool(recordingPeriodRoot, field, false);

            field = "SegmentDuration";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            segmentDurationInSeconds = JSONUtils::asInt(parametersRoot, field, 0);

            field = "OutputFileFormat";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				outputFileFormat = "ts";
			else
            	outputFileFormat = parametersRoot.get(field, "XXX").asString();

			field = "MonitorHLS";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				Json::Value monitorHLSRoot = parametersRoot[field];

				monitorHLS = true;

				field = "PlaylistEntriesNumber";
				if (!JSONUtils::isMetadataPresent(monitorHLSRoot, field))
					monitorPlaylistEntriesNumber = 6;
				else
					monitorPlaylistEntriesNumber = JSONUtils::asInt(monitorHLSRoot, field, 6);

				field = "SegmentDurationInSeconds";
				if (!JSONUtils::isMetadataPresent(monitorHLSRoot, field))
					monitorSegmentDurationInSeconds = 10;
				else
					monitorSegmentDurationInSeconds = JSONUtils::asInt(monitorHLSRoot, field, 10);


				string keyField = "EncodingProfileKey";
				string labelField = "EncodingProfileLabel";
				string contentTypeField = "ContentType";
				if (JSONUtils::isMetadataPresent(monitorHLSRoot, keyField))
					monitorEncodingProfileKey = JSONUtils::asInt64(monitorHLSRoot, keyField, 0);
				else if (JSONUtils::isMetadataPresent(monitorHLSRoot, labelField))
				{
					string encodingProfileLabel = monitorHLSRoot.get(labelField, "").asString();

					MMSEngineDBFacade::ContentType contentType;
					if (JSONUtils::isMetadataPresent(monitorHLSRoot, contentTypeField))
					{
						contentType = MMSEngineDBFacade::toContentType(
							monitorHLSRoot.get(contentTypeField, "").asString());

						monitorEncodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
							workspace->_workspaceKey, contentType,
							encodingProfileLabel);
					}
					else
					{
						bool contentTypeToBeUsed = false;
						monitorEncodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
							workspace->_workspaceKey, contentType,
							encodingProfileLabel, contentTypeToBeUsed);
					}
				}
			}
			else
			{
				monitorHLS = false;
			}

			field = "LiveRecorderVirtualVOD";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				Json::Value virtualVODRoot = parametersRoot[field];

				liveRecorderVirtualVOD = true;

				field = "LiveRecorderVirtualVODMaxDuration";
				liveRecorderVirtualVODMaxDurationInMinutes = JSONUtils::asInt(
					virtualVODRoot, field, 30);

				field = "SegmentDurationInSeconds";
				if (!JSONUtils::isMetadataPresent(virtualVODRoot, field))
					virtualVODSegmentDurationInSeconds = 10;
				else
					virtualVODSegmentDurationInSeconds = JSONUtils::asInt(virtualVODRoot, field, 10);

				string keyField = "EncodingProfileKey";
				string labelField = "EncodingProfileLabel";
				string contentTypeField = "ContentType";
				if (JSONUtils::isMetadataPresent(virtualVODRoot, keyField))
					virtualVODEncodingProfileKey = JSONUtils::asInt64(virtualVODRoot, keyField, 0);
				else if (JSONUtils::isMetadataPresent(virtualVODRoot, labelField))
				{
					string encodingProfileLabel = virtualVODRoot.get(labelField, "").asString();

					MMSEngineDBFacade::ContentType contentType;
					if (JSONUtils::isMetadataPresent(virtualVODRoot, contentTypeField))
					{
						contentType = MMSEngineDBFacade::toContentType(
							virtualVODRoot.get(contentTypeField, "").asString());

						virtualVODEncodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
							workspace->_workspaceKey, contentType, encodingProfileLabel);
					}
					else
					{
						bool contentTypeToBeUsed = false;
						virtualVODEncodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
							workspace->_workspaceKey, contentType,
							encodingProfileLabel, contentTypeToBeUsed);
					}
				}
			}
			else
			{
				liveRecorderVirtualVOD = false;
			}

			field = "DeliveryCode";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			deliveryCode = JSONUtils::asInt64(parametersRoot, field, 0);

			field = "Outputs";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				outputsRoot = parametersRoot[field];

			if (JSONUtils::isMetadataPresent(parametersRoot, "framesToBeDetected"))
			{
				framesToBeDetectedRoot = parametersRoot["framesToBeDetected"];

				for(int pictureIndex = 0; pictureIndex < framesToBeDetectedRoot.size();
					pictureIndex++)
				{
					Json::Value frameToBeDetectedRoot = framesToBeDetectedRoot[pictureIndex];

					if (JSONUtils::isMetadataPresent(frameToBeDetectedRoot,
						"picturePhysicalPathKey"))
					{
						int64_t physicalPathKey = JSONUtils::asInt64(frameToBeDetectedRoot,
							"picturePhysicalPathKey", -1);
						string picturePathName;

						tuple<string, int, string, string, int64_t, string> physicalPathDetails =
							_mmsStorage->getPhysicalPathDetails(physicalPathKey);
						tie(picturePathName, ignore, ignore, ignore, ignore, ignore)
							= physicalPathDetails;

						bool videoFrameToBeCropped = JSONUtils::asBool(frameToBeDetectedRoot,
							"videoFrameToBeCropped", false);
						if (videoFrameToBeCropped)
						{
							int width;
							int height;

							tuple<int, int, string, int> imageDetails =
								_mmsEngineDBFacade->getImageDetails(-1, physicalPathKey);
							tie(width, height, ignore, ignore) = imageDetails;

							frameToBeDetectedRoot["width"] = width;
							frameToBeDetectedRoot["height"] = height;
						}

						frameToBeDetectedRoot["picturePathName"] = picturePathName;

						framesToBeDetectedRoot[pictureIndex] = frameToBeDetectedRoot;
					}
				}
			}
        }

		// Validator validator(_logger, _mmsEngineDBFacade, _configuration);

		time_t utcRecordingPeriodStart = DateTime::sDateSecondsToUtc(recordingPeriodStart);
		// _logger->error(__FILEREF__ + "ctime recordingPeriodStart: "
		//		+ ctime(utcRecordingPeriodStart));

		// next code is the same in the Validator class
		time_t utcRecordingPeriodEnd = DateTime::sDateSecondsToUtc(recordingPeriodEnd);

		string tvType;
		int64_t tvServiceId = -1;
		int64_t tvFrequency = -1;
		int64_t tvSymbolRate = -1;
		int64_t tvBandwidthInHz = -1;
		string tvModulation;
		int tvVideoPid = -1;
		int tvAudioItalianPid = -1;
		string liveURL;

		if (streamSourceType == "IP_PULL")
			liveURL = pullUrl;
		else if (streamSourceType == "IP_PUSH")
		{
			liveURL = pushProtocol + "://" + pushServerName
				+ ":" + to_string(pushServerPort) + pushUri;
		}
		else if (streamSourceType == "TV")
		{
			bool warningIfMissing = false;
			tuple<string, int64_t, int64_t, int64_t, int64_t, string, int, int>
				tvChannelConfDetails =
				_mmsEngineDBFacade->getSourceTVStreamDetails(
				tvSourceTVConfKey, warningIfMissing);

			tie(tvType, tvServiceId, tvFrequency,
				tvSymbolRate, tvBandwidthInHz, tvModulation,
				tvVideoPid, tvAudioItalianPid) = tvChannelConfDetails;
		}

		{
			int encodersNumber = _mmsEngineDBFacade->getEncodersNumberByEncodersPool(
				workspace->_workspaceKey, encodersPoolLabel);
			if (encodersNumber == 0)
			{
				string errorMessage = __FILEREF__ + "No encoders available"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
		}

		Json::Value localOutputsRoot = getReviewedOutputsRoot(outputsRoot,
			workspace, ingestionJobKey, false);

		// in case we have monitorHLS and/or liveRecorderVirtualVOD,
		// this will be "translate"
		// in one entry added to the outputsRoot
		string monitorManifestDirectoryPath;
		string monitorManifestFileName;
		if(monitorHLS || liveRecorderVirtualVOD)
		{
			int64_t monitorVirtualVODEncodingProfileKey = -1;
			{
				if (monitorEncodingProfileKey != -1 && virtualVODEncodingProfileKey != -1)
					monitorVirtualVODEncodingProfileKey = virtualVODEncodingProfileKey;
				else if (monitorEncodingProfileKey != -1 && virtualVODEncodingProfileKey == -1)
					monitorVirtualVODEncodingProfileKey = monitorEncodingProfileKey;
				else if (monitorEncodingProfileKey == -1 && virtualVODEncodingProfileKey != -1)
					monitorVirtualVODEncodingProfileKey = virtualVODEncodingProfileKey;
			}

			Json::Value encodingProfileDetailsRoot = Json::nullValue;
			MMSEngineDBFacade::ContentType encodingProfileContentType =
				MMSEngineDBFacade::ContentType::Video;
			if (monitorVirtualVODEncodingProfileKey != -1)
			{
				string jsonEncodingProfile;

				tuple<string, MMSEngineDBFacade::ContentType, MMSEngineDBFacade::DeliveryTechnology, string>
					encodingProfileDetails = _mmsEngineDBFacade->getEncodingProfileDetailsByKey(
					workspace->_workspaceKey, monitorVirtualVODEncodingProfileKey);
				tie(ignore, encodingProfileContentType, ignore, jsonEncodingProfile) =
					encodingProfileDetails;

				{
					Json::CharReaderBuilder builder;
					Json::CharReader* reader = builder.newCharReader();
					string errors;

					bool parsingSuccessful = reader->parse(jsonEncodingProfile.c_str(),
						jsonEncodingProfile.c_str() + jsonEncodingProfile.size(), 
						&encodingProfileDetailsRoot,
						&errors);
					delete reader;

					if (!parsingSuccessful)
					{
						string errorMessage = __FILEREF__ + "failed to parse 'parameters'"
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", errors: " + errors
						;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}
				}
			}

			{
				string manifestExtension;
				manifestExtension = "m3u8";

				if (streamSourceType == "IP_PULL")
				{
					// monitorHLS is true
					monitorManifestDirectoryPath = _mmsStorage->getLiveDeliveryAssetPath(
						to_string(deliveryCode),
						workspace);

					monitorManifestFileName = to_string(deliveryCode) + ".m3u8";
				}
				else if (streamSourceType == "TV")
				{
					// monitorHLS is true
					monitorManifestDirectoryPath = _mmsStorage->getLiveDeliveryAssetPath(
						to_string(deliveryCode),
						workspace);

					monitorManifestFileName = to_string(deliveryCode) + ".m3u8";
				}
				else if (streamSourceType == "IP_PUSH")
				{
					monitorManifestDirectoryPath = _mmsStorage->getLiveDeliveryAssetPath(
						to_string(deliveryCode),
						workspace);

					monitorManifestFileName = to_string(deliveryCode) + ".m3u8";
				}
				else if (streamSourceType == "CaptureLive")
				{
					monitorManifestDirectoryPath = _mmsStorage->getLiveDeliveryAssetPath(
						to_string(deliveryCode),
						workspace);

					monitorManifestFileName = to_string(deliveryCode) + ".m3u8";
				}
			}

			string otherOutputOptions;
			{
				string recordedFileNamePrefix = string("liveRecorder_")
					+ to_string(ingestionJobKey)
					// + "_" + to_string(_encodingItem->_encodingJobKey)
				;
				string segmentFilePathName = monitorManifestDirectoryPath + "/"
					+ recordedFileNamePrefix + "_%s." + outputFileFormat;

				otherOutputOptions = "-hls_flags program_date_time -strftime 1 -hls_segment_filename " + segmentFilePathName + " -f hls";
			}

			int monitorVirtualVODSegmentDurationInSeconds;
			{
				if (liveRecorderVirtualVOD)
					monitorVirtualVODSegmentDurationInSeconds = virtualVODSegmentDurationInSeconds;
				else
					monitorVirtualVODSegmentDurationInSeconds = monitorSegmentDurationInSeconds;
			}

			int monitorVirtualVODPlaylistEntriesNumber;
			{
				if (liveRecorderVirtualVOD)
				{
					monitorVirtualVODPlaylistEntriesNumber = (liveRecorderVirtualVODMaxDurationInMinutes * 60) / 
						monitorVirtualVODSegmentDurationInSeconds;
				}
				else
					monitorVirtualVODPlaylistEntriesNumber = monitorPlaylistEntriesNumber;
			}

			Json::Value localOutputRoot;

			field = "outputType";
			localOutputRoot[field] = string("HLS");

			field = "otherOutputOptions";
			localOutputRoot[field] = otherOutputOptions;

			field = "filters";
			localOutputRoot[field] = Json::nullValue;

			field = "segmentDurationInSeconds";
			localOutputRoot[field] = monitorVirtualVODSegmentDurationInSeconds;

			field = "playlistEntriesNumber";
			localOutputRoot[field] = monitorVirtualVODPlaylistEntriesNumber;

			{
				field = "encodingProfileKey";
				localOutputRoot[field] = monitorVirtualVODEncodingProfileKey;

				field = "encodingProfileDetails";
				localOutputRoot[field] = encodingProfileDetailsRoot;

				field = "encodingProfileContentType";
				localOutputRoot[field] = MMSEngineDBFacade::toString(encodingProfileContentType);
			}

			field = "manifestDirectoryPath";
			localOutputRoot[field] = monitorManifestDirectoryPath;

			field = "manifestFileName";
			localOutputRoot[field] = monitorManifestFileName;

			field = "rtmpUrl";
			localOutputRoot[field] = string("");

			field = "playUrl";
			localOutputRoot[field] = string("");

			localOutputsRoot.append(localOutputRoot);
		}

		_mmsEngineDBFacade->addEncoding_LiveRecorderJob(workspace, ingestionJobKey,
			ingestionJobLabel, streamSourceType,
			configurationLabel, confKey, liveURL, encodersPoolLabel, userAgent,
			utcRecordingPeriodStart, utcRecordingPeriodEnd,
			autoRenew, segmentDurationInSeconds, outputFileFormat, encodingPriority,

			pushListenTimeout, pushEncoderKey, pushServerName,
			captureVideoDeviceNumber,
			captureVideoInputFormat, captureFrameRate,
			captureWidth, captureHeight, captureAudioDeviceNumber,
			captureChannelsNumber,

			tvType, tvServiceId, tvFrequency, tvSymbolRate, tvBandwidthInHz,
			tvModulation, tvVideoPid, tvAudioItalianPid,

			monitorHLS,
			liveRecorderVirtualVOD,
			monitorManifestDirectoryPath,	// used by FFMPEGEncoder.cpp to build virtualVOD
			monitorManifestFileName,	// used by FFMPEGEncoder.cpp to build virtualVOD

			localOutputsRoot, framesToBeDetectedRoot,
			_mmsWorkflowIngestionURL, _mmsBinaryIngestionURL);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageLiveRecorder failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageLiveRecorder failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageLiveProxy(
	int64_t ingestionJobKey,
	MMSEngineDBFacade::IngestionStatus ingestionStatus,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot
)
{
    try
    {
		/*
		 * commented because it will be High by default
		MMSEngineDBFacade::EncodingPriority encodingPriority;
		string field = "EncodingPriority";
		if (!JSONUtils::isMetadataPresent(parametersRoot, field))
		{
			encodingPriority = 
				static_cast<MMSEngineDBFacade::EncodingPriority>(
				workspace->_maxEncodingPriority);
		}
		else
		{
			encodingPriority =
				MMSEngineDBFacade::toEncodingPriority(
				parametersRoot.get(field, "").asString());
		}
		*/

		string configurationLabel;

		int64_t confKey = -1;
		string streamSourceType;
		bool defaultBroadcast = false;
		string encodersPoolLabel;
		string pullUrl;
		int maxWidth = -1;
		string userAgent;
		string otherInputOptions;
		string pushProtocol;
		int64_t pushEncoderKey = -1;
		string pushServerName;
		int pushServerPort = -1;
		string pushUri;
		int pushListenTimeout = -1;
		int captureVideoDeviceNumber = -1;
		string captureVideoInputFormat;
		int captureFrameRate = -1;
		int captureWidth = -1;
		int captureHeight = -1;
		int captureAudioDeviceNumber = -1;
		int captureChannelsNumber = -1;
		int64_t tvSourceTVConfKey = -1;

		long waitingSecondsBetweenAttemptsInCaseOfErrors;
		// long maxAttemptsNumberInCaseOfErrors;
		Json::Value outputsRoot;
		bool timePeriod;
		int64_t utcProxyPeriodStart = -1;
		int64_t utcProxyPeriodEnd = -1;
        {
			{
				string field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				configurationLabel = parametersRoot.get(field, "").asString();

				{
					bool warningIfMissing = false;
					tuple<int64_t, string, string, string, string, int64_t, string, int, string, int,
						int, string, int, int, int, int, int, int64_t>
						channelConfDetails = _mmsEngineDBFacade->getStreamDetails(
						workspace->_workspaceKey, configurationLabel, warningIfMissing);
					tie(confKey, streamSourceType,
						encodersPoolLabel,
						pullUrl,
						pushProtocol, pushEncoderKey, pushServerName, pushServerPort, pushUri,
						pushListenTimeout,
						captureVideoDeviceNumber,
						captureVideoInputFormat,
						captureFrameRate, captureWidth, captureHeight,
						captureAudioDeviceNumber, captureChannelsNumber,
						tvSourceTVConfKey) = channelConfDetails;

					// default is IP_PULL
					if (streamSourceType == "")
						streamSourceType = "IP_PULL";
				}
			}

			// EncodersPool override the one included in ChannelConf if present
            string field = "EncodersPool";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				encodersPoolLabel = parametersRoot.get(field, "").asString();

			field = "defaultBroadcast";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				defaultBroadcast = JSONUtils::asBool(parametersRoot, field, false);

			timePeriod = false;
            field = "TimePeriod";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				utcProxyPeriodStart = -1;
				utcProxyPeriodEnd = -1;
			}
			else
			{
				timePeriod = JSONUtils::asBool(parametersRoot, field, false);
				if (timePeriod)
				{
					field = "schedule";
					if (!JSONUtils::isMetadataPresent(parametersRoot, field))
					{
						string errorMessage = __FILEREF__
							+ "Field is not present or it is null"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", Field: " + field;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					// Validator validator(_logger, _mmsEngineDBFacade, _configuration);

					Json::Value proxyPeriodRoot = parametersRoot[field];

					field = "start";
					if (!JSONUtils::isMetadataPresent(proxyPeriodRoot, field))
					{
						string errorMessage = __FILEREF__
							+ "Field is not present or it is null"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", Field: " + field;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					string proxyPeriodStart = proxyPeriodRoot.get(field, "").asString();
					utcProxyPeriodStart = DateTime::sDateSecondsToUtc(proxyPeriodStart);

					field = "end";
					if (!JSONUtils::isMetadataPresent(proxyPeriodRoot, field))
					{
						string errorMessage = __FILEREF__
							+ "Field is not present or it is null"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", Field: " + field;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					string proxyPeriodEnd = proxyPeriodRoot.get(field, "").asString();
					utcProxyPeriodEnd = DateTime::sDateSecondsToUtc(proxyPeriodEnd);
				}
			}

			field = "MaxWidth";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				maxWidth = JSONUtils::asInt(parametersRoot, field, -1);

			field = "UserAgent";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				userAgent = parametersRoot.get(field, "").asString();

			field = "OtherInputOptions";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				otherInputOptions = parametersRoot.get(field, "").asString();

			// field = "MaxAttemptsNumberInCaseOfErrors";
			// if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			// 	maxAttemptsNumberInCaseOfErrors = 3;
			// else
			// 	maxAttemptsNumberInCaseOfErrors = JSONUtils::asInt(
			// 		parametersRoot, field, 0);

			field = "WaitingSecondsBetweenAttemptsInCaseOfErrors";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				waitingSecondsBetweenAttemptsInCaseOfErrors = 5;
			else
				waitingSecondsBetweenAttemptsInCaseOfErrors = JSONUtils::asInt64(
					parametersRoot, field, 0);

			field = "Outputs";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			outputsRoot = parametersRoot[field];
        }

		// string tvType;
		// int64_t tvServiceId = -1;
		// int64_t tvFrequency = -1;
		// int64_t tvSymbolRate = -1;
		// int64_t tvBandwidthInMhz = -1;
		// string tvModulation;
		// int tvVideoPid = -1;
		// int tvAudioItalianPid = -1;
		string liveURL;

		if (streamSourceType == "IP_PULL")
			liveURL = pullUrl;
		else if (streamSourceType == "IP_PUSH")
		{
			liveURL = pushProtocol + "://" + pushServerName
				+ ":" + to_string(pushServerPort) + pushUri;
		}
		else if (streamSourceType == "TV")
		{
			/*
			bool warningIfMissing = false;
			tuple<string, int64_t, int64_t, int64_t, int64_t, string, int, int>
				tvChannelConfDetails =
				_mmsEngineDBFacade->getSourceTVStreamDetails(
				tvSourceTVConfKey, warningIfMissing);

			int64_t tvBandwidthInHz;
			tie(tvType, tvServiceId, tvFrequency,
				tvSymbolRate, tvBandwidthInHz, tvModulation,
				tvVideoPid, tvAudioItalianPid) = tvChannelConfDetails;
			if (tvBandwidthInHz > 0)
				tvBandwidthInMhz = tvBandwidthInHz / 1000000;
			*/
		}

		Json::Value localOutputsRoot = getReviewedOutputsRoot(outputsRoot,
			workspace, ingestionJobKey, false);

		// 2021-12-22: in case of a Broadcaster, we may have a playlist (inputsRoot) already ready
		Json::Value inputsRoot;
		if (JSONUtils::isMetadataPresent(parametersRoot, "internalMMS")
			&& JSONUtils::isMetadataPresent(parametersRoot["internalMMS"], "broadcaster")
			&& JSONUtils::isMetadataPresent(parametersRoot["internalMMS"]["broadcaster"], "broadcasterInputsRoot")
		)
		{
			inputsRoot = parametersRoot["internalMMS"]["broadcaster"]["broadcasterInputsRoot"];
		}
		else
		{
			Json::Value streamInputRoot = _mmsEngineDBFacade->getStreamInputRoot(
				workspace->_workspaceKey, configurationLabel,
				maxWidth, userAgent, otherInputOptions);

			Json::Value inputRoot;
			{
				string field = "streamInput";
				inputRoot[field] = streamInputRoot;

				field = "timePeriod";
				inputRoot[field] = timePeriod;

				// field = "utcProxyPeriodStart";
				// inputRoot[field] = utcProxyPeriodStart;
				field = "utcScheduleStart";
				inputRoot[field] = utcProxyPeriodStart;

				// field = "utcProxyPeriodEnd";
				// inputRoot[field] = utcProxyPeriodEnd;
				field = "utcScheduleEnd";
				inputRoot[field] = utcProxyPeriodEnd;

				if (defaultBroadcast)
				{
					field = "defaultBroadcast";
					inputRoot[field] = defaultBroadcast;
				}
			}

			Json::Value localInputsRoot(Json::arrayValue);
			localInputsRoot.append(inputRoot);

			inputsRoot = localInputsRoot;
		}

		_mmsEngineDBFacade->addEncoding_LiveProxyJob(workspace, ingestionJobKey,
			inputsRoot,	// used by FFMPEGEncoder
			streamSourceType,	// used by FFMPEGEncoder
			utcProxyPeriodStart,	// used in MMSEngineDBFacade::getEncodingJobs
			// maxAttemptsNumberInCaseOfErrors,	// used in EncoderVideoAudioProxy.cpp
			waitingSecondsBetweenAttemptsInCaseOfErrors,	// used in EncoderVideoAudioProxy.cpp
			localOutputsRoot		// used by FFMPEGEncoder
		);
	}
    catch(ConfKeyNotFound e)
    {
        _logger->error(__FILEREF__ + "manageLiveProxy failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw runtime_error(e.what());
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageLiveProxy failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageLiveProxy failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageVODProxy(
	int64_t ingestionJobKey,
	MMSEngineDBFacade::IngestionStatus ingestionStatus,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
		dependencies
)
{
    try
    {
		_logger->info(__FILEREF__ + "manageVODProxy"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		);

        if (dependencies.size() < 1)
        {
            string errorMessage = __FILEREF__ + "Wrong source number to be proxied"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		Json::Value outputsRoot;
		bool timePeriod = false;
		int64_t utcProxyPeriodStart = -1;
		int64_t utcProxyPeriodEnd = -1;
		bool defaultBroadcast = false;
        {
            string field = "TimePeriod";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				timePeriod = JSONUtils::asBool(parametersRoot, field, false);
				if (timePeriod)
				{
					field = "schedule";
					if (!JSONUtils::isMetadataPresent(parametersRoot, field))
					{
						string errorMessage = __FILEREF__ + "Field is not present or it is null"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", Field: " + field;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					// Validator validator(_logger, _mmsEngineDBFacade, _configuration);

					Json::Value proxyPeriodRoot = parametersRoot[field];

					field = "start";
					if (!JSONUtils::isMetadataPresent(proxyPeriodRoot, field))
					{
						string errorMessage = __FILEREF__ + "Field is not present or it is null"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", Field: " + field;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					string proxyPeriodStart = proxyPeriodRoot.get(field, "").asString();
					utcProxyPeriodStart = DateTime::sDateSecondsToUtc(proxyPeriodStart);

					field = "end";
					if (!JSONUtils::isMetadataPresent(proxyPeriodRoot, field))
					{
						string errorMessage = __FILEREF__ + "Field is not present or it is null"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", Field: " + field;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					string proxyPeriodEnd = proxyPeriodRoot.get(field, "").asString();
					utcProxyPeriodEnd = DateTime::sDateSecondsToUtc(proxyPeriodEnd);
				}
			}

			field = "defaultBroadcast";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				defaultBroadcast = JSONUtils::asBool(parametersRoot, field, false);

			field = "Outputs";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			outputsRoot = parametersRoot[field];
        }

		MMSEngineDBFacade::ContentType vodContentType;

		Json::Value inputsRoot(Json::arrayValue);
		// 2021-12-22: in case of a Broadcaster, we may have a playlist (inputsRoot)
		//		already ready
		if (JSONUtils::isMetadataPresent(parametersRoot, "internalMMS")
			&& JSONUtils::isMetadataPresent(parametersRoot["internalMMS"], "broadcaster")
			&& JSONUtils::isMetadataPresent(parametersRoot["internalMMS"]["broadcaster"], "broadcasterInputsRoot")
		)
		{
			inputsRoot = parametersRoot["internalMMS"]["broadcaster"]["broadcasterInputsRoot"];
		}
		else
		{
			vector<tuple<int64_t, string, string>> sources;

			for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
			{
				string sourcePhysicalPathName;
				int64_t sourcePhysicalPathKey;

				int64_t key;
				// MMSEngineDBFacade::ContentType referenceContentType;
				Validator::DependencyType dependencyType;
				bool stopIfReferenceProcessingError;

				tie(key, vodContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				_logger->info(__FILEREF__ + "manageVODProxy"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", key: " + to_string(key)
				);

				int64_t sourceMediaItemKey;
				if (dependencyType == Validator::DependencyType::MediaItemKey)
				{
					int64_t encodingProfileKey = -1;
					bool warningIfMissing = false;
					tuple<int64_t, string, int, string, string, int64_t, string>
						physicalPathDetails = _mmsStorage->getPhysicalPathDetails(key,
						encodingProfileKey, warningIfMissing);
					tie(sourcePhysicalPathKey, sourcePhysicalPathName, ignore, ignore, ignore,
						ignore, ignore) = physicalPathDetails;

					sourceMediaItemKey = key;
				}
				else
				{
					tuple<string, int, string, string, int64_t, string>
						physicalPathDetails = _mmsStorage->getPhysicalPathDetails(key);
					tie(sourcePhysicalPathName, ignore, ignore, ignore, ignore, ignore)
						= physicalPathDetails;

					sourcePhysicalPathKey = key;

					bool warningIfMissing = false;
					tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t,
						string, string> mediaItemKeyDetails =
						_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
							workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

					tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore,
						ignore, ignore) = mediaItemKeyDetails;
				}

				// int64_t durationInMilliSeconds =
				// 	_mmsEngineDBFacade->getMediaDurationInMilliseconds(
				// 		-1, sourcePhysicalPathKey);

				// calculate delivery URL in case of an external encoder
				string sourcePhysicalDeliveryURL;
				{
					int64_t utcNow;
					{
						chrono::system_clock::time_point now = chrono::system_clock::now();
						utcNow = chrono::system_clock::to_time_t(now);
					}

					pair<string, string> deliveryAuthorizationDetails =
						_mmsDeliveryAuthorization->createDeliveryAuthorization(
						-1,	// userKey,
						workspace,
						"",	// clientIPAddress,

						-1,	// mediaItemKey,
						"",	// uniqueName,
						-1,	// encodingProfileKey,
						"",	// encodingProfileLabel,

						sourcePhysicalPathKey,

						-1,	// ingestionJobKey,	(in case of live)
						-1,	// deliveryCode,

						365 * 24 * 60 * 60,	// ttlInSeconds, 365 days!!!
						999999,	// maxRetries,
						false,	// save,
						"MMS_SignedToken",	// deliveryType,

						false,	// warningIfMissingMediaItemKey,
						true,	// filteredByStatistic
						""		// userId (it is not needed it filteredByStatistic is true
					);

					tie(sourcePhysicalDeliveryURL, ignore) = deliveryAuthorizationDetails;
				}

				sources.push_back(make_tuple(sourcePhysicalPathKey, sourcePhysicalPathName,
					sourcePhysicalDeliveryURL));
			}

			// same json structure is used in API_Ingestion::changeLiveProxyPlaylist
			Json::Value vodInputRoot = _mmsEngineDBFacade->getVodInputRoot(
				vodContentType, sources);

			Json::Value inputRoot;
			{
				string field = "vodInput";
				inputRoot[field] = vodInputRoot;

				field = "timePeriod";
				inputRoot[field] = timePeriod;

				field = "utcScheduleStart";
				inputRoot[field] = utcProxyPeriodStart;

				field = "utcScheduleEnd";
				inputRoot[field] = utcProxyPeriodEnd;

				if (defaultBroadcast)
				{
					field = "defaultBroadcast";
					inputRoot[field] = defaultBroadcast;
				}
			}

			inputsRoot.append(inputRoot);
		}

		Json::Value localOutputsRoot = getReviewedOutputsRoot(outputsRoot,
			workspace, ingestionJobKey,
			vodContentType == MMSEngineDBFacade::ContentType::Image ? true : false
		);

		// the only reason we may have a failure should be in case the vod is missing/removed
		long waitingSecondsBetweenAttemptsInCaseOfErrors = 30;
		long maxAttemptsNumberInCaseOfErrors = 3;

		_mmsEngineDBFacade->addEncoding_VODProxyJob(workspace, ingestionJobKey,
			inputsRoot,

			utcProxyPeriodStart,
			localOutputsRoot,
			maxAttemptsNumberInCaseOfErrors, waitingSecondsBetweenAttemptsInCaseOfErrors);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageVODProxy failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageVODProxy failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageCountdown( int64_t ingestionJobKey,
	MMSEngineDBFacade::IngestionStatus ingestionStatus,
	string ingestionDate,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
		dependencies
)
{
    try
    {
        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong media number for Countdown"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		bool defaultBroadcast = false;
		bool timePeriod = true;
		int64_t utcProxyPeriodStart = -1;
		int64_t utcProxyPeriodEnd = -1;
        {
			string field = "defaultBroadcast";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				defaultBroadcast = JSONUtils::asBool(parametersRoot, field, false);

			field = "schedule";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			// Validator validator(_logger, _mmsEngineDBFacade, _configuration);

			Json::Value proxyPeriodRoot = parametersRoot[field];

			field = "start";
			if (!JSONUtils::isMetadataPresent(proxyPeriodRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			string proxyPeriodStart = proxyPeriodRoot.get(field, "").asString();
			utcProxyPeriodStart = DateTime::sDateSecondsToUtc(proxyPeriodStart);

			field = "end";
			if (!JSONUtils::isMetadataPresent(proxyPeriodRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			string proxyPeriodEnd = proxyPeriodRoot.get(field, "").asString();
			utcProxyPeriodEnd = DateTime::sDateSecondsToUtc(proxyPeriodEnd);
		}

		string mmsSourceVideoAssetPathName;
		string mmsSourceVideoAssetDeliveryURL;
		MMSEngineDBFacade::ContentType referenceContentType;
		int64_t sourceMediaItemKey;
		int64_t sourcePhysicalPathKey;
		{
            int64_t key;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType	= dependencies[0];
            tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType == Validator::DependencyType::MediaItemKey)
			{
                int64_t encodingProfileKey = -1;
                
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string> physicalPath =
					_mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
				tie(sourcePhysicalPathKey, mmsSourceVideoAssetPathName, ignore, ignore,
					ignore, ignore, ignore) = physicalPath;

				sourceMediaItemKey = key;

				// sourcePhysicalPathKey = -1;
			}
			else
			{
				tuple<string, int, string, string, int64_t, string> physicalPath =
					_mmsStorage->getPhysicalPathDetails(key);
				tie(mmsSourceVideoAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPath;

				sourcePhysicalPathKey = key;

				bool warningIfMissing = false;
				tuple<int64_t,MMSEngineDBFacade::ContentType,string,string, string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
					workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

				MMSEngineDBFacade::ContentType localContentType;
				string localTitle;
				string userData;
                string ingestionDate;
				int64_t localIngestionJobKey;
				tie(sourceMediaItemKey,localContentType, localTitle, userData, ingestionDate,
						localIngestionJobKey, ignore, ignore)
                    = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
			}

			// calculate delivery URL in case of an external encoder
			{
				int64_t utcNow;
				{
					chrono::system_clock::time_point now = chrono::system_clock::now();
					utcNow = chrono::system_clock::to_time_t(now);
				}

				pair<string, string> deliveryAuthorizationDetails =
					_mmsDeliveryAuthorization->createDeliveryAuthorization(
					-1,	// userKey,
					workspace,
					"",	// clientIPAddress,

					-1,	// mediaItemKey,
					"",	// uniqueName,
					-1,	// encodingProfileKey,
					"",	// encodingProfileLabel,

					sourcePhysicalPathKey,

					-1,	// ingestionJobKey,	(in case of live)
					-1,	// deliveryCode,

					abs(utcNow - utcProxyPeriodEnd),	// ttlInSeconds,
					999999,	// maxRetries,
					false,	// save,
					"MMS_SignedToken",	// deliveryType,

					false,	// warningIfMissingMediaItemKey,
					true,	// filteredByStatistic
					""		// userId (it is not needed it filteredByStatistic is true
				);

				tie(mmsSourceVideoAssetDeliveryURL, ignore) = deliveryAuthorizationDetails;
			}
		}

		int64_t videoDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
			sourceMediaItemKey, sourcePhysicalPathKey);

		Json::Value outputsRoot;
		{
			string field = "Outputs";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			outputsRoot = parametersRoot[field];
        }

		Json::Value localOutputsRoot = getReviewedOutputsRoot(outputsRoot,
			workspace, ingestionJobKey,
			referenceContentType == MMSEngineDBFacade::ContentType::Image ? true : false
		);

		// 2021-12-22: in case of a Broadcaster, we may have a playlist (inputsRoot) already ready
		Json::Value inputsRoot;
		if (JSONUtils::isMetadataPresent(parametersRoot, "internalMMS")
			&& JSONUtils::isMetadataPresent(parametersRoot["internalMMS"], "broadcaster")
			&& JSONUtils::isMetadataPresent(parametersRoot["internalMMS"]["broadcaster"], "broadcasterInputsRoot")
		)
		{
			inputsRoot = parametersRoot["internalMMS"]["broadcaster"]["broadcasterInputsRoot"];
		}
		else
		{
			Json::Value broadcastDrawTextDetailsRoot = Json::nullValue;

			string field = "broadcastDrawTextDetails";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				broadcastDrawTextDetailsRoot = parametersRoot[field];

			// same json structure is used in API_Ingestion::changeLiveProxyPlaylist
			Json::Value countdownInputRoot = _mmsEngineDBFacade->getCountdownInputRoot(
				mmsSourceVideoAssetPathName, mmsSourceVideoAssetDeliveryURL,
				sourcePhysicalPathKey, videoDurationInMilliSeconds,
				broadcastDrawTextDetailsRoot
				// text, textPosition_X_InPixel, textPosition_Y_InPixel, fontType, fontSize,
				// fontColor, textPercentageOpacity, boxEnable, boxColor, boxPercentageOpacity
			);

			Json::Value inputRoot;
			{
				string field = "countdownInput";
				inputRoot[field] = countdownInputRoot;

				field = "timePeriod";
				inputRoot[field] = timePeriod;

				// field = "utcProxyPeriodStart";
				// inputRoot[field] = utcProxyPeriodStart;
				field = "utcScheduleStart";
				inputRoot[field] = utcProxyPeriodStart;

				// field = "utcProxyPeriodEnd";
				// inputRoot[field] = utcProxyPeriodEnd;
				field = "utcScheduleEnd";
				inputRoot[field] = utcProxyPeriodEnd;

				if (defaultBroadcast)
				{
					field = "defaultBroadcast";
					inputRoot[field] = defaultBroadcast;
				}
			}

			Json::Value localInputsRoot(Json::arrayValue);
			localInputsRoot.append(inputRoot);

			inputsRoot = localInputsRoot;
		}

		// the only reason we may have a failure should be in case the image is missing/removed
		long waitingSecondsBetweenAttemptsInCaseOfErrors = 30;
		long maxAttemptsNumberInCaseOfErrors = 3;

		_mmsEngineDBFacade->addEncoding_CountdownJob(workspace, ingestionJobKey,
			inputsRoot,
			utcProxyPeriodStart,
			localOutputsRoot,
			maxAttemptsNumberInCaseOfErrors, waitingSecondsBetweenAttemptsInCaseOfErrors);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageCountdown failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageCountdown failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

Json::Value MMSEngineProcessor::getReviewedOutputsRoot(
	Json::Value outputsRoot,
	shared_ptr<Workspace> workspace,
	int64_t ingestionJobKey,
	bool encodingProfileMandatory)
{
	Json::Value localOutputsRoot(Json::arrayValue);

	if (outputsRoot == Json::nullValue)
		return localOutputsRoot;

	for (int outputIndex = 0; outputIndex < outputsRoot.size(); outputIndex++)
	{
		Json::Value outputRoot = outputsRoot[outputIndex];


		string outputType;
		string otherOutputOptions;
		int videoTrackIndexToBeUsed = -1;
		int audioTrackIndexToBeUsed = -1;
		Json::Value filtersRoot = Json::nullValue;
		int64_t deliveryCode;
		int segmentDurationInSeconds = 0;
		int playlistEntriesNumber = 0;
		int64_t encodingProfileKey = -1;
		Json::Value encodingProfileDetailsRoot = Json::nullValue;
		MMSEngineDBFacade::ContentType encodingProfileContentType =
			MMSEngineDBFacade::ContentType::Video;
		string manifestDirectoryPath;
		string manifestFileName;
		string rtmpUrl;
		string rtmpStreamName;
		string rtmpUserName;
		string rtmpPassword;
		string playUrl;
		string awsChannelConfigurationLabel;
		bool awsSignedURL = false;
		int awsExpirationInMinutes = 1440;	// 1 day
		string udpUrl;
		Json::Value drawTextDetailsRoot = Json::nullValue;


		string field = "OutputType";
		if (!JSONUtils::isMetadataPresent(outputRoot, field))
			outputType = "HLS";
		else
			outputType = outputRoot.get(field, "HLS").asString();

		field = "OtherOutputOptions";
		if (JSONUtils::isMetadataPresent(outputRoot, field))
			otherOutputOptions = outputRoot.get(field, "").asString();

		field = "videoTrackIndexToBeUsed";
		if (JSONUtils::isMetadataPresent(outputRoot, field))
			videoTrackIndexToBeUsed = outputRoot.get(field, -1).asInt();

		field = "audioTrackIndexToBeUsed";
		if (JSONUtils::isMetadataPresent(outputRoot, field))
			audioTrackIndexToBeUsed = outputRoot.get(field, -1).asInt();

		field = "filters";
		if (JSONUtils::isMetadataPresent(outputRoot, field))
			filtersRoot = outputRoot[field];

		if (outputType == "HLS" || outputType == "DASH")
		{
			field = "DeliveryCode";
			if (!JSONUtils::isMetadataPresent(outputRoot, field))
			{
				string errorMessage =
					__FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			else
				deliveryCode = outputRoot.get(field, 0).asInt64();

			field = "SegmentDurationInSeconds";
			if (!JSONUtils::isMetadataPresent(outputRoot, field))
				segmentDurationInSeconds = 10;
			else
				segmentDurationInSeconds = JSONUtils::asInt(outputRoot, field, 0);

			field = "PlaylistEntriesNumber";
			if (!JSONUtils::isMetadataPresent(outputRoot, field))
				playlistEntriesNumber = 6;
			else
				playlistEntriesNumber = JSONUtils::asInt(outputRoot, field, 0);

			string manifestExtension;
			if (outputType == "HLS")
				manifestExtension = "m3u8";
			else if (outputType == "DASH")
				manifestExtension = "mpd";

			{
				manifestDirectoryPath = _mmsStorage->getLiveDeliveryAssetPath(
					to_string(deliveryCode),
					workspace);

				manifestFileName = to_string(deliveryCode) + ".m3u8";
			}
		}
		else if (outputType == "RTMP_Stream")
		{
			field = "RtmpUrl";
			rtmpUrl = outputRoot.get(field, "").asString();

			field = "rtmpStreamName";
			rtmpStreamName = outputRoot.get(field, "").asString();

			field = "rtmpUserName";
			rtmpUserName = outputRoot.get(field, "").asString();

			field = "rtmpPassword";
			rtmpPassword = outputRoot.get(field, "").asString();

			field = "PlayUrl";
			playUrl = outputRoot.get(field, "").asString();
		}
		else if (outputType == "AWS_CHANNEL")
		{
			field = "awsChannelConfigurationLabel";
			awsChannelConfigurationLabel = outputRoot.get(field, "").asString();

			field = "awsSignedURL";
			awsSignedURL = JSONUtils::asBool(outputRoot, field, false);

			field = "awsExpirationInMinutes";
			awsExpirationInMinutes = JSONUtils::asInt(outputRoot, field, 1440);
		}
		else // if (outputType == "UDP_Stream")
		{
			field = "udpUrl";
			udpUrl = outputRoot.get(field, "").asString();
		}

		string keyField = "EncodingProfileKey";
		string labelField = "EncodingProfileLabel";
		string contentTypeField = "ContentType";
		if (JSONUtils::isMetadataPresent(outputRoot, keyField))
		{
			encodingProfileKey = JSONUtils::asInt64(outputRoot, keyField, 0);

			_logger->info(__FILEREF__ + "outputRoot encodingProfileKey"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", encodingProfileKey: " + to_string(encodingProfileKey)
			);
		}
		else if (JSONUtils::isMetadataPresent(outputRoot, labelField))
		{
			string encodingProfileLabel = outputRoot.get(labelField, "").asString();
			if (encodingProfileLabel != "")
			{
				MMSEngineDBFacade::ContentType contentType;
				if (JSONUtils::isMetadataPresent(outputRoot, contentTypeField))
				{
					contentType = MMSEngineDBFacade::toContentType(
						outputRoot.get(contentTypeField, "").asString());

					encodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
						workspace->_workspaceKey, contentType, encodingProfileLabel);
				}
				else
				{
					bool contentTypeToBeUsed = false;
					encodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
						workspace->_workspaceKey, contentType, encodingProfileLabel,
						contentTypeToBeUsed);
				}

				_logger->info(__FILEREF__ + "outputRoot encodingProfileLabel"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", encodingProfileLabel: " + encodingProfileLabel
					+ ", encodingProfileKey: " + to_string(encodingProfileKey)
				);
			}
		}

		if (encodingProfileKey != -1)
		{
			string jsonEncodingProfile;

			tuple<string, MMSEngineDBFacade::ContentType,
				MMSEngineDBFacade::DeliveryTechnology, string>
				encodingProfileDetails = _mmsEngineDBFacade->getEncodingProfileDetailsByKey(
				workspace->_workspaceKey, encodingProfileKey);
			tie(ignore, encodingProfileContentType, ignore, jsonEncodingProfile)
				= encodingProfileDetails;

			{
				Json::CharReaderBuilder builder;
				Json::CharReader* reader = builder.newCharReader();
				string errors;

				bool parsingSuccessful = reader->parse(jsonEncodingProfile.c_str(),
					jsonEncodingProfile.c_str() + jsonEncodingProfile.size(), 
					&encodingProfileDetailsRoot,
					&errors);
				delete reader;

				if (!parsingSuccessful)
				{
					string errorMessage = __FILEREF__ + "failed to parse 'parameters'"
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", errors: " + errors
					;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
			}
		}
		else
		{
			if (encodingProfileMandatory)
			{
				string errorMessage = __FILEREF__
					+ "EncodingProfile is mandatory in case of Image"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
		}

		field = "drawTextDetails";
		if (JSONUtils::isMetadataPresent(outputRoot, field))
			drawTextDetailsRoot = outputRoot[field];

		Json::Value localOutputRoot;

		field = "outputType";
		localOutputRoot[field] = outputType;

		field = "otherOutputOptions";
		localOutputRoot[field] = otherOutputOptions;

		field = "videoTrackIndexToBeUsed";
		localOutputRoot[field] = videoTrackIndexToBeUsed;

		field = "audioTrackIndexToBeUsed";
		localOutputRoot[field] = audioTrackIndexToBeUsed;

		field = "filters";
		localOutputRoot[field] = filtersRoot;

		field = "segmentDurationInSeconds";
		localOutputRoot[field] = segmentDurationInSeconds;

		field = "playlistEntriesNumber";
		localOutputRoot[field] = playlistEntriesNumber;

		{
			field = "encodingProfileKey";
			localOutputRoot[field] = encodingProfileKey;

			field = "encodingProfileDetails";
			localOutputRoot[field] = encodingProfileDetailsRoot;

			field = "encodingProfileContentType";
			outputRoot[field] = MMSEngineDBFacade::toString(encodingProfileContentType);
		}

		field = "manifestDirectoryPath";
		localOutputRoot[field] = manifestDirectoryPath;

		field = "manifestFileName";
		localOutputRoot[field] = manifestFileName;

		field = "rtmpUrl";
		localOutputRoot[field] = rtmpUrl;

		field = "rtmpStreamName";
		localOutputRoot[field] = rtmpStreamName;

		field = "rtmpUserName";
		localOutputRoot[field] = rtmpUserName;

		field = "rtmpPassword";
		localOutputRoot[field] = rtmpPassword;

		field = "playUrl";
		localOutputRoot[field] = playUrl;

		field = "awsChannelConfigurationLabel";
		localOutputRoot[field] = awsChannelConfigurationLabel;

		field = "awsSignedURL";
		localOutputRoot[field] = awsSignedURL;

		field = "awsExpirationInMinutes";
		localOutputRoot[field] = awsExpirationInMinutes;

		field = "udpUrl";
		localOutputRoot[field] = udpUrl;

		if (drawTextDetailsRoot != Json::nullValue)
		{
			field = "drawTextDetails";
			localOutputRoot[field] = drawTextDetailsRoot;
		}

		localOutputsRoot.append(localOutputRoot);
	}

	return localOutputsRoot;
}

void MMSEngineProcessor::manageLiveGrid(
	int64_t ingestionJobKey,
	MMSEngineDBFacade::IngestionStatus ingestionStatus,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot
)
{
    try
    {
		/*
		 * commented because it will be High by default
		MMSEngineDBFacade::EncodingPriority encodingPriority;
		string field = "EncodingPriority";
		if (!JSONUtils::isMetadataPresent(parametersRoot, field))
		{
			encodingPriority = 
				static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
		}
		else
		{
			encodingPriority =
				MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
		}
		*/

		vector<tuple<int64_t, string, string>> inputChannels;
		int64_t encodingProfileKey = -1;
		string outputType;
		// string userAgent;
		int segmentDurationInSeconds = 0;
		int playlistEntriesNumber = 0;
		int64_t deliveryCode = -1;
		long waitingSecondsBetweenAttemptsInCaseOfErrors;
		long maxAttemptsNumberInCaseOfErrors;
		string srtURL;
        {
            string field = "InputConfigurationLabels";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
			Json::Value inputChannelsRoot = parametersRoot[field];
			for (int inputChannelIndex = 0; inputChannelIndex < inputChannelsRoot.size(); inputChannelIndex++)
			{
				string inputConfigurationLabel = inputChannelsRoot[inputChannelIndex].asString();

				bool warningIfMissing = false;
				tuple<int64_t, string, string, string, string, int64_t, string, int, string, int,
					int, string, int, int, int, int, int, int64_t>
					confKeyAndChannelURL = _mmsEngineDBFacade->getStreamDetails(
					workspace->_workspaceKey, inputConfigurationLabel, warningIfMissing);

				int64_t inputConfKey;
				string streamSourceType;
				string inputChannelURL;
				tie(inputConfKey, streamSourceType, ignore, inputChannelURL,
					ignore, ignore, ignore, ignore, ignore, ignore,
					ignore, ignore, ignore, ignore, ignore, ignore,
					ignore, ignore) = confKeyAndChannelURL;

				// bisognerebbe verificare streamSourceType

				inputChannels.push_back(make_tuple(inputConfKey,
					inputConfigurationLabel, inputChannelURL));
			}

			string keyField = "EncodingProfileKey";
			string labelField = "EncodingProfileLabel";
			if (JSONUtils::isMetadataPresent(parametersRoot, keyField))
			{
				encodingProfileKey = JSONUtils::asInt64(parametersRoot, keyField, 0);
			}
			else if (JSONUtils::isMetadataPresent(parametersRoot, labelField))
			{
				string encodingProfileLabel = parametersRoot.get(labelField, "XXX").asString();

				encodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
					workspace->_workspaceKey, MMSEngineDBFacade::ContentType::Video, encodingProfileLabel);
			}
			else
			{
				string errorMessage = __FILEREF__ + "Both fields are not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", Field: " + keyField
                    + ", Field: " + labelField
                    ;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

            field = "OutputType";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				outputType = "HLS";
			else
            	outputType = parametersRoot.get(field, "").asString();

			if (outputType == "HLS") // || outputType == "DASH")
			{
				field = "DeliveryCode";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				deliveryCode = JSONUtils::asInt64(parametersRoot, field, 0);

				field = "SegmentDurationInSeconds";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
					segmentDurationInSeconds = 10;
				else
					segmentDurationInSeconds = JSONUtils::asInt(parametersRoot, field, 0);

				field = "PlaylistEntriesNumber";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
					playlistEntriesNumber = 6;
				else
					playlistEntriesNumber = JSONUtils::asInt(parametersRoot, field, 0);
			}
			else if (outputType == "SRT")
			{
				field = "SRT_URL";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}

				srtURL = parametersRoot.get(field, "XXX").asString();
			}

			field = "MaxAttemptsNumberInCaseOfErrors";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				maxAttemptsNumberInCaseOfErrors = 3;
			else
				maxAttemptsNumberInCaseOfErrors = JSONUtils::asInt(parametersRoot, field, 0);

			field = "WaitingSecondsBetweenAttemptsInCaseOfErrors";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				waitingSecondsBetweenAttemptsInCaseOfErrors = 5;
			else
				waitingSecondsBetweenAttemptsInCaseOfErrors = JSONUtils::asInt64(
					parametersRoot, field, 0);
        }

		string monitorManifestDirectoryPath = _mmsStorage->getLiveDeliveryAssetPath(
			to_string(deliveryCode),
			workspace);
		string monitorManifestFileName = to_string(deliveryCode) + ".m3u8";

		_mmsEngineDBFacade->addEncoding_LiveGridJob(workspace, ingestionJobKey,
			inputChannels, encodingProfileKey, outputType,
			monitorManifestDirectoryPath, monitorManifestFileName,
			segmentDurationInSeconds, playlistEntriesNumber, srtURL,
			maxAttemptsNumberInCaseOfErrors, waitingSecondsBetweenAttemptsInCaseOfErrors);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageLiveGrid failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        // Update IngestionJob done in the calling method
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageLiveGrid failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::liveCutThread_streamSegmenter(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value liveCutParametersRoot
)
{
    try
    {
		_logger->info(__FILEREF__ + "liveCutThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

		// string streamSourceType;
		// string ipConfigurationLabel;
		// string satConfigurationLabel;
		int64_t deliveryCode;
        string cutPeriodStartTimeInMilliSeconds;
        string cutPeriodEndTimeInMilliSeconds;
		int maxWaitingForLastChunkInSeconds = 90;
		bool errorIfAChunkIsMissing = false;
        {
			/*
            string field = "streamSourceType";
            if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
			streamSourceType = liveCutParametersRoot.get(field, "").asString();

			if (streamSourceType == "IP_PULL")
			{
				field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				ipConfigurationLabel = liveCutParametersRoot.get(field, "").asString();
			}
			else if (streamSourceType == "Satellite")
			{
				field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				satConfigurationLabel = liveCutParametersRoot.get(field, "").asString();
			}
			*/

			// else if (streamSourceType == "IP_PUSH")
			string field = "DeliveryCode";
			if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			deliveryCode = JSONUtils::asInt64(liveCutParametersRoot, field, -1);

			field = "MaxWaitingForLastChunkInSeconds";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				maxWaitingForLastChunkInSeconds = JSONUtils::asInt64(liveCutParametersRoot, field, 90);

			field = "ErrorIfAChunkIsMissing";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				errorIfAChunkIsMissing = JSONUtils::asBool(liveCutParametersRoot, field, false);

            field = "CutPeriod";
			Json::Value cutPeriodRoot = liveCutParametersRoot[field];

            field = "Start";
            if (!JSONUtils::isMetadataPresent(cutPeriodRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            cutPeriodStartTimeInMilliSeconds = cutPeriodRoot.get(field, "").asString();

            field = "End";
            if (!JSONUtils::isMetadataPresent(cutPeriodRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            cutPeriodEndTimeInMilliSeconds = cutPeriodRoot.get(field, "").asString();
        }

		// Validator validator(_logger, _mmsEngineDBFacade, _configuration);

		int64_t utcCutPeriodStartTimeInMilliSeconds = DateTime::sDateMilliSecondsToUtc(cutPeriodStartTimeInMilliSeconds);

		// next code is the same in the Validator class
		int64_t utcCutPeriodEndTimeInMilliSeconds = DateTime::sDateMilliSecondsToUtc(cutPeriodEndTimeInMilliSeconds);

		/*
		 * 2020-03-30: scenario: period end time is 300 seconds (5 minutes). In case the chunk is 1 minute,
		 * we will take 5 chunks.
		 * The result is that the Cut will fail because:
		 * - we need to cut to 300 seconds
		 * - the duration of the video is 298874 milliseconds
		 * For this reason, when we retrieve the chunks, we will use 'period end time' plus one second
		 */
		int64_t utcCutPeriodEndTimeInMilliSecondsPlusOneSecond = utcCutPeriodEndTimeInMilliSeconds + 1000;

		/*
		int64_t confKey = -1;
		if (streamSourceType == "IP_PULL")
		{
			bool warningIfMissing = false;
			pair<int64_t, string> confKeyAndLiveURL = _mmsEngineDBFacade->getIPChannelConfDetails(
				workspace->_workspaceKey, ipConfigurationLabel, warningIfMissing);
			tie(confKey, ignore) = confKeyAndLiveURL;
		}
		else if (streamSourceType == "Satellite")
		{
			bool warningIfMissing = false;
			confKey = _mmsEngineDBFacade->getSATChannelConfDetails(
				workspace->_workspaceKey, satConfigurationLabel, warningIfMissing);
		}
		*/

		Json::Value mediaItemKeyReferencesRoot(Json::arrayValue);
		int64_t utcFirstChunkStartTime;
		string firstChunkStartTime;
		int64_t utcLastChunkEndTime;
		string lastChunkEndTime;

		chrono::system_clock::time_point startLookingForChunks = chrono::system_clock::now();

		bool firstRequestedChunk = false;
		bool lastRequestedChunk = false;
		while (!lastRequestedChunk
			&& (chrono::duration_cast<chrono::seconds>(chrono::system_clock::now()
				- startLookingForChunks).count() < maxWaitingForLastChunkInSeconds)
		)
		{
			int64_t mediaItemKey = -1;
			int64_t physicalPathKey = -1;
			string uniqueName;
			vector<int64_t> otherMediaItemsKey;
			int start = 0;
			int rows = 60 * 1;	// assuming every MediaItem is one minute, let's take 1 hour
			bool contentTypePresent = true;
			MMSEngineDBFacade::ContentType contentType = MMSEngineDBFacade::ContentType::Video;
			// bool startAndEndIngestionDatePresent = false;
			string startIngestionDate;
			string endIngestionDate;
			string title;
			int liveRecordingChunk = 1;
			vector<string> tagsIn;
			vector<string> tagsNotIn;
			string orderBy = "";
			bool admin = false;

			firstRequestedChunk = false;
			lastRequestedChunk = false;

			string jsonCondition;
			{
				// SC: Start Chunk
				// PS: Playout Start, PE: Playout End
				// --------------SC--------------SC--------------SC--------------SC
				//                       PS-------------------------------PE

				jsonCondition = "(";

				// first chunk of the cut
				jsonCondition += (
					"(JSON_EXTRACT(userData, '$.mmsData.utcChunkStartTime') * 1000 <= "
						+ to_string(utcCutPeriodStartTimeInMilliSeconds) + " "
					+ "and " + to_string(utcCutPeriodStartTimeInMilliSeconds)
						+ " < JSON_EXTRACT(userData, '$.mmsData.utcChunkEndTime') * 1000 ) "
				);

				jsonCondition += " or ";

				// internal chunk of the cut
				jsonCondition += (
					"( " + to_string(utcCutPeriodStartTimeInMilliSeconds) + " <= JSON_EXTRACT(userData, '$.mmsData.utcChunkStartTime') * 1000 "
					+ "and JSON_EXTRACT(userData, '$.mmsData.utcChunkEndTime') * 1000 <= " + to_string(utcCutPeriodEndTimeInMilliSecondsPlusOneSecond) + ") "
				);

				jsonCondition += " or ";

				// last chunk of the cut
				jsonCondition += (
					"( JSON_EXTRACT(userData, '$.mmsData.utcChunkStartTime') * 1000 < " + to_string(utcCutPeriodEndTimeInMilliSecondsPlusOneSecond) + " "
						+ "and " + to_string(utcCutPeriodEndTimeInMilliSecondsPlusOneSecond) + " <= JSON_EXTRACT(userData, '$.mmsData.utcChunkEndTime') * 1000 ) "
					);

				jsonCondition += ")";
			}
			string jsonOrderBy = "JSON_EXTRACT(userData, '$.mmsData.utcChunkStartTime') asc";

			long utcPreviousUtcChunkEndTime = -1;
			bool firstRetrievedChunk = true;

			// retrieve the reference of all the MediaItems to be concatenate
			mediaItemKeyReferencesRoot.clear();

			// Json::Value mediaItemsListRoot;
			Json::Value mediaItemsRoot;
			do
			{
				int64_t utcCutPeriodStartTimeInMilliSeconds = -1;
				int64_t utcCutPeriodEndTimeInMilliSecondsPlusOneSecond = -1;
				Json::Value responseFields = Json::nullValue;
				Json::Value mediaItemsListRoot = _mmsEngineDBFacade->getMediaItemsList(
					workspace->_workspaceKey, mediaItemKey, uniqueName, physicalPathKey, otherMediaItemsKey,
					start, rows,
					contentTypePresent, contentType,
					// startAndEndIngestionDatePresent,
					startIngestionDate, endIngestionDate,
					title, liveRecordingChunk,
					deliveryCode,
					utcCutPeriodStartTimeInMilliSeconds, utcCutPeriodEndTimeInMilliSecondsPlusOneSecond,
					jsonCondition,
					tagsIn, tagsNotIn, orderBy, jsonOrderBy,
					responseFields, admin);

				string field = "response";
				Json::Value responseRoot = mediaItemsListRoot[field];

				field = "mediaItems";
				mediaItemsRoot = responseRoot[field];

				for (int mediaItemIndex = 0; mediaItemIndex < mediaItemsRoot.size(); mediaItemIndex++)
				{
					Json::Value mediaItemRoot = mediaItemsRoot[mediaItemIndex];

					field = "mediaItemKey";
					int64_t mediaItemKey = JSONUtils::asInt64(mediaItemRoot, field, 0);

					Json::Value userDataRoot;
					{
						field = "userData";
						string userData = mediaItemRoot.get(field, "").asString();
						if (userData == "")
						{
							string errorMessage = __FILEREF__ + "recording media item without userData!!!"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", mediaItemKey: " + to_string(mediaItemKey)
							;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}

						try
						{
							Json::CharReaderBuilder builder;                                  
							Json::CharReader* reader = builder.newCharReader();               
							string errors;                                                    

							bool parsingSuccessful = reader->parse(                           
								userData.c_str(),                             
								userData.c_str() + userData.size(),
								&userDataRoot, &errors);                      
							delete reader;

							if (!parsingSuccessful)                                           
							{
								string errorMessage = __FILEREF__ + "failed to parse the userData"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", mediaItemKey: " + to_string(mediaItemKey)
									+ ", errors: " + errors
									+ ", userData: " + userData
								;
								_logger->error(errorMessage);

								throw runtime_error(errors);
							}
						}
						catch(runtime_error e)
						{
							string errorMessage = string("userData json is not well format")
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", mediaItemKey: " + to_string(mediaItemKey)
								+ ", userData: " + userData
								+ ", e.what(): " + e.what()
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);
						}
						catch(exception e)
						{
							string errorMessage = string("userData json is not well format")
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", mediaItemKey: " + to_string(mediaItemKey)
								+ ", userData: " + userData
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);
						}
					}

					field = "mmsData";
					Json::Value mmsDataRoot = userDataRoot[field];

					field = "utcChunkStartTime";
					int64_t currentUtcChunkStartTime = JSONUtils::asInt64(mmsDataRoot, field, 0);

					field = "utcChunkEndTime";
					int64_t currentUtcChunkEndTime = JSONUtils::asInt64(mmsDataRoot, field, 0);

					string currentChunkStartTime;
					string currentChunkEndTime;
					{
						char strDateTime [64];
						tm tmDateTime;

						localtime_r (&currentUtcChunkStartTime, &tmDateTime);
						sprintf (strDateTime, "%04d-%02d-%02d %02d:%02d:%02d",
							tmDateTime. tm_year + 1900,
							tmDateTime. tm_mon + 1,
							tmDateTime. tm_mday,
							tmDateTime. tm_hour,
							tmDateTime. tm_min,
							tmDateTime. tm_sec);
						currentChunkStartTime = strDateTime;

						localtime_r (&currentUtcChunkEndTime, &tmDateTime);
						sprintf (strDateTime, "%04d-%02d-%02d %02d:%02d:%02d",
							tmDateTime. tm_year + 1900,
							tmDateTime. tm_mon + 1,
							tmDateTime. tm_mday,
							tmDateTime. tm_hour,
							tmDateTime. tm_min,
							tmDateTime. tm_sec);
						currentChunkEndTime = strDateTime;
					}

					_logger->info(__FILEREF__ + "Retrieved chunk"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", mediaITemKey: " + to_string(mediaItemKey)
						+ ", currentUtcChunkStartTime: " + to_string(currentUtcChunkStartTime) + " (" + currentChunkStartTime + ")"
						+ ", currentUtcChunkEndTime: " + to_string(currentUtcChunkEndTime) + " (" + currentChunkEndTime + ")"
					);

					// check if it is the next chunk
					if (utcPreviousUtcChunkEndTime != -1 && utcPreviousUtcChunkEndTime != currentUtcChunkStartTime)
					{
						string previousUtcChunkEndTime;
						{
							char strDateTime [64];
							tm tmDateTime;

							localtime_r (&utcPreviousUtcChunkEndTime, &tmDateTime);

							sprintf (strDateTime, "%04d-%02d-%02d %02d:%02d:%02d",
								tmDateTime. tm_year + 1900,
								tmDateTime. tm_mon + 1,
								tmDateTime. tm_mday,
								tmDateTime. tm_hour,
								tmDateTime. tm_min,
								tmDateTime. tm_sec);
							previousUtcChunkEndTime = strDateTime;
						}

						// it is not the next chunk
						string errorMessage = string("#Chunks check. Next chunk was not found")
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", utcPreviousUtcChunkEndTime: " + to_string(utcPreviousUtcChunkEndTime) + " (" + previousUtcChunkEndTime + ")"
							+ ", currentUtcChunkStartTime: " + to_string(currentUtcChunkStartTime) + " (" + currentChunkStartTime + ")"
							+ ", currentUtcChunkEndTime: " + to_string(currentUtcChunkEndTime) + " (" + currentChunkEndTime + ")"
							+ ", utcCutPeriodStartTimeInMilliSeconds: " + to_string(utcCutPeriodStartTimeInMilliSeconds)
								+ " (" + cutPeriodStartTimeInMilliSeconds + ")"
							+ ", utcCutPeriodEndTimeInMilliSeconds: " + to_string(utcCutPeriodEndTimeInMilliSeconds)
								+ " (" + cutPeriodEndTimeInMilliSeconds + ")"
						;
						if (errorIfAChunkIsMissing)
						{
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);
						}
						else
						{
							_logger->warn(__FILEREF__ + errorMessage);
						}
					}

					// check if it is the first chunk
					if (firstRetrievedChunk)
					{
						firstRetrievedChunk = false;

						// check that it is the first chunk

						if (!(currentUtcChunkStartTime * 1000 <= utcCutPeriodStartTimeInMilliSeconds
							&& utcCutPeriodStartTimeInMilliSeconds < currentUtcChunkEndTime * 1000))
						{
							firstRequestedChunk = false;

							// it is not the first chunk
							string errorMessage = string("#Chunks check. First chunk was not found")
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", first utcChunkStart: " + to_string(currentUtcChunkStartTime) + " (" + currentChunkStartTime + ")"
								+ ", first currentUtcChunkEndTime: " + to_string(currentUtcChunkEndTime) + " (" + currentChunkEndTime + ")"
								+ ", utcCutPeriodStartTimeInMilliSeconds: " + to_string(utcCutPeriodStartTimeInMilliSeconds)
									+ " (" + cutPeriodStartTimeInMilliSeconds + ")"
								+ ", utcCutPeriodEndTimeInMilliSeconds: " + to_string(utcCutPeriodEndTimeInMilliSeconds)
									+ " (" + cutPeriodEndTimeInMilliSeconds + ")"
							;
							if (errorIfAChunkIsMissing)
							{
								_logger->error(__FILEREF__ + errorMessage);

								throw runtime_error(errorMessage);
							}
							else
							{
								_logger->warn(__FILEREF__ + errorMessage);
							}
						}
						else
						{
							firstRequestedChunk = true;
						}

						utcFirstChunkStartTime = currentUtcChunkStartTime;
						firstChunkStartTime = currentChunkStartTime;
					}

					{
						Json::Value mediaItemKeyReferenceRoot;

						field = "ReferenceMediaItemKey";
						mediaItemKeyReferenceRoot[field] = mediaItemKey;

						mediaItemKeyReferencesRoot.append(mediaItemKeyReferenceRoot);
					}

					{
						// check if it is the last chunk

						if (!(currentUtcChunkStartTime * 1000 < utcCutPeriodEndTimeInMilliSecondsPlusOneSecond
								&& utcCutPeriodEndTimeInMilliSecondsPlusOneSecond <= currentUtcChunkEndTime * 1000))
							lastRequestedChunk = false;
						else
						{
							lastRequestedChunk = true;
							utcLastChunkEndTime = currentUtcChunkEndTime;
							lastChunkEndTime = currentChunkEndTime;
						}
					}

					utcPreviousUtcChunkEndTime = currentUtcChunkEndTime;
				}

				start += rows;

				_logger->info(__FILEREF__ + "Retrieving chunk"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", start: " + to_string(start)
					+ ", rows: " + to_string(rows)
					+ ", mediaItemsRoot.size: " + to_string(mediaItemsRoot.size())
					+ ", lastRequestedChunk: " + to_string(lastRequestedChunk)
				);
			}
			while(mediaItemsRoot.size() == rows);

			// just waiting if the last chunk was not finished yet
			if (!lastRequestedChunk)
			{
				if (chrono::duration_cast<chrono::seconds>(
					chrono::system_clock::now() - startLookingForChunks).count() < maxWaitingForLastChunkInSeconds)
				{
					int secondsToWaitLastChunk = 30;

					this_thread::sleep_for(chrono::seconds(secondsToWaitLastChunk));
				}
			}
		}

		if (!firstRequestedChunk || !lastRequestedChunk)
		{
			string errorMessage = string("#Chunks check. Chunks not available")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", firstRequestedChunk: " + to_string(firstRequestedChunk)
				+ ", lastRequestedChunk: " + to_string(lastRequestedChunk)
				// + ", streamSourceType: " + streamSourceType
				// + ", ipConfigurationLabel: " + ipConfigurationLabel
				// + ", satConfigurationLabel: " + satConfigurationLabel
				+ ", deliveryCode: " + to_string(deliveryCode)
				+ ", cutPeriodStartTimeInMilliSeconds: " + cutPeriodStartTimeInMilliSeconds
				+ ", cutPeriodEndTimeInMilliSeconds: " + cutPeriodEndTimeInMilliSeconds
				+ ", maxWaitingForLastChunkInSeconds: " + to_string(maxWaitingForLastChunkInSeconds)
			;
			if (errorIfAChunkIsMissing)
			{
				_logger->error(__FILEREF__ + errorMessage);

				throw runtime_error(errorMessage);
			}
			else
			{
				_logger->warn(__FILEREF__ + errorMessage);
			}
		}

		_logger->info(__FILEREF__ + "Preparing workflow to ingest..."
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		);

		Json::Value liveCutOnSuccess = Json::nullValue;
		Json::Value liveCutOnError = Json::nullValue;
		Json::Value liveCutOnComplete = Json::nullValue;
		int64_t userKey;
		string apiKey;
		{
			string field = "internalMMS";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
			{
				Json::Value internalMMSRoot = liveCutParametersRoot[field];

				field = "credentials";
				if (JSONUtils::isMetadataPresent(internalMMSRoot, field))
				{
					Json::Value credentialsRoot = internalMMSRoot[field];

					field = "userKey";
					userKey = JSONUtils::asInt64(credentialsRoot, field, -1);

					field = "apiKey";
					string apiKeyEncrypted = credentialsRoot.get(field, "").asString();
					apiKey = Encrypt::opensslDecrypt(apiKeyEncrypted);
				}

				field = "events";
				if (JSONUtils::isMetadataPresent(internalMMSRoot, field))
				{
					Json::Value eventsRoot = internalMMSRoot[field];

					field = "OnSuccess";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						liveCutOnSuccess = eventsRoot[field];

					field = "OnError";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						liveCutOnError = eventsRoot[field];

					field = "OnComplete";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						liveCutOnComplete = eventsRoot[field];
				}
			}
		}

		// create workflow to ingest
		string workflowMetadata;
		{
			Json::Value concatDemuxerRoot;
			Json::Value concatDemuxerParametersRoot;
			{
				string field = "Label";
				concatDemuxerRoot[field] = "Concat from " + to_string(utcFirstChunkStartTime) + " (" + firstChunkStartTime
					+ ") to " + to_string(utcLastChunkEndTime) + " (" + lastChunkEndTime + ")";

				field = "Type";
				concatDemuxerRoot[field] = "Concat-Demuxer";

				concatDemuxerParametersRoot = liveCutParametersRoot;
				/*
				if (streamSourceType == "IP_PULL")
				{
					Json::Value removed;
					field = "ConfigurationLabel";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				else if (streamSourceType == "Satellite")
				{
					Json::Value removed;
					field = "ConfigurationLabel";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				else // if (streamSourceType == "IP_PUSH")
				{
					Json::Value removed;
					field = "ActAsServerChannelCode";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				*/
				{
					Json::Value removed;
					field = "DeliveryCode";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}

				{
					Json::Value removed;
					field = "CutPeriod";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				{
					field = "MaxWaitingForLastChunkInSeconds";
					if (JSONUtils::isMetadataPresent(concatDemuxerParametersRoot, field))
					{
						Json::Value removed;
						concatDemuxerParametersRoot.removeMember(field, &removed);
					}
				}

				field = "Retention";
				concatDemuxerParametersRoot[field] = "0";

				field = "References";
				concatDemuxerParametersRoot[field] = mediaItemKeyReferencesRoot;

				field = "Parameters";
				concatDemuxerRoot[field] = concatDemuxerParametersRoot;
			}

			Json::Value cutRoot;
			{
				string field = "Label";
				cutRoot[field] = string("Live Cut from ") + to_string(utcCutPeriodStartTimeInMilliSeconds)
					+ " (" + cutPeriodStartTimeInMilliSeconds + ") to "
					+ to_string(utcCutPeriodEndTimeInMilliSeconds) + " (" + cutPeriodEndTimeInMilliSeconds + ")";

				field = "Type";
				cutRoot[field] = "Cut";

				Json::Value cutParametersRoot = concatDemuxerParametersRoot;
				{
					Json::Value removed;
					field = "References";
					cutParametersRoot.removeMember(field, &removed);
				}

				field = "Retention";
				cutParametersRoot[field] = liveCutParametersRoot.get(field, "").asString();

				double startTimeInMilliSeconds = utcCutPeriodStartTimeInMilliSeconds
					- (utcFirstChunkStartTime * 1000);
				double startTimeInSeconds = startTimeInMilliSeconds / 1000;
				field = "StartTimeInSeconds";
				cutParametersRoot[field] = startTimeInSeconds;

				double endTimeInMilliSeconds = utcCutPeriodEndTimeInMilliSeconds - (utcFirstChunkStartTime * 1000);
				double endTimeInSeconds = endTimeInMilliSeconds / 1000;
				field = "EndTimeInSeconds";
				cutParametersRoot[field] = endTimeInSeconds;

				// 2020-07-19: keyFrameSeeking by default it is true.
				//	Result is that the cut is a bit over (in my test it was about one second more).
				//	Using keyFrameSeeking false the Cut is accurate.
				string cutType = "FrameAccurateWithoutEncoding";
				field = "CutType";
				cutParametersRoot[field] = cutType;

				bool fixEndTimeIfOvercomeDuration;
				if (!errorIfAChunkIsMissing)
					fixEndTimeIfOvercomeDuration = true;
				else
					fixEndTimeIfOvercomeDuration = false;
				field = "FixEndTimeIfOvercomeDuration";
				cutParametersRoot[field] = fixEndTimeIfOvercomeDuration;

				{
					Json::Value userDataRoot;

					field = "UserData";
					if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
					{
						// to_string(static_cast<int>(liveCutParametersRoot[field].type())) == 7 means objectValue 
						//		(see Json::ValueType definition: http://jsoncpp.sourceforge.net/value_8h_source.html)

						Json::ValueType valueType = liveCutParametersRoot[field].type();

						_logger->info(__FILEREF__ + "Preparing workflow to ingest... (2)"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", type: " + to_string(static_cast<int>(valueType))
						);

						if (valueType == Json::ValueType::stringValue)
						{
							string sUserData = liveCutParametersRoot.get(field, "").asString();

							if (sUserData != "")
							{
								try
								{
									Json::CharReaderBuilder builder;                                  
									Json::CharReader* reader = builder.newCharReader();               
									string errors;                                                    

									bool parsingSuccessful = reader->parse(                           
										sUserData.c_str(),                             
										sUserData.c_str() + sUserData.size(),
										&userDataRoot, &errors);                      
									delete reader;

									if (!parsingSuccessful)                                           
									{
										string errorMessage = __FILEREF__ + "failed to parse the userData"
											+ ", _processorIdentifier: " + to_string(_processorIdentifier)
											+ ", ingestionJobKey: " + to_string(ingestionJobKey)
											+ ", errors: " + errors
											+ ", sUserData: " + sUserData
										;
										_logger->error(errorMessage);

										throw runtime_error(errors);
									}
								}
								catch(runtime_error e)
								{
									string errorMessage = string("userData json is not well format")
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", sUserData: " + sUserData
										+ ", e.what(): " + e.what()
									;
									_logger->error(__FILEREF__ + errorMessage);

									throw runtime_error(errorMessage);
								}
								catch(exception e)
								{
									string errorMessage = string("userData json is not well format")
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", sUserData: " + sUserData
									;
									_logger->error(__FILEREF__ + errorMessage);

									throw runtime_error(errorMessage);
								}
							}
						}
						else // if (valueType == Json::ValueType::objectValue)
						{
							userDataRoot = liveCutParametersRoot[field];
						}
					}

					Json::Value mmsDataRoot;

					/*
					 * liveCutUtcStartTimeInMilliSecs and liveCutUtcEndTimeInMilliSecs was
					 * commented because:
					 *	1. they do not have the right name
					 *	2. LiveCut generates a workflow of
					 *		- concat of chunks --> cut of the concat
					 *		The Concat media will have the TimeCode because they are
					 *		automatically generated by the task (see the concat method
					 *		in this class)
					 *		The Cut media will have the TimeCode because they are
					 *		automatically generated by the task (see the cut method
					 *		in this class)

					field = "liveCutUtcStartTimeInMilliSecs";
					mmsDataRoot[field] = utcCutPeriodStartTimeInMilliSeconds;

					field = "liveCutUtcEndTimeInMilliSecs";
					mmsDataRoot[field] = utcCutPeriodEndTimeInMilliSeconds;
					*/

					/*
					field = "streamSourceType";
					mmsDataRoot[field] = streamSourceType;

					if (streamSourceType == "IP_PULL")
					{
						field = "configurationLabel";
						mmsDataRoot[field] = ipConfigurationLabel;
					}
					else if (streamSourceType == "Satellite")
					{
						field = "configurationLabel";
						mmsDataRoot[field] = satConfigurationLabel;
					}
					else // if (streamSourceType == "IP_PUSH")
					{
						field = "actAsServerChannelCode";
						mmsDataRoot[field] = actAsServerChannelCode;
					}
					*/
					field = "deliveryCode";
					mmsDataRoot[field] = deliveryCode;

					field = "mmsData";
					userDataRoot["mmsData"] = mmsDataRoot;

					field = "UserData";
					cutParametersRoot[field] = userDataRoot;
				}

				field = "Parameters";
				cutRoot[field] = cutParametersRoot;

				if (liveCutOnSuccess != Json::nullValue)
				{
					field = "OnSuccess";
					cutRoot[field] = liveCutOnSuccess;
				}
				if (liveCutOnError != Json::nullValue)
				{
					field = "OnError";
					cutRoot[field] = liveCutOnError;
				}
				if (liveCutOnComplete != Json::nullValue)
				{
					field = "OnComplete";
					cutRoot[field] = liveCutOnComplete;
				}
			}

			Json::Value concatOnSuccessRoot;
			{
				Json::Value cutTaskRoot;
				string field = "Task";
				cutTaskRoot[field] = cutRoot;

				field = "OnSuccess";
				concatDemuxerRoot[field] = cutTaskRoot;
			}

			Json::Value workflowRoot;
			{
				string field = "Label";
				workflowRoot[field] = string("Cut from ") + to_string(utcCutPeriodStartTimeInMilliSeconds)
					+ " (" + cutPeriodStartTimeInMilliSeconds + ") to "
					+ to_string(utcCutPeriodEndTimeInMilliSeconds) + " (" + cutPeriodEndTimeInMilliSeconds + ")";

				field = "Type";
				workflowRoot[field] = "Workflow";

				field = "Task";
				workflowRoot[field] = concatDemuxerRoot;
			}

			{
				Json::StreamWriterBuilder wbuilder;
				workflowMetadata = Json::writeString(wbuilder, workflowRoot);
			}
		}

		string sResponse = MMSCURL::httpPostPutString(                                                        
			ingestionJobKey,                                                                                  
			_mmsWorkflowIngestionURL,                                                                                        
			"POST", // requestType                                                                            
			_mmsAPITimeoutInSeconds,                                                                          
			to_string(userKey),                                                                               
			apiKey,                                                                                           
			workflowMetadata,                                                                                 
			"application/json", // contentType                                                                
			_logger                                                                                           
		);                                                                                                    

		/*
		{
			string mmsAPIURL =
				_mmsAPIProtocol
				+ "://"
				+ _mmsAPIHostname + ":"
				+ to_string(_mmsAPIPort)
				+ "/catramms/"
				+ _mmsAPIVersion
				+ _mmsAPIIngestionURI
            ;

			list<string> header;

			header.push_back("Content-Type: application/json");
			{
				// string userPasswordEncoded = Convert::base64_encode(_mmsAPIUser + ":" + _mmsAPIPassword);
				string userPasswordEncoded = Convert::base64_encode(to_string(userKey) + ":" + apiKey);
				string basicAuthorization = string("Authorization: Basic ") + userPasswordEncoded;

				header.push_back(basicAuthorization);
			}

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			// Setting the URL to retrive.
			request.setOpt(new curlpp::options::Url(mmsAPIURL));

			// timeout consistent with nginx configuration (fastcgi_read_timeout)
			request.setOpt(new curlpp::options::Timeout(_mmsAPITimeoutInSeconds));

			if (_mmsAPIProtocol == "https")
			{
				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);
               
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);
               
				// request.setOpt(new curlpp::options::SslEngineDefault());                                              
			}

			request.setOpt(new curlpp::options::HttpHeader(header));
			request.setOpt(new curlpp::options::PostFields(workflowMetadata));
			request.setOpt(new curlpp::options::PostFieldSize(workflowMetadata.length()));

			ostringstream response;

			request.setOpt(new curlpp::options::WriteStream(&response));

			_logger->info(__FILEREF__ + "Ingesting CutLive workflow"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
				+ ", mmsAPIURL: " + mmsAPIURL
				+ ", workflowMetadata: " + workflowMetadata
			);
			chrono::system_clock::time_point startIngesting = chrono::system_clock::now();
			request.perform();
			chrono::system_clock::time_point endIngesting = chrono::system_clock::now();

			string sResponse = response.str();
			// LF and CR create problems to the json parser...
			while (sResponse.size() > 0 && (sResponse.back() == 10 || sResponse.back() == 13))
				sResponse.pop_back();

			long responseCode = curlpp::infos::ResponseCode::get(request);
			if (responseCode == 201)
			{
				string message = __FILEREF__ + "Ingested CutLive workflow response"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", @MMS statistics@ - ingestingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endIngesting - startIngesting).count()) + "@"
					+ ", workflowMetadata: " + workflowMetadata
					+ ", sResponse: " + sResponse
					;
				_logger->info(message);
			}
			else
			{
				string message = __FILEREF__ + "Ingested CutLive workflow response"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", @MMS statistics@ - ingestingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endIngesting - startIngesting).count()) + "@"
					+ ", workflowMetadata: " + workflowMetadata
					+ ", sResponse: " + sResponse
					+ ", responseCode: " + to_string(responseCode)
					;
				_logger->error(message);

				throw runtime_error(message);
			}
		}
		*/

        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_TaskSuccess"
            + ", errorMessage: " + ""
        );
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
        );
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "liveCutThread failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		return;
        // throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "liveCutThread failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		return;
        // throw e;
    }
}

void MMSEngineProcessor::liveCutThread_hlsSegmenter(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	string ingestionJobLabel,
	shared_ptr<Workspace> workspace,
	Json::Value liveCutParametersRoot
)
{
    try
    {
		_logger->info(__FILEREF__ + "liveCutThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

		// string streamSourceType;
		// string ipConfigurationLabel;
		// string satConfigurationLabel;
		int64_t deliveryCode;
		int64_t chunkEncodingProfileKey = -1;
		string chunkEncodingProfileLabel;
        string cutPeriodStartTimeInMilliSeconds;
        string cutPeriodEndTimeInMilliSeconds;
		int maxWaitingForLastChunkInSeconds = 90;
		bool errorIfAChunkIsMissing = false;
        {
			/*
            string field = "streamSourceType";
            if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
			streamSourceType = liveCutParametersRoot.get(field, "").asString();

			if (streamSourceType == "IP_PULL")
			{
				field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				ipConfigurationLabel = liveCutParametersRoot.get(field, "").asString();
			}
			else if (streamSourceType == "Satellite")
			{
				field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				satConfigurationLabel = liveCutParametersRoot.get(field, "").asString();
			}
			*/

			// else if (streamSourceType == "IP_PUSH")
			string field = "DeliveryCode";
			if (!JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			deliveryCode = JSONUtils::asInt64(liveCutParametersRoot, field, -1);

			field = "ChunkEncodingProfileKey";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				chunkEncodingProfileKey = JSONUtils::asInt64(liveCutParametersRoot, field, 90);

			field = "ChunkEncodingProfileLabel";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				chunkEncodingProfileLabel = liveCutParametersRoot.get(field, "").asString();

			field = "MaxWaitingForLastChunkInSeconds";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				maxWaitingForLastChunkInSeconds = JSONUtils::asInt64(liveCutParametersRoot, field, 90);

			field = "ErrorIfAChunkIsMissing";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
				errorIfAChunkIsMissing = JSONUtils::asBool(liveCutParametersRoot, field, false);

            field = "CutPeriod";
			Json::Value cutPeriodRoot = liveCutParametersRoot[field];

            field = "Start";
            if (!JSONUtils::isMetadataPresent(cutPeriodRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            cutPeriodStartTimeInMilliSeconds = cutPeriodRoot.get(field, "").asString();

            field = "End";
            if (!JSONUtils::isMetadataPresent(cutPeriodRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            cutPeriodEndTimeInMilliSeconds = cutPeriodRoot.get(field, "").asString();
        }

		// Validator validator(_logger, _mmsEngineDBFacade, _configuration);

		int64_t utcCutPeriodStartTimeInMilliSeconds = DateTime::sDateMilliSecondsToUtc(cutPeriodStartTimeInMilliSeconds);

		// next code is the same in the Validator class
		int64_t utcCutPeriodEndTimeInMilliSeconds = DateTime::sDateMilliSecondsToUtc(cutPeriodEndTimeInMilliSeconds);

		/*
		 * 2020-03-30: scenario: period end time is 300 seconds (5 minutes). In case the chunk is 1 minute,
		 * we will take 5 chunks.
		 * The result is that the Cut will fail because:
		 * - we need to cut to 300 seconds
		 * - the duration of the video is 298874 milliseconds
		 * For this reason, when we retrieve the chunks, we will use 'period end time' plus one second
		 */
		int64_t utcCutPeriodEndTimeInMilliSecondsPlusOneSecond = utcCutPeriodEndTimeInMilliSeconds + 1000;

		/*
		int64_t confKey = -1;
		if (streamSourceType == "IP_PULL")
		{
			bool warningIfMissing = false;
			pair<int64_t, string> confKeyAndLiveURL = _mmsEngineDBFacade->getIPChannelConfDetails(
				workspace->_workspaceKey, ipConfigurationLabel, warningIfMissing);
			tie(confKey, ignore) = confKeyAndLiveURL;
		}
		else if (streamSourceType == "Satellite")
		{
			bool warningIfMissing = false;
			confKey = _mmsEngineDBFacade->getSATChannelConfDetails(
				workspace->_workspaceKey, satConfigurationLabel, warningIfMissing);
		}
		*/

		Json::Value mediaItemKeyReferencesRoot(Json::arrayValue);
		int64_t utcFirstChunkStartTimeInMilliSecs;
		string firstChunkStartTime;
		int64_t utcLastChunkEndTimeInMilliSecs;
		string lastChunkEndTime;

		chrono::system_clock::time_point startLookingForChunks = chrono::system_clock::now();

		bool firstRequestedChunk = false;
		bool lastRequestedChunk = false;
		while (!lastRequestedChunk
			&& (chrono::duration_cast<chrono::seconds>(chrono::system_clock::now()
				- startLookingForChunks).count() < maxWaitingForLastChunkInSeconds)
		)
		{
			int64_t mediaItemKey = -1;
			int64_t physicalPathKey = -1;
			string uniqueName;
			vector<int64_t> otherMediaItemsKey;
			int start = 0;
			int rows = 60 * 1;	// assuming every MediaItem is one minute, let's take 1 hour
			bool contentTypePresent = true;
			MMSEngineDBFacade::ContentType contentType = MMSEngineDBFacade::ContentType::Video;
			// bool startAndEndIngestionDatePresent = false;
			string startIngestionDate;
			string endIngestionDate;
			string title;
			int liveRecordingChunk = 1;
			vector<string> tagsIn;
			vector<string> tagsNotIn;
			string orderBy;
			bool admin = false;

			firstRequestedChunk = false;
			lastRequestedChunk = false;

			string jsonCondition;
			/*
			{
				// SC: Start Chunk
				// PS: Playout Start, PE: Playout End
				// --------------SC--------------SC--------------SC--------------SC
				//                       PS-------------------------------PE

				jsonCondition = "(";

				// first chunk of the cut
				jsonCondition += (
					"(JSON_EXTRACT(userData, '$.mmsData.utcStartTimeInMilliSecs') <= "
						+ to_string(utcCutPeriodStartTimeInMilliSeconds) + " "
					+ "and " + to_string(utcCutPeriodStartTimeInMilliSeconds)
						+ " < JSON_EXTRACT(userData, '$.mmsData.utcEndTimeInMilliSecs') ) "
				);

				jsonCondition += " or ";

				// internal chunk of the cut
				jsonCondition += (
					"( " + to_string(utcCutPeriodStartTimeInMilliSeconds) + " <= JSON_EXTRACT(userData, '$.mmsData.utcStartTimeInMilliSecs') "
					+ "and JSON_EXTRACT(userData, '$.mmsData.utcEndTimeInMilliSecs') <= " + to_string(utcCutPeriodEndTimeInMilliSecondsPlusOneSecond) + ") "
				);

				jsonCondition += " or ";

				// last chunk of the cut
				jsonCondition += (
					"( JSON_EXTRACT(userData, '$.mmsData.utcStartTimeInMilliSecs') < " + to_string(utcCutPeriodEndTimeInMilliSecondsPlusOneSecond) + " "
						+ "and " + to_string(utcCutPeriodEndTimeInMilliSecondsPlusOneSecond) + " <= JSON_EXTRACT(userData, '$.mmsData.utcEndTimeInMilliSecs') ) "
					);

				jsonCondition += ")";
			}
			string jsonOrderBy = "JSON_EXTRACT(userData, '$.mmsData.utcStartTimeInMilliSecs') asc";
			*/
			string jsonOrderBy;
			orderBy = "utcStartTimeInMilliSecs_virtual asc";

			long utcPreviousUtcChunkEndTimeInMilliSecs = -1;
			bool firstRetrievedChunk = true;

			// retrieve the reference of all the MediaItems to be concatenate
			mediaItemKeyReferencesRoot.clear();

			// Json::Value mediaItemsListRoot;
			Json::Value mediaItemsRoot;
			do
			{
				Json::Value responseFields = Json::nullValue;
				Json::Value mediaItemsListRoot = _mmsEngineDBFacade->getMediaItemsList(
					workspace->_workspaceKey, mediaItemKey, uniqueName, physicalPathKey, otherMediaItemsKey,
					start, rows,
					contentTypePresent, contentType,
					// startAndEndIngestionDatePresent,
					startIngestionDate, endIngestionDate,
					title, liveRecordingChunk,
					deliveryCode,
					utcCutPeriodStartTimeInMilliSeconds, utcCutPeriodEndTimeInMilliSecondsPlusOneSecond,
					jsonCondition,
					tagsIn, tagsNotIn, orderBy, jsonOrderBy,
					responseFields, admin);

				string field = "response";
				Json::Value responseRoot = mediaItemsListRoot[field];

				field = "mediaItems";
				mediaItemsRoot = responseRoot[field];

				for (int mediaItemIndex = 0; mediaItemIndex < mediaItemsRoot.size(); mediaItemIndex++)
				{
					Json::Value mediaItemRoot = mediaItemsRoot[mediaItemIndex];

					field = "mediaItemKey";
					int64_t mediaItemKey = JSONUtils::asInt64(mediaItemRoot, field, 0);

					Json::Value userDataRoot;
					{
						field = "userData";
						string userData = mediaItemRoot.get(field, "").asString();
						if (userData == "")
						{
							string errorMessage = __FILEREF__ + "recording media item without userData!!!"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", mediaItemKey: " + to_string(mediaItemKey)
							;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}

						try
						{
							Json::CharReaderBuilder builder;                                  
							Json::CharReader* reader = builder.newCharReader();               
							string errors;                                                    

							bool parsingSuccessful = reader->parse(                           
								userData.c_str(),                             
								userData.c_str() + userData.size(),
								&userDataRoot, &errors);                      
							delete reader;

							if (!parsingSuccessful)                                           
							{
								string errorMessage = __FILEREF__ + "failed to parse the userData"
									+ ", _processorIdentifier: " + to_string(_processorIdentifier)
									+ ", ingestionJobKey: " + to_string(ingestionJobKey)
									+ ", mediaItemKey: " + to_string(mediaItemKey)
									+ ", errors: " + errors
									+ ", userData: " + userData
								;
								_logger->error(errorMessage);

								throw runtime_error(errors);
							}
						}
						catch(runtime_error e)
						{
							string errorMessage = string("userData json is not well format")
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", mediaItemKey: " + to_string(mediaItemKey)
								+ ", userData: " + userData
								+ ", e.what(): " + e.what()
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);
						}
						catch(exception e)
						{
							string errorMessage = string("userData json is not well format")
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", mediaItemKey: " + to_string(mediaItemKey)
								+ ", userData: " + userData
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);
						}
					}

					field = "mmsData";
					Json::Value mmsDataRoot = userDataRoot[field];

					field = "utcStartTimeInMilliSecs";
					int64_t currentUtcChunkStartTimeInMilliSecs = JSONUtils::asInt64(mmsDataRoot, field, 0);

					field = "utcEndTimeInMilliSecs";
					int64_t currentUtcChunkEndTimeInMilliSecs = JSONUtils::asInt64(mmsDataRoot, field, 0);

					string currentChunkStartTime;
					string currentChunkEndTime;
					{
						char strDateTime [64];
						tm tmDateTime;

						int64_t currentUtcChunkStartTime = currentUtcChunkStartTimeInMilliSecs / 1000;
						localtime_r (&currentUtcChunkStartTime, &tmDateTime);
						sprintf (strDateTime, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
							tmDateTime. tm_year + 1900,
							tmDateTime. tm_mon + 1,
							tmDateTime. tm_mday,
							tmDateTime. tm_hour,
							tmDateTime. tm_min,
							tmDateTime. tm_sec,
							(int) (currentUtcChunkStartTimeInMilliSecs % 1000));
						currentChunkStartTime = strDateTime;

						int64_t currentUtcChunkEndTime = currentUtcChunkEndTimeInMilliSecs / 1000;
						localtime_r (&currentUtcChunkEndTime, &tmDateTime);
						sprintf (strDateTime, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
							tmDateTime. tm_year + 1900,
							tmDateTime. tm_mon + 1,
							tmDateTime. tm_mday,
							tmDateTime. tm_hour,
							tmDateTime. tm_min,
							tmDateTime. tm_sec,
							(int) (currentUtcChunkEndTimeInMilliSecs % 1000));
						currentChunkEndTime = strDateTime;
					}

					_logger->info(__FILEREF__ + "Retrieved chunk"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", mediaITemKey: " + to_string(mediaItemKey)
						+ ", currentUtcChunkStartTimeInMilliSecs: " + to_string(currentUtcChunkStartTimeInMilliSecs) + " (" + currentChunkStartTime + ")"
						+ ", currentUtcChunkEndTimeInMilliSecs: " + to_string(currentUtcChunkEndTimeInMilliSecs) + " (" + currentChunkEndTime + ")"
					);

					// check if it is the next chunk
					if (utcPreviousUtcChunkEndTimeInMilliSecs != -1 && utcPreviousUtcChunkEndTimeInMilliSecs != currentUtcChunkStartTimeInMilliSecs)
					{
						string previousUtcChunkEndTime;
						{
							char strDateTime [64];
							tm tmDateTime;

							int64_t utcPreviousUtcChunkEndTime = utcPreviousUtcChunkEndTimeInMilliSecs / 1000;
							localtime_r (&utcPreviousUtcChunkEndTime, &tmDateTime);

							sprintf (strDateTime, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
								tmDateTime. tm_year + 1900,
								tmDateTime. tm_mon + 1,
								tmDateTime. tm_mday,
								tmDateTime. tm_hour,
								tmDateTime. tm_min,
								tmDateTime. tm_sec,
								(int) (utcPreviousUtcChunkEndTimeInMilliSecs % 1000));
							previousUtcChunkEndTime = strDateTime;
						}

						// it is not the next chunk
						string errorMessage = string("Next chunk was not found")
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", utcPreviousUtcChunkEndTimeInMilliSecs: " + to_string(utcPreviousUtcChunkEndTimeInMilliSecs) + " (" + previousUtcChunkEndTime + ")"
							+ ", currentUtcChunkStartTimeInMilliSecs: " + to_string(currentUtcChunkStartTimeInMilliSecs) + " (" + currentChunkStartTime + ")"
							+ ", currentUtcChunkEndTimeInMilliSecs: " + to_string(currentUtcChunkEndTimeInMilliSecs) + " (" + currentChunkEndTime + ")"
							+ ", utcCutPeriodStartTimeInMilliSeconds: " + to_string(utcCutPeriodStartTimeInMilliSeconds)
								+ " (" + cutPeriodStartTimeInMilliSeconds + ")"
							+ ", utcCutPeriodEndTimeInMilliSeconds: " + to_string(utcCutPeriodEndTimeInMilliSeconds)
								+ " (" + cutPeriodEndTimeInMilliSeconds + ")"
						;
						if (errorIfAChunkIsMissing)
						{
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);
						}
						else
						{
							_logger->warn(__FILEREF__ + errorMessage);
						}
					}

					// check if it is the first chunk
					if (firstRetrievedChunk)
					{
						firstRetrievedChunk = false;

						// check that it is the first chunk

						if (!(currentUtcChunkStartTimeInMilliSecs <= utcCutPeriodStartTimeInMilliSeconds
							&& utcCutPeriodStartTimeInMilliSeconds < currentUtcChunkEndTimeInMilliSecs))
						{
							firstRequestedChunk = false;

							// it is not the first chunk
							string errorMessage = string("First chunk was not found")
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", first utcChunkStartInMilliSecs: " + to_string(currentUtcChunkStartTimeInMilliSecs) + " (" + currentChunkStartTime + ")"
								+ ", first currentUtcChunkEndTimeInMilliSecs: " + to_string(currentUtcChunkEndTimeInMilliSecs) + " (" + currentChunkEndTime + ")"
								+ ", utcCutPeriodStartTimeInMilliSeconds: " + to_string(utcCutPeriodStartTimeInMilliSeconds)
									+ " (" + cutPeriodStartTimeInMilliSeconds + ")"
								+ ", utcCutPeriodEndTimeInMilliSeconds: " + to_string(utcCutPeriodEndTimeInMilliSeconds)
									+ " (" + cutPeriodEndTimeInMilliSeconds + ")"
							;
							if (errorIfAChunkIsMissing)
							{
								_logger->error(__FILEREF__ + errorMessage);

								throw runtime_error(errorMessage);
							}
							else
							{
								_logger->warn(__FILEREF__ + errorMessage);
							}
						}
						else
						{
							firstRequestedChunk = true;
						}

						utcFirstChunkStartTimeInMilliSecs = currentUtcChunkStartTimeInMilliSecs;
						firstChunkStartTime = currentChunkStartTime;
					}

					{
						Json::Value mediaItemKeyReferenceRoot;

						field = "ReferenceMediaItemKey";
						mediaItemKeyReferenceRoot[field] = mediaItemKey;

						if (chunkEncodingProfileKey != -1)
						{
							field = "ReferenceEncodingProfileKey";
							mediaItemKeyReferenceRoot[field] = chunkEncodingProfileKey;
						}
						else if (chunkEncodingProfileLabel != "")
						{
							field = "ReferenceEncodingProfileLabel";
							mediaItemKeyReferenceRoot[field] = chunkEncodingProfileLabel;
						}

						mediaItemKeyReferencesRoot.append(mediaItemKeyReferenceRoot);
					}

					{
						// check if it is the last chunk

						if (!(currentUtcChunkStartTimeInMilliSecs < utcCutPeriodEndTimeInMilliSecondsPlusOneSecond
								&& utcCutPeriodEndTimeInMilliSecondsPlusOneSecond <= currentUtcChunkEndTimeInMilliSecs))
							lastRequestedChunk = false;
						else
						{
							lastRequestedChunk = true;
							utcLastChunkEndTimeInMilliSecs = currentUtcChunkEndTimeInMilliSecs;
							lastChunkEndTime = currentChunkEndTime;
						}
					}

					utcPreviousUtcChunkEndTimeInMilliSecs = currentUtcChunkEndTimeInMilliSecs;
				}

				start += rows;

				_logger->info(__FILEREF__ + "Retrieving chunk"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", start: " + to_string(start)
					+ ", rows: " + to_string(rows)
					+ ", mediaItemsRoot.size: " + to_string(mediaItemsRoot.size())
					+ ", lastRequestedChunk: " + to_string(lastRequestedChunk)
				);
			}
			while(mediaItemsRoot.size() == rows);

			// just waiting if the last chunk was not finished yet
			if (!lastRequestedChunk)
			{
				chrono::system_clock::time_point now = chrono::system_clock::now();
				if (chrono::duration_cast<chrono::seconds>(
					now - startLookingForChunks).count() < maxWaitingForLastChunkInSeconds)
				{
					int secondsToWaitLastChunk = 15;

					_logger->info(__FILEREF__ + "Sleeping to wait the last chunk..."
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", maxWaitingForLastChunkInSeconds: "
							+ to_string(maxWaitingForLastChunkInSeconds)
						+ ", seconds passed: " + to_string(chrono::duration_cast<
							chrono::seconds>(now - startLookingForChunks).count())
						+ ", secondsToWait before next check: "
							+ to_string(secondsToWaitLastChunk)
					);

					this_thread::sleep_for(chrono::seconds(secondsToWaitLastChunk));
				}
			}
		}

		if (!firstRequestedChunk || !lastRequestedChunk)
		{
			string errorMessage = string("Chunks not available")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", firstRequestedChunk: " + to_string(firstRequestedChunk)
				+ ", lastRequestedChunk: " + to_string(lastRequestedChunk)
				// + ", streamSourceType: " + streamSourceType
				// + ", ipConfigurationLabel: " + ipConfigurationLabel
				// + ", satConfigurationLabel: " + satConfigurationLabel
				+ ", deliveryCode: " + to_string(deliveryCode)
				+ ", cutPeriodStartTimeInMilliSeconds: " + cutPeriodStartTimeInMilliSeconds
				+ ", cutPeriodEndTimeInMilliSeconds: " + cutPeriodEndTimeInMilliSeconds
				+ ", maxWaitingForLastChunkInSeconds: " + to_string(maxWaitingForLastChunkInSeconds)
			;
			if (errorIfAChunkIsMissing)
			{
				_logger->error(__FILEREF__ + errorMessage);

				throw runtime_error(errorMessage);
			}
			else
			{
				_logger->warn(__FILEREF__ + errorMessage);
			}
		}

		_logger->info(__FILEREF__ + "Preparing workflow to ingest..."
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		);

		Json::Value liveCutOnSuccess = Json::nullValue;
		Json::Value liveCutOnError = Json::nullValue;
		Json::Value liveCutOnComplete = Json::nullValue;
		int64_t userKey;
		string apiKey;
		{
			string field = "internalMMS";
			if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
			{
				Json::Value internalMMSRoot = liveCutParametersRoot[field];

				field = "credentials";
				if (JSONUtils::isMetadataPresent(internalMMSRoot, field))
				{
					Json::Value credentialsRoot = internalMMSRoot[field];

					field = "userKey";
					userKey = JSONUtils::asInt64(credentialsRoot, field, -1);

					field = "apiKey";
					string apiKeyEncrypted = credentialsRoot.get(field, "").asString();
					apiKey = Encrypt::opensslDecrypt(apiKeyEncrypted);
				}

				field = "events";
				if (JSONUtils::isMetadataPresent(internalMMSRoot, field))
				{
					Json::Value eventsRoot = internalMMSRoot[field];

					field = "OnSuccess";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						liveCutOnSuccess = eventsRoot[field];

					field = "OnError";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						liveCutOnError = eventsRoot[field];

					field = "OnComplete";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						liveCutOnComplete = eventsRoot[field];
				}
			}
		}

		// create workflow to ingest
		string workflowMetadata;
		{
			Json::Value concatDemuxerRoot;
			Json::Value concatDemuxerParametersRoot;
			{
				string field = "Label";
				concatDemuxerRoot[field] = "Concat from " + to_string(utcFirstChunkStartTimeInMilliSecs) + " (" + firstChunkStartTime
					+ ") to " + to_string(utcLastChunkEndTimeInMilliSecs) + " (" + lastChunkEndTime + ")";

				field = "Type";
				concatDemuxerRoot[field] = "Concat-Demuxer";

				concatDemuxerParametersRoot = liveCutParametersRoot;
				/*
				if (streamSourceType == "IP_PULL")
				{
					Json::Value removed;
					field = "ConfigurationLabel";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				else if (streamSourceType == "Satellite")
				{
					Json::Value removed;
					field = "ConfigurationLabel";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				else // if (streamSourceType == "IP_PUSH")
				{
					Json::Value removed;
					field = "ActAsServerChannelCode";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				*/
				{
					Json::Value removed;
					field = "DeliveryCode";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}

				{
					Json::Value removed;
					field = "CutPeriod";
					concatDemuxerParametersRoot.removeMember(field, &removed);
				}
				{
					field = "MaxWaitingForLastChunkInSeconds";
					if (JSONUtils::isMetadataPresent(concatDemuxerParametersRoot, field))
					{
						Json::Value removed;
						concatDemuxerParametersRoot.removeMember(field, &removed);
					}
				}

				field = "Retention";
				concatDemuxerParametersRoot[field] = "0";

				field = "References";
				concatDemuxerParametersRoot[field] = mediaItemKeyReferencesRoot;

				field = "Parameters";
				concatDemuxerRoot[field] = concatDemuxerParametersRoot;
			}

			Json::Value cutRoot;
			{
				string field = "Label";
				cutRoot[field] = string("Live Cut from ") + to_string(utcCutPeriodStartTimeInMilliSeconds)
					+ " (" + cutPeriodStartTimeInMilliSeconds + ") to "
					+ to_string(utcCutPeriodEndTimeInMilliSeconds) + " (" + cutPeriodEndTimeInMilliSeconds + ")";

				field = "Type";
				cutRoot[field] = "Cut";

				Json::Value cutParametersRoot = concatDemuxerParametersRoot;
				{
					Json::Value removed;
					field = "References";
					cutParametersRoot.removeMember(field, &removed);
				}

				field = "Retention";
				cutParametersRoot[field] = liveCutParametersRoot.get(field, "").asString();

				double startTimeInMilliSeconds = utcCutPeriodStartTimeInMilliSeconds
					- utcFirstChunkStartTimeInMilliSecs;
				double startTimeInSeconds = startTimeInMilliSeconds / 1000;
				field = "StartTimeInSeconds";
				cutParametersRoot[field] = startTimeInSeconds;

				double endTimeInMilliSeconds = utcCutPeriodEndTimeInMilliSeconds - utcFirstChunkStartTimeInMilliSecs;
				double endTimeInSeconds = endTimeInMilliSeconds / 1000;
				field = "EndTimeInSeconds";
				cutParametersRoot[field] = endTimeInSeconds;

				// 2020-07-19: keyFrameSeeking by default it is true.
				//	Result is that the cut is a bit over (in my test it was about one second more).
				//	Using keyFrameSeeking false the Cut is accurate.
				string cutType = "FrameAccurateWithoutEncoding";
				field = "CutType";
				cutParametersRoot[field] = cutType;

				bool fixEndTimeIfOvercomeDuration;
				if (!errorIfAChunkIsMissing)
					fixEndTimeIfOvercomeDuration = true;
				else
					fixEndTimeIfOvercomeDuration = false;
				field = "FixEndTimeIfOvercomeDuration";
				cutParametersRoot[field] = fixEndTimeIfOvercomeDuration;

				{
					Json::Value userDataRoot;

					field = "UserData";
					if (JSONUtils::isMetadataPresent(liveCutParametersRoot, field))
					{
						// to_string(static_cast<int>(liveCutParametersRoot[field].type())) == 7 means objectValue 
						//		(see Json::ValueType definition: http://jsoncpp.sourceforge.net/value_8h_source.html)

						Json::ValueType valueType = liveCutParametersRoot[field].type();

						_logger->info(__FILEREF__ + "Preparing workflow to ingest... (2)"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", type: " + to_string(static_cast<int>(valueType))
						);

						if (valueType == Json::ValueType::stringValue)
						{
							string sUserData = liveCutParametersRoot.get(field, "").asString();

							if (sUserData != "")
							{
								try
								{
									Json::CharReaderBuilder builder;                                  
									Json::CharReader* reader = builder.newCharReader();               
									string errors;                                                    

									bool parsingSuccessful = reader->parse(                           
										sUserData.c_str(),                             
										sUserData.c_str() + sUserData.size(),
										&userDataRoot, &errors);                      
									delete reader;

									if (!parsingSuccessful)                                           
									{
										string errorMessage = __FILEREF__ + "failed to parse the userData"
											+ ", _processorIdentifier: " + to_string(_processorIdentifier)
											+ ", ingestionJobKey: " + to_string(ingestionJobKey)
											+ ", errors: " + errors
											+ ", sUserData: " + sUserData
										;
										_logger->error(errorMessage);

										throw runtime_error(errors);
									}
								}
								catch(runtime_error e)
								{
									string errorMessage = string("userData json is not well format")
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", sUserData: " + sUserData
										+ ", e.what(): " + e.what()
									;
									_logger->error(__FILEREF__ + errorMessage);

									throw runtime_error(errorMessage);
								}
								catch(exception e)
								{
									string errorMessage = string("userData json is not well format")
										+ ", _processorIdentifier: " + to_string(_processorIdentifier)
										+ ", ingestionJobKey: " + to_string(ingestionJobKey)
										+ ", sUserData: " + sUserData
									;
									_logger->error(__FILEREF__ + errorMessage);

									throw runtime_error(errorMessage);
								}
							}
						}
						else // if (valueType == Json::ValueType::objectValue)
						{
							userDataRoot = liveCutParametersRoot[field];
						}
					}

					Json::Value mmsDataRoot;

					/*
					 * liveCutUtcStartTimeInMilliSecs and liveCutUtcEndTimeInMilliSecs was
					 * commented because:
					 *	1. they do not have the right name
					 *	2. LiveCut generates a workflow of
					 *		- concat of chunks --> cut of the concat
					 *		The Concat media will have the TimeCode because they are
					 *		automatically generated by the task (see the concat method
					 *		in this class)
					 *		The Cut media will have the TimeCode because they are
					 *		automatically generated by the task (see the cut method
					 *		in this class)

					field = "liveCutUtcStartTimeInMilliSecs";
					mmsDataRoot[field] = utcCutPeriodStartTimeInMilliSeconds;

					field = "liveCutUtcEndTimeInMilliSecs";
					mmsDataRoot[field] = utcCutPeriodEndTimeInMilliSeconds;
					*/

					/*
					field = "streamSourceType";
					mmsDataRoot[field] = streamSourceType;

					if (streamSourceType == "IP_PULL")
					{
						field = "configurationLabel";
						mmsDataRoot[field] = ipConfigurationLabel;
					}
					else if (streamSourceType == "Satellite")
					{
						field = "configurationLabel";
						mmsDataRoot[field] = satConfigurationLabel;
					}
					else // if (streamSourceType == "IP_PUSH")
					{
						field = "actAsServerChannelCode";
						mmsDataRoot[field] = actAsServerChannelCode;
					}
					*/
					field = "deliveryCode";
					mmsDataRoot[field] = deliveryCode;

					field = "mmsData";
					userDataRoot["mmsData"] = mmsDataRoot;

					field = "UserData";
					cutParametersRoot[field] = userDataRoot;
				}

				field = "Parameters";
				cutRoot[field] = cutParametersRoot;

				if (liveCutOnSuccess != Json::nullValue)
				{
					field = "OnSuccess";
					cutRoot[field] = liveCutOnSuccess;
				}
				if (liveCutOnError != Json::nullValue)
				{
					field = "OnError";
					cutRoot[field] = liveCutOnError;
				}
				if (liveCutOnComplete != Json::nullValue)
				{
					field = "OnComplete";
					cutRoot[field] = liveCutOnComplete;
				}
			}

			Json::Value concatOnSuccessRoot;
			{
				Json::Value cutTaskRoot;
				string field = "Task";
				cutTaskRoot[field] = cutRoot;

				field = "OnSuccess";
				concatDemuxerRoot[field] = cutTaskRoot;
			}

			Json::Value workflowRoot;
			{
				string field = "Label";
				workflowRoot[field] = ingestionJobLabel + ". Cut from " + to_string(utcCutPeriodStartTimeInMilliSeconds)
					+ " (" + cutPeriodStartTimeInMilliSeconds + ") to "
					+ to_string(utcCutPeriodEndTimeInMilliSeconds) + " (" + cutPeriodEndTimeInMilliSeconds + ")";

				field = "Type";
				workflowRoot[field] = "Workflow";

				field = "Task";
				workflowRoot[field] = concatDemuxerRoot;
			}

			{
				Json::StreamWriterBuilder wbuilder;
				workflowMetadata = Json::writeString(wbuilder, workflowRoot);
			}
		}

		string sResponse = MMSCURL::httpPostPutString(                                                        
			ingestionJobKey,                                                                                  
			_mmsWorkflowIngestionURL,                                                                                        
			"POST", // requestType                                                                            
			_mmsAPITimeoutInSeconds,                                                                          
			to_string(userKey),                                                                               
			apiKey,                                                                                           
			workflowMetadata,                                                                                 
			"application/json", // contentType                                                                
			_logger                                                                                           
		);                                                                                                    

		/*
		{
			string mmsAPIURL =
				_mmsAPIProtocol
				+ "://"
				+ _mmsAPIHostname + ":"
				+ to_string(_mmsAPIPort)
				+ "/catramms/"
				+ _mmsAPIVersion
				+ _mmsAPIIngestionURI
            ;

			list<string> header;

			header.push_back("Content-Type: application/json");
			{
				// string userPasswordEncoded = Convert::base64_encode(_mmsAPIUser + ":" + _mmsAPIPassword);
				string userPasswordEncoded = Convert::base64_encode(to_string(userKey) + ":" + apiKey);
				string basicAuthorization = string("Authorization: Basic ") + userPasswordEncoded;

				header.push_back(basicAuthorization);
			}

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			// Setting the URL to retrive.
			request.setOpt(new curlpp::options::Url(mmsAPIURL));

			// timeout consistent with nginx configuration (fastcgi_read_timeout)
			request.setOpt(new curlpp::options::Timeout(_mmsAPITimeoutInSeconds));

			if (_mmsAPIProtocol == "https")
			{
				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);
               
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);
               
				// request.setOpt(new curlpp::options::SslEngineDefault());                                              
			}

			request.setOpt(new curlpp::options::HttpHeader(header));
			request.setOpt(new curlpp::options::PostFields(workflowMetadata));
			request.setOpt(new curlpp::options::PostFieldSize(workflowMetadata.length()));

			ostringstream response;

			request.setOpt(new curlpp::options::WriteStream(&response));

			_logger->info(__FILEREF__ + "Ingesting CutLive workflow"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
				+ ", mmsAPIURL: " + mmsAPIURL
				+ ", workflowMetadata: " + workflowMetadata
			);
			chrono::system_clock::time_point startIngesting = chrono::system_clock::now();
			request.perform();
			chrono::system_clock::time_point endIngesting = chrono::system_clock::now();

			string sResponse = response.str();
			// LF and CR create problems to the json parser...
			while (sResponse.size() > 0 && (sResponse.back() == 10 || sResponse.back() == 13))
				sResponse.pop_back();

			long responseCode = curlpp::infos::ResponseCode::get(request);
			if (responseCode == 201)
			{
				string message = __FILEREF__ + "Ingested CutLive workflow response"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", @MMS statistics@ - ingestingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endIngesting - startIngesting).count()) + "@"
					+ ", workflowMetadata: " + workflowMetadata
					+ ", sResponse: " + sResponse
					;
				_logger->info(message);
			}
			else
			{
				string message = __FILEREF__ + "Ingested CutLive workflow response"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", sResponse: " + sResponse
					+ ", responseCode: " + to_string(responseCode)
					+ ", @MMS statistics@ - ingestingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endIngesting - startIngesting).count()) + "@"
					+ ", workflowMetadata: " + workflowMetadata
					;
				_logger->error(message);

				throw runtime_error(message);
			}
		}
		*/

        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_TaskSuccess"
            + ", errorMessage: " + ""
        );
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
        );
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "liveCutThread failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		return;
        // throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "liveCutThread failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		return;
        // throw e;
    }
}

void MMSEngineProcessor::youTubeLiveBroadcastThread(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	string ingestionJobLabel,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot
)
{
    try
    {
		_logger->info(__FILEREF__ + "youTubeLiveBroadcastThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

		string youTubeConfigurationLabel;
		string youTubeLiveBroadcastTitle;
		string youTubeLiveBroadcastDescription;
		string youTubeLiveBroadcastPrivacyStatus;
		bool youTubeLiveBroadcastMadeForKids;
		string youTubeLiveBroadcastLatencyPreference;

		string scheduleStartTimeInSeconds;
		string scheduleEndTimeInSeconds;
		string sourceType;
		// streamConfigurationLabel or referencesRoot has to be present
		string streamConfigurationLabel;
		Json::Value referencesRoot;
        {
            string field = "YouTubeConfigurationLabel";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            youTubeConfigurationLabel = parametersRoot.get(field, "").asString();

            field = "Title";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            youTubeLiveBroadcastTitle = parametersRoot.get(field, "").asString();

            field = "MadeForKids";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				youTubeLiveBroadcastMadeForKids = JSONUtils::asBool(parametersRoot,
					"MadeForKids", true);
			else
				youTubeLiveBroadcastMadeForKids = true;

            field = "Description";
            if (JSONUtils::isMetadataPresent(parametersRoot, field))
				youTubeLiveBroadcastDescription = parametersRoot.get(field, "").asString();

            field = "PrivacyStatus";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				youTubeLiveBroadcastPrivacyStatus = "unlisted";
			else
				youTubeLiveBroadcastPrivacyStatus = parametersRoot.get(field, "").asString();

            field = "LatencyPreference";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				youTubeLiveBroadcastLatencyPreference = "normal";
			else
				youTubeLiveBroadcastLatencyPreference = parametersRoot.get(field, "").asString();

            field = "schedule";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
			Json::Value scheduleRoot = parametersRoot[field];

            field = "start";
            if (!JSONUtils::isMetadataPresent(scheduleRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            scheduleStartTimeInSeconds = scheduleRoot.get(field, "").asString();

            field = "end";
            if (!JSONUtils::isMetadataPresent(scheduleRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            scheduleEndTimeInSeconds = scheduleRoot.get(field, "").asString();

            field = "SourceType";
            if (!JSONUtils::isMetadataPresent(parametersRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            sourceType = parametersRoot.get(field, "").asString();

			if (sourceType == "Live")
			{
				field = "ConfigurationLabel";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				streamConfigurationLabel = parametersRoot.get(field, "").asString();
			}
			else // if (sourceType == "MediaItem")
			{
				field = "References";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				referencesRoot = parametersRoot[field];
			}
        }

		// 1. get refresh_token from the configuration
		// 2. call google API
		// 3. the response will have the access token to be used
        string youTubeAccessToken = getYouTubeAccessTokenByConfigurationLabel(
			ingestionJobKey,
            workspace, youTubeConfigurationLabel);

		string youTubeURL;
		string sResponse;
		string broadcastId;

		// first call, create the Live Broadcast
		try
		{
			/*
			* curl -v --request POST \
				'https://youtube.googleapis.com/youtube/v3/liveBroadcasts?part=snippet%2CcontentDetails%2Cstatus' \
				--header 'Authorization: Bearer ya29.a0ARrdaM9t2WqGKTgB9rZtoZU4oUCnW96Pe8qmgdk6ryYxEEe21T9WXWr8Eai1HX3AzG9zdOAEzRm8T6MhBmuQEDj4C5iDmfhRVjmUakhCKbZ7mWmqLOP9M6t5gha1QsH5ocNKqAZkhbCnWK0euQxGoK79MBjA' \
				--header 'Accept: application/json' \
				--header 'Content-Type: application/json' \
				--data '{"snippet":{"title":"Test CiborTV","scheduledStartTime":"2021-11-19T20:00:00.000Z","scheduledEndTime":"2021-11-19T22:00:00.000Z"},"contentDetails":{"enableClosedCaptions":true,"enableContentEncryption":true,"enableDvr":true,"enableEmbed":true,"recordFromStart":true,"startWithSlate":true},"status":{"privacyStatus":"unlisted"}}' \
				--compressed
			*/
			youTubeURL = _youTubeDataAPIProtocol
				+ "://"
				+ _youTubeDataAPIHostName
				+ ":" + to_string(_youTubeDataAPIPort)
				+ _youTubeDataAPILiveBroadcastURI;

			string body;
			{
				Json::Value bodyRoot;

				{
					Json::Value snippetRoot;

					string field = "title";
					snippetRoot[field] = youTubeLiveBroadcastTitle;

					if (youTubeLiveBroadcastDescription != "")
					{
						field = "description";
						snippetRoot[field] = youTubeLiveBroadcastDescription;
					}

					if (streamConfigurationLabel != "")
					{
						field = "channelId";
						snippetRoot[field] = streamConfigurationLabel;
					}

					// scheduledStartTime
					{
						int64_t utcScheduleStartTimeInSeconds
							= DateTime::sDateSecondsToUtc(scheduleStartTimeInSeconds);

						// format: YYYY-MM-DDTHH:MI:SS.000Z
						string scheduleStartTimeInMilliSeconds = scheduleStartTimeInSeconds;
						scheduleStartTimeInMilliSeconds.insert(
							scheduleStartTimeInSeconds.length() - 1, ".000", 4);

						field = "scheduledStartTime";
						snippetRoot[field] = scheduleStartTimeInMilliSeconds;
					}

					// scheduledEndTime
					{
						int64_t utcScheduleEndTimeInSeconds
							= DateTime::sDateSecondsToUtc(scheduleEndTimeInSeconds);

						// format: YYYY-MM-DDTHH:MI:SS.000Z
						string scheduleEndTimeInMilliSeconds = scheduleEndTimeInSeconds;
						scheduleEndTimeInMilliSeconds.insert(scheduleEndTimeInSeconds.length() - 1,
							".000", 4);

						field = "scheduledEndTime";
						snippetRoot[field] = scheduleEndTimeInMilliSeconds;
					}
               
					field = "snippet";
					bodyRoot[field] = snippetRoot;
				}

				{
					Json::Value contentDetailsRoot;

					bool enableContentEncryption = true;
					string field = "enableContentEncryption";
					contentDetailsRoot[field] = enableContentEncryption;

					bool enableDvr = true;
					field = "enableDvr";
					contentDetailsRoot[field] = enableDvr;

					bool enableEmbed = true;
					field = "enableEmbed";
					contentDetailsRoot[field] = enableEmbed;

					bool recordFromStart = true;
					field = "recordFromStart";
					contentDetailsRoot[field] = recordFromStart;

					bool startWithSlate = true;
					field = "startWithSlate";
					contentDetailsRoot[field] = startWithSlate;

					bool enableAutoStart = true;
					field = "enableAutoStart";
					contentDetailsRoot[field] = enableAutoStart;

					bool enableAutoStop = true;
					field = "enableAutoStop";
					contentDetailsRoot[field] = enableAutoStop;

					field = "latencyPreference";
					contentDetailsRoot[field] = youTubeLiveBroadcastLatencyPreference;

					field = "contentDetails";
					bodyRoot[field] = contentDetailsRoot;
				}

				{
					Json::Value statusRoot;

					string field = "privacyStatus";
					statusRoot[field] = youTubeLiveBroadcastPrivacyStatus;

					field = "selfDeclaredMadeForKids";
					statusRoot[field] = youTubeLiveBroadcastMadeForKids;

					field = "status";
					bodyRoot[field] = statusRoot;
				}

				{
					Json::StreamWriterBuilder wbuilder;
                   
					body = Json::writeString(wbuilder, bodyRoot);
				}
			}

			list<string> headerList;

			{
				string header = "Authorization: Bearer " + youTubeAccessToken;
				headerList.push_back(header);

                header = "Content-Length: " + to_string(body.length());
                headerList.push_back(header);

				header = "Accept: application/json";
				headerList.push_back(header);

				header = "Content-Type: application/json";
				headerList.push_back(header);
			}                    

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			request.setOpt(new curlpp::options::PostFields(body));
			request.setOpt(new curlpp::options::PostFieldSize(body.length()));

			request.setOpt(new curlpp::options::Url(youTubeURL));
			request.setOpt(new curlpp::options::Timeout(_youTubeDataAPITimeoutInSeconds));

			if (_youTubeDataAPIProtocol == "https")
			{
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
				// typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
				// typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;

				// cert is stored PEM coded in file... 
				// since PEM is default, we needn't set it for PEM 
				// curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
				// curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
				// equest.setOpt(sslCertType);

				// set the cert for client authentication
				// "testcert.pem"
				// curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
				// curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
				// request.setOpt(sslCert);

				// sorry, for engine we must set the passphrase
				//   (if the key has one...)
				// const char *pPassphrase = NULL;
				// if(pPassphrase)
				//  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

				// if we use a key stored in a crypto engine,
				//   we must set the key type to "ENG"
				// pKeyType  = "PEM";
				// curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

				// set the private key (file or ID in engine)
				// pKeyName  = "testkey.pem";
				// curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

				// set the file with the certs vaildating the server
				// *pCACertFile = "cacert.pem";
				// curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);

				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);

				// request.setOpt(new curlpp::options::SslEngineDefault());
			}
           
			for (string headerMessage: headerList)
				_logger->info(__FILEREF__ + "Adding header message: " + headerMessage);
			request.setOpt(new curlpp::options::HttpHeader(headerList));

			ostringstream response;
			request.setOpt(new curlpp::options::WriteStream(&response));

			// store response headers in the response
			// You simply have to set next option to prefix the header to the normal body output. 
			request.setOpt(new curlpp::options::Header(true)); 
           
			_logger->info(__FILEREF__ + "Calling youTube (live broadcast)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", body: " + body
			);
			request.perform();

			long responseCode = curlpp::infos::ResponseCode::get(request);

			_logger->info(__FILEREF__ + "Called youTube (live broadcast)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", responseCode: " + to_string(responseCode)
			);

			if (responseCode != 200)
			{
				string errorMessage = __FILEREF__ + "youTube (live broadcast) failed"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
					+ ", responseCode: " + to_string(responseCode)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			string sCompleteResponse = response.str();
			size_t beginOfBodyIndex;
			if ((beginOfBodyIndex = sCompleteResponse.find("\r\n\r\n")) == string::npos)
			{
				string errorMessage = __FILEREF__ + "youTube response is wrong (live broadcast)"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
					+ ", responseCode: " + to_string(responseCode)
					+ ", sCompleteResponse: " + sCompleteResponse
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			sResponse = sCompleteResponse.substr(beginOfBodyIndex + 4);
			_logger->info(__FILEREF__ + "Called youTube (live broadcast)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				// + ", body: " + body
				+ ", responseCode: " + to_string(responseCode)
				+ ", sCompleteResponse: " + sCompleteResponse
				// + ", sResponse: " + sResponse
			);

			/* sResponse:
			HTTP/2 200 
			content-type: application/json; charset=UTF-8
			vary: Origin
			vary: X-Origin
			vary: Referer
			content-encoding: gzip
			date: Sat, 20 Nov 2021 11:19:49 GMT
			server: scaffolding on HTTPServer2
			cache-control: private
			content-length: 858
			x-xss-protection: 0
			x-frame-options: SAMEORIGIN
			x-content-type-options: nosniff
			alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"

			{
				"kind": "youtube#liveBroadcast",
				"etag": "AwdnruQBkHYB37w_2Rp6zWvtVbw",
				"id": "xdAak4DmKPI",
				"snippet": {
					"publishedAt": "2021-11-19T14:12:14Z",
					"channelId": "UC2WYB3NxVDD0mf-jML8qGAA",
					"title": "Test broadcast 2",
					"description": "",
					"thumbnails": {
						"default": {
							"url": "https://i.ytimg.com/vi/xdAak4DmKPI/default_live.jpg",
							"width": 120,
							"height": 90
						},
						"medium": {
							"url": "https://i.ytimg.com/vi/xdAak4DmKPI/mqdefault_live.jpg",
							"width": 320,
							"height": 180
						},
						"high": {
							"url": "https://i.ytimg.com/vi/xdAak4DmKPI/hqdefault_live.jpg",
							"width": 480,
							"height": 360
						}
					},
					"scheduledStartTime": "2021-11-19T16:00:00Z",
					"scheduledEndTime": "2021-11-19T17:00:00Z",
					"isDefaultBroadcast": false,
					"liveChatId": "KicKGFVDMldZQjNOeFZERDBtZi1qTUw4cUdBQRILeGRBYWs0RG1LUEk"
				},
				"status": {
					"lifeCycleStatus": "created",
					"privacyStatus": "unlisted",
					"recordingStatus": "notRecording",
					"madeForKids": false,
					"selfDeclaredMadeForKids": false
				},
				"contentDetails": {
					"monitorStream": {
					"enableMonitorStream": true,
					"broadcastStreamDelayMs": 0,
					"embedHtml": "\u003ciframe width=\"425\" height=\"344\" src=\"https://www.youtube.com/embed/xdAak4DmKPI?autoplay=1&livemonitor=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003e\u003c/iframe\u003e"
					},
					"enableEmbed": true,
					"enableDvr": true,
					"enableContentEncryption": true,
					"startWithSlate": true,
					"recordFromStart": true,
					"enableClosedCaptions": true,
					"closedCaptionsType": "closedCaptionsHttpPost",
					"enableLowLatency": false,
					"latencyPreference": "normal",
					"projection": "rectangular",
					"enableAutoStart": false,
					"enableAutoStop": false
				}
			}
			*/

			Json::Value responseRoot;
			{
				Json::CharReaderBuilder builder;                                  
				Json::CharReader* reader = builder.newCharReader();               
				string errors;                                                    

				bool parsingSuccessful = reader->parse(                           
					sResponse.c_str(),                             
					sResponse.c_str() + sResponse.size(),
					&responseRoot, &errors);                      
				delete reader;

				if (!parsingSuccessful)                                           
				{
					string errorMessage = __FILEREF__ + "failed to parse the YouTube response"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", errors: " + errors
						+ ", sResponse: " + sResponse
					;
					_logger->error(errorMessage);

					throw runtime_error(errors);
				}
			}

			string field = "id";
			if (!JSONUtils::isMetadataPresent(responseRoot, field))
			{
				string errorMessage = __FILEREF__ + "YouTube response, Field is not present or it is null"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field
					+ ", sResponse: " + sResponse;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
            broadcastId = responseRoot.get(field, "").asString();

			sResponse = "";
		}
		catch(runtime_error e)
		{
			string errorMessage = string("YouTube live broadcast management failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", sResponse: " + sResponse
				+ ", e.what(): " + e.what()
			;
			_logger->error(__FILEREF__ + errorMessage);

			throw runtime_error(errorMessage);
		}
		catch(exception e)
		{
			string errorMessage = string("YouTube live broadcast management failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", sResponse: " + sResponse
			;
			_logger->error(__FILEREF__ + errorMessage);

			throw runtime_error(errorMessage);
		}

		string streamId;
		string rtmpURL;

		// second call, create the Live Stream
		try
		{
			/*
			* curl -v --request POST \
				'https://youtube.googleapis.com/youtube/v3/liveStreams?part=snippet%2Ccdn%2CcontentDetails%2Cstatus' \
				--header 'Authorization: Bearer ya29.a0ARrdaM9t2WqGKTgB9rZtoZU4oUCnW96Pe8qmgdk6ryYxEEe21T9WXWr8Eai1HX3AzG9zdOAEzRm8T6MhBmuQEDj4C5iDmfhRVjmUakhCKbZ7mWmqLOP9M6t5gha1QsH5ocNKqAZkhbCnWK0euQxGoK79MBjA' \
				--header 'Accept: application/json' \
				--header 'Content-Type: application/json' \
				--data '{"snippet":{"title":"my new video stream name","description":"A description of your video stream. This field is optional."},"cdn":{"frameRate":"60fps","ingestionType":"rtmp","resolution":"1080p"},"contentDetails":{"isReusable":true}}' \
				--compressed
			*/
			youTubeURL = _youTubeDataAPIProtocol
				+ "://"
				+ _youTubeDataAPIHostName
				+ ":" + to_string(_youTubeDataAPIPort)
				+ _youTubeDataAPILiveStreamURI;

			string body;
			{
				Json::Value bodyRoot;

				{
					Json::Value snippetRoot;

					string field = "title";
					snippetRoot[field] = youTubeLiveBroadcastTitle;

					if (youTubeLiveBroadcastDescription != "")
					{
						field = "description";
						snippetRoot[field] = youTubeLiveBroadcastDescription;
					}

					if (streamConfigurationLabel != "")
					{
						field = "channelId";
						snippetRoot[field] = streamConfigurationLabel;
					}

					field = "snippet";
					bodyRoot[field] = snippetRoot;
				}
               
				{
					Json::Value cdnRoot;

					string field = "frameRate";
					cdnRoot[field] = "variable";

					field = "ingestionType";
					cdnRoot[field] = "rtmp";

					field = "resolution";
					cdnRoot[field] = "variable";

					field = "cdn";
					bodyRoot[field] = cdnRoot;
				}
				{
					Json::Value contentDetailsRoot;

					bool isReusable = true;
					string field = "isReusable";
					contentDetailsRoot[field] = isReusable;

					field = "contentDetails";
					bodyRoot[field] = contentDetailsRoot;
				}

				{
					Json::StreamWriterBuilder wbuilder;
                   
					body = Json::writeString(wbuilder, bodyRoot);
				}
			}

			list<string> headerList;

			{
				string header = "Authorization: Bearer " + youTubeAccessToken;
				headerList.push_back(header);

                header = "Content-Length: " + to_string(body.length());
                headerList.push_back(header);

				header = "Accept: application/json";
				headerList.push_back(header);

				header = "Content-Type: application/json";
				headerList.push_back(header);
			}                    

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			request.setOpt(new curlpp::options::PostFields(body));
			request.setOpt(new curlpp::options::PostFieldSize(body.length()));

			request.setOpt(new curlpp::options::Url(youTubeURL));
			request.setOpt(new curlpp::options::Timeout(_youTubeDataAPITimeoutInSeconds));

			if (_youTubeDataAPIProtocol == "https")
			{
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
				// typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
				// typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;

				// cert is stored PEM coded in file... 
				// since PEM is default, we needn't set it for PEM 
				// curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
				// curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
				// equest.setOpt(sslCertType);

				// set the cert for client authentication
				// "testcert.pem"
				// curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
				// curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
				// request.setOpt(sslCert);

				// sorry, for engine we must set the passphrase
				//   (if the key has one...)
				// const char *pPassphrase = NULL;
				// if(pPassphrase)
				//  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

				// if we use a key stored in a crypto engine,
				//   we must set the key type to "ENG"
				// pKeyType  = "PEM";
				// curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

				// set the private key (file or ID in engine)
				// pKeyName  = "testkey.pem";
				// curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

				// set the file with the certs vaildating the server
				// *pCACertFile = "cacert.pem";
				// curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);

				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);

				// request.setOpt(new curlpp::options::SslEngineDefault());
			}
           
			for (string headerMessage: headerList)
				_logger->info(__FILEREF__ + "Adding header message: " + headerMessage);
			request.setOpt(new curlpp::options::HttpHeader(headerList));

			ostringstream response;
			request.setOpt(new curlpp::options::WriteStream(&response));

			// store response headers in the response
			// You simply have to set next option to prefix the header to the normal body output. 
			request.setOpt(new curlpp::options::Header(true)); 
           
			_logger->info(__FILEREF__ + "Calling youTube (live stream)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", body: " + body
			);
			request.perform();

			long responseCode = curlpp::infos::ResponseCode::get(request);

			_logger->info(__FILEREF__ + "Called youTube (live stream)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", responseCode: " + to_string(responseCode)
			);

			if (responseCode != 200)
			{
				string errorMessage = __FILEREF__ + "youTube (live stream) failed"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
					+ ", responseCode: " + to_string(responseCode)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			string sCompleteResponse = response.str();
			size_t beginOfBodyIndex;
			if ((beginOfBodyIndex = sCompleteResponse.find("\r\n\r\n")) == string::npos)
			{
				string errorMessage = __FILEREF__ + "youTube response is wrong (live stream)"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
					+ ", responseCode: " + to_string(responseCode)
					+ ", sCompleteResponse: " + sCompleteResponse
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			sResponse = sCompleteResponse.substr(beginOfBodyIndex + 4);
			_logger->info(__FILEREF__ + "Called youTube (live stream)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				// + ", body: " + body
				+ ", responseCode: " + to_string(responseCode)
				+ ", sCompleteResponse: " + sCompleteResponse
				// + ", sResponse: " + sResponse
			);

			/* sResponse:
			HTTP/2 200 
			content-type: application/json; charset=UTF-8
			vary: Origin
			vary: X-Origin
			vary: Referer
			content-encoding: gzip
			date: Sat, 20 Nov 2021 11:19:49 GMT
			server: scaffolding on HTTPServer2
			cache-control: private
			content-length: 858
			x-xss-protection: 0
			x-frame-options: SAMEORIGIN
			x-content-type-options: nosniff
			alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"

			{
				"kind": "youtube#liveStream",
				"etag": "MYZZfdTjQds1ghPCh_jyIjtsT9c",
				"id": "2WYB3NxVDD0mf-jML8qGAA1637335849431228",
				"snippet": {
					"publishedAt": "2021-11-19T15:30:49Z",
					"channelId": "UC2WYB3NxVDD0mf-jML8qGAA",
					"title": "my new video stream name",
					"description": "A description of your video stream. This field is optional.",
					"isDefaultStream": false
				},
				"cdn": {
					"ingestionType": "rtmp",
					"ingestionInfo": {
						"streamName": "py80-04jp-6jq3-eq29-407j",
						"ingestionAddress": "rtmp://a.rtmp.youtube.com/live2",
						"backupIngestionAddress": "rtmp://b.rtmp.youtube.com/live2?backup=1",
						"rtmpsIngestionAddress": "rtmps://a.rtmps.youtube.com/live2",
						"rtmpsBackupIngestionAddress": "rtmps://b.rtmps.youtube.com/live2?backup=1"
					},
					"resolution": "1080p",
					"frameRate": "60fps"
				},
				"status": {
					"streamStatus": "ready",
					"healthStatus": {
						"status": "noData"
					}
				},
				"contentDetails": {
					"closedCaptionsIngestionUrl": "http://upload.youtube.com/closedcaption?cid=py80-04jp-6jq3-eq29-407j",
					"isReusable": true
				}
			}
			*/

			Json::Value responseRoot;
			{
				Json::CharReaderBuilder builder;                                  
				Json::CharReader* reader = builder.newCharReader();               
				string errors;                                                    

				bool parsingSuccessful = reader->parse(                           
					sResponse.c_str(),                             
					sResponse.c_str() + sResponse.size(),
					&responseRoot, &errors);                      
				delete reader;

				if (!parsingSuccessful)                                           
				{
					string errorMessage = __FILEREF__ + "failed to parse the YouTube response"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", errors: " + errors
						+ ", sResponse: " + sResponse
					;
					_logger->error(errorMessage);

					throw runtime_error(errors);
				}
			}

			string field = "id";
			if (!JSONUtils::isMetadataPresent(responseRoot, field))
			{
				string errorMessage = __FILEREF__ + "YouTube response, Field is not present or it is null"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field
					+ ", sResponse: " + sResponse;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			streamId = responseRoot.get(field, "").asString();

			field = "cdn";
			if (!JSONUtils::isMetadataPresent(responseRoot, field))
			{
				string errorMessage = __FILEREF__ + "YouTube response, Field is not present or it is null"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field
					+ ", sResponse: " + sResponse;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			Json::Value cdnRoot = responseRoot[field];

			field = "ingestionInfo";
			if (!JSONUtils::isMetadataPresent(cdnRoot, field))
			{
				string errorMessage = __FILEREF__ + "YouTube response, Field is not present or it is null"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field
					+ ", sResponse: " + sResponse;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			Json::Value ingestionInfoRoot = cdnRoot[field];

			field = "streamName";
			if (!JSONUtils::isMetadataPresent(ingestionInfoRoot, field))
			{
				string errorMessage = __FILEREF__ + "YouTube response, Field is not present or it is null"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field
					+ ", sResponse: " + sResponse;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			string streamName = ingestionInfoRoot.get(field, "").asString();

			field = "ingestionAddress";
			if (!JSONUtils::isMetadataPresent(ingestionInfoRoot, field))
			{
				string errorMessage = __FILEREF__ + "YouTube response, Field is not present or it is null"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + field
					+ ", sResponse: " + sResponse;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			string ingestionAddress = ingestionInfoRoot.get(field, "").asString();

			rtmpURL = ingestionAddress + "/" + streamName;

			sResponse = "";
		}
		catch(runtime_error e)
		{
			string errorMessage = string("YouTube live stream management failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", sResponse: " + sResponse
				+ ", e.what(): " + e.what()
			;
			_logger->error(__FILEREF__ + errorMessage);

			throw runtime_error(errorMessage);
		}
		catch(exception e)
		{
			string errorMessage = string("YouTube live stream management failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", sResponse: " + sResponse
			;
			_logger->error(__FILEREF__ + errorMessage);

			throw runtime_error(errorMessage);
		}

		// third call, bind live broadcast - live stream
		try
		{
			/*
			* curl -v --request POST \
				'https://youtube.googleapis.com/youtube/v3/liveBroadcasts/bind?id=xdAak4DmKPI&part=snippet&streamId=2WYB3NxVDD0mf-jML8qGAA1637335849431228' \
				--header 'Authorization: Bearer ya29.a0ARrdaM9t2WqGKTgB9rZtoZU4oUCnW96Pe8qmgdk6ryYxEEe21T9WXWr8Eai1HX3AzG9zdOAEzRm8T6MhBmuQEDj4C5iDmfhRVjmUakhCKbZ7mWmqLOP9M6t5gha1QsH5ocNKqAZkhbCnWK0euQxGoK79MBjA' \
				--header 'Accept: application/json' \
				--compressed
			*/
			string youTubeDataAPILiveBroadcastBindURI =
				regex_replace(_youTubeDataAPILiveBroadcastBindURI, regex("__BROADCASTID__"), broadcastId);
			youTubeDataAPILiveBroadcastBindURI =
				regex_replace(youTubeDataAPILiveBroadcastBindURI, regex("__STREAMID__"), streamId);

			youTubeURL = _youTubeDataAPIProtocol
				+ "://"
				+ _youTubeDataAPIHostName
				+ ":" + to_string(_youTubeDataAPIPort)
				+ youTubeDataAPILiveBroadcastBindURI;

			list<string> headerList;

			{
				string header = "Authorization: Bearer " + youTubeAccessToken;
				headerList.push_back(header);

                // header = "Content-Length: " + to_string(body.length());
                // headerList.push_back(header);

				header = "Accept: application/json";
				headerList.push_back(header);

				// header = "Content-Type: application/json";
				// headerList.push_back(header);
			}                    

			string body;

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			request.setOpt(new curlpp::options::PostFields(body));
			request.setOpt(new curlpp::options::PostFieldSize(body.length()));

			request.setOpt(new curlpp::options::Url(youTubeURL));
			request.setOpt(new curlpp::options::Timeout(_youTubeDataAPITimeoutInSeconds));

			if (_youTubeDataAPIProtocol == "https")
			{
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
				// typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
				// typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;

				// cert is stored PEM coded in file... 
				// since PEM is default, we needn't set it for PEM 
				// curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
				// curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
				// equest.setOpt(sslCertType);

				// set the cert for client authentication
				// "testcert.pem"
				// curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
				// curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
				// request.setOpt(sslCert);

				// sorry, for engine we must set the passphrase
				//   (if the key has one...)
				// const char *pPassphrase = NULL;
				// if(pPassphrase)
				//  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

				// if we use a key stored in a crypto engine,
				//   we must set the key type to "ENG"
				// pKeyType  = "PEM";
				// curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

				// set the private key (file or ID in engine)
				// pKeyName  = "testkey.pem";
				// curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

				// set the file with the certs vaildating the server
				// *pCACertFile = "cacert.pem";
				// curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);

				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);

				// request.setOpt(new curlpp::options::SslEngineDefault());
			}
           
			for (string headerMessage: headerList)
				_logger->info(__FILEREF__ + "Adding header message: " + headerMessage);
			request.setOpt(new curlpp::options::HttpHeader(headerList));

			ostringstream response;
			request.setOpt(new curlpp::options::WriteStream(&response));

			// store response headers in the response
			// You simply have to set next option to prefix the header to the normal body output. 
			request.setOpt(new curlpp::options::Header(true)); 
           
			_logger->info(__FILEREF__ + "Calling youTube (live broadcast bind)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				// + ", body: " + body
			);
			request.perform();

			long responseCode = curlpp::infos::ResponseCode::get(request);
			string sCompleteResponse = response.str();

			_logger->info(__FILEREF__ + "Called youTube (live broadcast bind)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", responseCode: " + to_string(responseCode)
				+ ", sCompleteResponse: " + sCompleteResponse
			);

			if (responseCode != 200)
			{
				string errorMessage = __FILEREF__ + "youTube (live broadcast bind) failed"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
					+ ", responseCode: " + to_string(responseCode)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			size_t beginOfBodyIndex;
			if ((beginOfBodyIndex = sCompleteResponse.find("\r\n\r\n")) == string::npos)
			{
				string errorMessage = __FILEREF__ + "youTube response is wrong (live broadcast bind)"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
					+ ", responseCode: " + to_string(responseCode)
					+ ", sCompleteResponse: " + sCompleteResponse
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			sResponse = sCompleteResponse.substr(beginOfBodyIndex + 4);
			_logger->info(__FILEREF__ + "Called youTube (live broadcast bind)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				// + ", body: " + body
				+ ", responseCode: " + to_string(responseCode)
				+ ", sCompleteResponse: " + sCompleteResponse
				// + ", sResponse: " + sResponse
			);

			/* sResponse:
			HTTP/2 200 ^M
			content-type: application/json; charset=UTF-8^M
			vary: X-Origin^M
			vary: Referer^M
			vary: Origin,Accept-Encoding^M
			date: Wed, 24 Nov 2021 22:35:48 GMT^M
			server: scaffolding on HTTPServer2^M
			cache-control: private^M
			x-xss-protection: 0^M
			x-frame-options: SAMEORIGIN^M
			x-content-type-options: nosniff^M
			accept-ranges: none^M
			alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"^M
			^M
			{
			"kind": "youtube#liveBroadcast",
			"etag": "1NM7pffpR8009CHTdckGzn0rN-o",
			"id": "tP_L5RKFrQM",
			"snippet": {
				"publishedAt": "2021-11-24T22:35:46Z",
				"channelId": "UC2WYB3NxVDD0mf-jML8qGAA",
				"title": "test",
				"description": "",
				"thumbnails": {
				"default": {
					"url": "https://i.ytimg.com/vi/tP_L5RKFrQM/default_live.jpg",
					"width": 120,
					"height": 90
				},
				"medium": {
					"url": "https://i.ytimg.com/vi/tP_L5RKFrQM/mqdefault_live.jpg",
					"width": 320,
					"height": 180
				},
				"high": {
					"url": "https://i.ytimg.com/vi/tP_L5RKFrQM/hqdefault_live.jpg",
					"width": 480,
					"height": 360
				},
				"standard": {
					"url": "https://i.ytimg.com/vi/tP_L5RKFrQM/sddefault_live.jpg",
					"width": 640,
					"height": 480
				}
				},
				"scheduledStartTime": "2021-11-24T22:25:00Z",
				"scheduledEndTime": "2021-11-24T22:50:00Z",
				"isDefaultBroadcast": false,
				"liveChatId": "KicKGFVDMldZQjNOeFZERDBtZi1qTUw4cUdBQRILdFBfTDVSS0ZyUU0"
			}
			}
			*/

			Json::Value responseRoot;
			{
				Json::CharReaderBuilder builder;                                  
				Json::CharReader* reader = builder.newCharReader();               
				string errors;                                                    

				bool parsingSuccessful = reader->parse(                           
					sResponse.c_str(),                             
					sResponse.c_str() + sResponse.size(),
					&responseRoot, &errors);                      
				delete reader;

				if (!parsingSuccessful)                                           
				{
					string errorMessage = __FILEREF__ + "failed to parse the YouTube response"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", errors: " + errors
						+ ", sResponse: " + sResponse
					;
					_logger->error(errorMessage);

					throw runtime_error(errors);
				}
			}
		}
		catch(runtime_error e)
		{
			string errorMessage = string("YouTube live stream management failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", sResponse: " + sResponse
				+ ", e.what(): " + e.what()
			;
			_logger->error(__FILEREF__ + errorMessage);

			throw runtime_error(errorMessage);
		}
		catch(exception e)
		{
			string errorMessage = string("YouTube live stream management failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", sResponse: " + sResponse
			;
			_logger->error(__FILEREF__ + errorMessage);

			throw runtime_error(errorMessage);
		}

		_logger->info(__FILEREF__ + "Preparing workflow to ingest..."
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		);

		Json::Value youTubeLiveBroadcastOnSuccess = Json::nullValue;
		Json::Value youTubeLiveBroadcastOnError = Json::nullValue;
		Json::Value youTubeLiveBroadcastOnComplete = Json::nullValue;
		int64_t userKey;
		string apiKey;
		{
			string field = "internalMMS";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				Json::Value internalMMSRoot = parametersRoot[field];

				field = "credentials";
				if (JSONUtils::isMetadataPresent(internalMMSRoot, field))
				{
					Json::Value credentialsRoot = internalMMSRoot[field];

					field = "userKey";
					userKey = JSONUtils::asInt64(credentialsRoot, field, -1);

					field = "apiKey";
					string apiKeyEncrypted = credentialsRoot.get(field, "").asString();
					apiKey = Encrypt::opensslDecrypt(apiKeyEncrypted);
				}

				field = "events";
				if (JSONUtils::isMetadataPresent(internalMMSRoot, field))
				{
					Json::Value eventsRoot = internalMMSRoot[field];

					field = "OnSuccess";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						youTubeLiveBroadcastOnSuccess = eventsRoot[field];

					field = "OnError";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						youTubeLiveBroadcastOnError = eventsRoot[field];

					field = "OnComplete";
					if (JSONUtils::isMetadataPresent(eventsRoot, field))
						youTubeLiveBroadcastOnComplete = eventsRoot[field];
				}
			}
		}

		// create workflow to ingest
		string workflowMetadata;
		{
			string proxyLabel;
			Json::Value proxyRoot;

			if (sourceType == "Live")
			{
				Json::Value liveProxyParametersRoot;
				{
					string field = "Label";
					proxyLabel = "Proxy " + streamConfigurationLabel
						+ " to YouTube (" + youTubeConfigurationLabel + ")";
					proxyRoot[field] = proxyLabel;

					field = "Type";
					proxyRoot[field] = "Live-Proxy";

					liveProxyParametersRoot = parametersRoot;
					{
						Json::Value removed;
						field = "YouTubeConfigurationLabel";
						liveProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "Title";
						liveProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "Description";
						liveProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "SourceType";
						liveProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "internalMMS";
						if (JSONUtils::isMetadataPresent(liveProxyParametersRoot, field))
							liveProxyParametersRoot.removeMember(field, &removed);
					}

					bool timePeriod = true;
					field = "TimePeriod";
					liveProxyParametersRoot[field] = timePeriod;

					Json::Value outputsRoot(Json::arrayValue);
					{
						Json::Value outputRoot;

						field = "OutputType";
						outputRoot[field] = "RTMP_Stream";

						field = "RtmpUrl";
						outputRoot[field] = rtmpURL;

						outputsRoot.append(outputRoot);
					}
					field = "Outputs";
					liveProxyParametersRoot[field] = outputsRoot;
				}
				string field = "Parameters";
				proxyRoot[field] = liveProxyParametersRoot;
			}
			else // if (sourceType == "MediaItem")
			{
				Json::Value vodProxyParametersRoot;
				{
					string field = "Label";
					proxyLabel = "Proxy MediaItem to YouTube (" + youTubeConfigurationLabel + ")";
					proxyRoot[field] = proxyLabel;

					field = "Type";
					proxyRoot[field] = "VOD-Proxy";

					vodProxyParametersRoot = parametersRoot;
					{
						Json::Value removed;
						field = "YouTubeConfigurationLabel";
						vodProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "Title";
						vodProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "Description";
						vodProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "SourceType";
						vodProxyParametersRoot.removeMember(field, &removed);
					}
					{
						Json::Value removed;
						field = "internalMMS";
						if (JSONUtils::isMetadataPresent(vodProxyParametersRoot, field))
							vodProxyParametersRoot.removeMember(field, &removed);
					}

					field = "References";
					vodProxyParametersRoot[field] = referencesRoot;

					bool timePeriod = true;
					field = "TimePeriod";
					vodProxyParametersRoot[field] = timePeriod;

					Json::Value outputsRoot(Json::arrayValue);
					{
						Json::Value outputRoot;

						field = "OutputType";
						outputRoot[field] = "RTMP_Stream";

						field = "RtmpUrl";
						outputRoot[field] = rtmpURL;

						outputsRoot.append(outputRoot);
					}
					field = "Outputs";
					vodProxyParametersRoot[field] = outputsRoot;
				}
				string field = "Parameters";
				proxyRoot[field] = vodProxyParametersRoot;
			}

			Json::Value workflowRoot;
			{
				string field = "Label";
				workflowRoot[field] = ingestionJobLabel + ". " + proxyLabel;

				field = "Type";
				workflowRoot[field] = "Workflow";

				field = "Task";
				workflowRoot[field] = proxyRoot;
			}

			{
				Json::StreamWriterBuilder wbuilder;
				workflowMetadata = Json::writeString(wbuilder, workflowRoot);
			}
		}

		MMSCURL::httpPostPutString(                                                        
			ingestionJobKey,                                                                                  
			_mmsWorkflowIngestionURL,                                                                                        
			"POST", // requestType                                                                            
			_mmsAPITimeoutInSeconds,                                                                          
			to_string(userKey),                                                                               
			apiKey,                                                                                           
			workflowMetadata,                                                                                 
			"application/json", // contentType                                                                
			_logger                                                                                           
		);                                                                                                    

		/*
		{
			string mmsAPIURL =
				_mmsAPIProtocol
				+ "://"
				+ _mmsAPIHostname + ":"
				+ to_string(_mmsAPIPort)
				+ "/catramms/"
				+ _mmsAPIVersion
				+ _mmsAPIIngestionURI
            ;

			list<string> header;

			header.push_back("Content-Type: application/json");
			{
				// string userPasswordEncoded = Convert::base64_encode(_mmsAPIUser + ":" + _mmsAPIPassword);
				string userPasswordEncoded = Convert::base64_encode(to_string(userKey) + ":" + apiKey);
				string basicAuthorization = string("Authorization: Basic ") + userPasswordEncoded;

				header.push_back(basicAuthorization);
			}

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			// Setting the URL to retrive.
			request.setOpt(new curlpp::options::Url(mmsAPIURL));

			// timeout consistent with nginx configuration (fastcgi_read_timeout)
			request.setOpt(new curlpp::options::Timeout(_mmsAPITimeoutInSeconds));

			if (_mmsAPIProtocol == "https")
			{
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
				// typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
				// typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
				// typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;

				// cert is stored PEM coded in file... 
				// since PEM is default, we needn't set it for PEM 
				// curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
				// curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
				// equest.setOpt(sslCertType);

				// set the cert for client authentication
				// "testcert.pem"
				// curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
				// curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
				// request.setOpt(sslCert);

				// sorry, for engine we must set the passphrase
				//   (if the key has one...)
				// const char *pPassphrase = NULL;
				// if(pPassphrase)
				//  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

				// if we use a key stored in a crypto engine,
				//   we must set the key type to "ENG"
				// pKeyType  = "PEM";
				// curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

				// set the private key (file or ID in engine)
				// pKeyName  = "testkey.pem";
				// curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

				// set the file with the certs vaildating the server
				// *pCACertFile = "cacert.pem";
				// curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);
               
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);

				// request.setOpt(new curlpp::options::SslEngineDefault());
			}

			request.setOpt(new curlpp::options::HttpHeader(header));
			request.setOpt(new curlpp::options::PostFields(workflowMetadata));
			request.setOpt(new curlpp::options::PostFieldSize(workflowMetadata.length()));

			ostringstream response;

			request.setOpt(new curlpp::options::WriteStream(&response));

			_logger->info(__FILEREF__ + "Ingesting YouTube Live Broadcast workflow"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
				+ ", mmsAPIURL: " + mmsAPIURL
				+ ", workflowMetadata: " + workflowMetadata
			);
			chrono::system_clock::time_point startIngesting = chrono::system_clock::now();
			request.perform();
			chrono::system_clock::time_point endIngesting = chrono::system_clock::now();

			string sResponse = response.str();
			// LF and CR create problems to the json parser...
			while (sResponse.size() > 0 && (sResponse.back() == 10 || sResponse.back() == 13))
				sResponse.pop_back();

			long responseCode = curlpp::infos::ResponseCode::get(request);
			if (responseCode == 201)
			{
				string message = __FILEREF__ + "Ingested CutLive workflow response"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", @MMS statistics@ - ingestingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endIngesting - startIngesting).count()) + "@"
					+ ", workflowMetadata: " + workflowMetadata
					+ ", sResponse: " + sResponse
					;
				_logger->info(message);
			}
			else
			{
				string message = __FILEREF__ + "Ingested YouTube Live Broadcast workflow response"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", @MMS statistics@ - ingestingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endIngesting - startIngesting).count()) + "@"
					+ ", workflowMetadata: " + workflowMetadata
					+ ", sResponse: " + sResponse
					+ ", responseCode: " + to_string(responseCode)
					;
				_logger->error(message);

				throw runtime_error(message);
			}
		}
		*/

        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_TaskSuccess"
            + ", errorMessage: " + ""
        );
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
        );
	}
	catch(runtime_error e)
	{
        _logger->error(__FILEREF__ + "youTubeLiveBroadcastThread failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
 
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		return;
        // throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "youTubeLiveBroadcastThread failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}

		return;
        // throw e;
    }
}

void MMSEngineProcessor::copyContent(
	int64_t ingestionJobKey, string mmsAssetPathName, string localPath, string localFileName)
{

    try 
    {
		_logger->info(__FILEREF__ + "copyContent"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		);

        string localPathName = localPath;
        if (localFileName != "")
        {
			string cleanedFileName;
			{
				cleanedFileName.resize(localFileName.size());
				transform(localFileName.begin(), localFileName.end(), cleanedFileName.begin(),
					[](unsigned char c)
						{
							if(c == '/'
								)
								return (int) ' ';
							else
								return (int) c;
						}
				);

				string fileFormat;
				{
					size_t extensionIndex = mmsAssetPathName.find_last_of(".");
					if (extensionIndex == string::npos)
					{
						string errorMessage = __FILEREF__ +
							"No fileFormat (extension of the file) found in mmsAssetPathName"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", mmsAssetPathName: " + mmsAssetPathName
						;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}
					fileFormat = mmsAssetPathName.substr(extensionIndex + 1);
				}

				string suffix = "." + fileFormat;
				if (cleanedFileName.size() >= suffix.size()
					&& 0 == cleanedFileName.compare(cleanedFileName.size()-suffix.size(),
						suffix.size(), suffix))
					;
				else
					cleanedFileName += suffix;

				string prefix = "MMS ";
				cleanedFileName = prefix + cleanedFileName;
			}

            if (localPathName.back() != '/')
                localPathName += "/";
            localPathName += cleanedFileName;
        }

        _logger->info(__FILEREF__ + "Coping"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", mmsAssetPathName: " + mmsAssetPathName
            + ", localPath: " + localPath
            + ", localFileName: " + localFileName
            + ", localPathName: " + localPathName
        );

        FileIO::copyFile(mmsAssetPathName, localPathName);
    }
    catch (runtime_error& e) 
    {
		string errorMessage = __FILEREF__ + "Coping failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", mmsAssetPathName: " + mmsAssetPathName 
            + ", localPath: " + localPath
            + ", localFileName: " + localFileName
            + ", exception: " + e.what()
        ;
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
    catch (exception e)
    {
		string errorMessage = __FILEREF__ + "Coping failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", mmsAssetPathName: " + mmsAssetPathName 
            + ", localPath: " + localPath
            + ", localFileName: " + localFileName
            + ", exception: " + e.what()
        ;
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
}

void MMSEngineProcessor::handleMultiLocalAssetIngestionEventThread (
		shared_ptr<long> processorsThreadsNumber,
    MultiLocalAssetIngestionEvent multiLocalAssetIngestionEvent)
{

	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"handleMultiLocalAssetIngestionEventThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		multiLocalAssetIngestionEvent.getIngestionJobKey());

    string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(
            multiLocalAssetIngestionEvent.getWorkspace());
    vector<string> generatedFramesFileNames;
    
    try
    {
		_logger->info(__FILEREF__ + "handleMultiLocalAssetIngestionEventThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        // get files from file system       
        {
            string generatedFrames_BaseFileName = to_string(multiLocalAssetIngestionEvent.getIngestionJobKey());

            FileIO::DirectoryEntryType_t detDirectoryEntryType;
            shared_ptr<FileIO::Directory> directory = FileIO::openDirectory (workspaceIngestionRepository + "/");

            bool scanDirectoryFinished = false;
            while (!scanDirectoryFinished)
            {
                string directoryEntry;
                try
                {
                    string directoryEntry = FileIO::readDirectory (directory,
                        &detDirectoryEntryType);

                    if (detDirectoryEntryType != FileIO::TOOLS_FILEIO_REGULARFILE)
                        continue;

                    if (directoryEntry.size() >= generatedFrames_BaseFileName.size() && 0 == directoryEntry.compare(0, generatedFrames_BaseFileName.size(), generatedFrames_BaseFileName))
                        generatedFramesFileNames.push_back(directoryEntry);
                }
                catch(DirectoryListFinished e)
                {
                    scanDirectoryFinished = true;
                }
                catch(runtime_error e)
                {
                    string errorMessage = __FILEREF__ + "listing directory failed"
                           + ", e.what(): " + e.what()
                    ;
                    _logger->error(errorMessage);

                    throw e;
                }
                catch(exception e)
                {
                    string errorMessage = __FILEREF__ + "listing directory failed"
                           + ", e.what(): " + e.what()
                    ;
                    _logger->error(errorMessage);

                    throw e;
                }
            }

            FileIO::closeDirectory (directory);
        }
           
        // we have one ingestion job row and one or more generated frames to be ingested
        // One MIK in case of a .mjpeg
        // One or more MIKs in case of .jpg
        // We want to update the ingestion row just once at the end,
        // in case of success or when an error happens.
        // To do this we will add a field in the localAssetIngestionEvent structure (ingestionRowToBeUpdatedAsSuccess)
        // and we will set it to false except for the last frame where we will set to true
        // In case of error, handleLocalAssetIngestionEvent will update ingestion row
        // and we will not call anymore handleLocalAssetIngestionEvent for the next frames
        // When I say 'update the ingestion row', it's not just the update but it is also
        // manageIngestionJobStatusUpdate
        bool generatedFrameIngestionFailed = false;

        for(vector<string>::iterator it = generatedFramesFileNames.begin(); 
                it != generatedFramesFileNames.end(); ++it) 
        {
            string generatedFrameFileName = *it;

            if (generatedFrameIngestionFailed)
            {
                string workspaceIngestionBinaryPathName = workspaceIngestionRepository 
                        + "/"
                        + generatedFrameFileName
                        ;

                _logger->info(__FILEREF__ + "Remove file"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
                    + ", workspaceIngestionBinaryPathName: " + workspaceIngestionBinaryPathName
                );
                FileIO::remove(workspaceIngestionBinaryPathName);
            }
            else
            {
                _logger->info(__FILEREF__ + "Generated Frame to ingest"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
                    + ", generatedFrameFileName: " + generatedFrameFileName
                    // + ", textToBeReplaced: " + textToBeReplaced
                    // + ", textToReplace: " + textToReplace
                );

                string fileFormat;
                size_t extensionIndex = generatedFrameFileName.find_last_of(".");
                if (extensionIndex == string::npos)
                {
                    string errorMessage = __FILEREF__ + "No fileFormat (extension of the file) found in generatedFileName"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
                            + ", generatedFrameFileName: " + generatedFrameFileName
                    ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
                fileFormat = generatedFrameFileName.substr(extensionIndex + 1);

    //            if (mmsSourceFileName.find(textToBeReplaced) != string::npos)
    //                mmsSourceFileName.replace(mmsSourceFileName.find(textToBeReplaced), textToBeReplaced.length(), textToReplace);

                _logger->info(__FILEREF__ + "Generated Frame to ingest"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
                    + ", new generatedFrameFileName: " + generatedFrameFileName
                    + ", fileFormat: " + fileFormat
                );

                string title;
                {
                    string field = "Title";
                    if (JSONUtils::isMetadataPresent(multiLocalAssetIngestionEvent.getParametersRoot(), field))
                        title = multiLocalAssetIngestionEvent.getParametersRoot().get(field, "XXX").asString();                    
                    title += (
                            " (" 
                            + to_string(it - generatedFramesFileNames.begin() + 1) 
                            + " / "
                            + to_string(generatedFramesFileNames.size())
                            + ")"
                            );
                }
				int64_t imageOfVideoMediaItemKey = -1;
				int64_t cutOfVideoMediaItemKey = -1;
				int64_t cutOfAudioMediaItemKey = -1;
				double startTimeInSeconds = 0.0;
				double endTimeInSeconds = 0.0;
                string imageMetaDataContent = generateMediaMetadataToIngest(
                        multiLocalAssetIngestionEvent.getIngestionJobKey(),
                        // mjpeg,
                        fileFormat,
                        title,
						imageOfVideoMediaItemKey,
						cutOfVideoMediaItemKey, cutOfAudioMediaItemKey, startTimeInSeconds, endTimeInSeconds,
                        multiLocalAssetIngestionEvent.getParametersRoot()
                );

                {
                    // shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent = _multiEventsSet->getEventsFactory()
                    //        ->getFreeEvent<LocalAssetIngestionEvent>(MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);
                    shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent 
                            = make_shared<LocalAssetIngestionEvent>();

                    localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
                    localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
                    localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

					localAssetIngestionEvent->setExternalReadOnlyStorage(false);
                    localAssetIngestionEvent->setIngestionJobKey(multiLocalAssetIngestionEvent.getIngestionJobKey());
                    localAssetIngestionEvent->setIngestionSourceFileName(generatedFrameFileName);
                    localAssetIngestionEvent->setMMSSourceFileName(generatedFrameFileName);
                    localAssetIngestionEvent->setWorkspace(multiLocalAssetIngestionEvent.getWorkspace());
                    localAssetIngestionEvent->setIngestionType(MMSEngineDBFacade::IngestionType::AddContent);
                    localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(
                        it + 1 == generatedFramesFileNames.end() ? true : false);

                    localAssetIngestionEvent->setMetadataContent(imageMetaDataContent);

                    try
                    {
                        handleLocalAssetIngestionEventThread (
							processorsThreadsNumber, *localAssetIngestionEvent);
                    }
                    catch(runtime_error e)
                    {
                        generatedFrameIngestionFailed = true;

                        _logger->error(__FILEREF__ + "handleLocalAssetIngestionEvent failed"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", exception: " + e.what()
                        );
                    }
                    catch(exception e)
                    {
                        generatedFrameIngestionFailed = true;

                        _logger->error(__FILEREF__ + "handleLocalAssetIngestionEvent failed"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", exception: " + e.what()
                        );
                    }

//                    shared_ptr<Event2>    event = dynamic_pointer_cast<Event2>(localAssetIngestionEvent);
//                    _multiEventsSet->addEvent(event);
//
//                    _logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (INGESTASSETEVENT)"
//                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
//                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
//                        + ", getEventKey().first: " + to_string(event->getEventKey().first)
//                        + ", getEventKey().second: " + to_string(event->getEventKey().second));
                }
            }
        }
        
        /*
        if (generatedFrameIngestionFailed)
        {
            _logger->info(__FILEREF__ + "updater->updateEncodingJob PunctualError"
                + ", _encodingItem->_encodingJobKey: " + to_string(multiLocalAssetIngestionEvent->getEncodingJobKey())
                + ", _encodingItem->_ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent->getIngestionJobKey())
            );

            int64_t mediaItemKey = -1;
            int64_t encodedPhysicalPathKey = -1;
            // PunctualError is used because, in case it always happens, the encoding will never reach a final state
            int encodingFailureNumber = updater->updateEncodingJob (
                    multiLocalAssetIngestionEvent->getEncodingJobKey(), 
                    MMSEngineDBFacade::EncodingError::PunctualError,    // ErrorBeforeEncoding, 
                    mediaItemKey, encodedPhysicalPathKey,
                    multiLocalAssetIngestionEvent->getIngestionJobKey());

            _logger->info(__FILEREF__ + "updater->updateEncodingJob PunctualError"
                + ", _encodingItem->_encodingJobKey: " + to_string(multiLocalAssetIngestionEvent->getEncodingJobKey())
                + ", _encodingItem->_ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent->getIngestionJobKey())
                + ", encodingFailureNumber: " + to_string(encodingFailureNumber)
            );
        }
        else
        {
            _logger->info(__FILEREF__ + "updater->updateEncodingJob NoError"
                + ", _encodingItem->_encodingJobKey: " + to_string(multiLocalAssetIngestionEvent->getEncodingJobKey())
                + ", _encodingItem->_ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent->getIngestionJobKey())
            );

            int64_t mediaItemKey = -1;
            int64_t encodedPhysicalPathKey = -1;
            updater->updateEncodingJob (
                multiLocalAssetIngestionEvent->getEncodingJobKey(), 
                MMSEngineDBFacade::EncodingError::NoError,
                mediaItemKey, encodedPhysicalPathKey,
                multiLocalAssetIngestionEvent->getIngestionJobKey());
        }
        */
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "handleMultiLocalAssetIngestionEvent failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (multiLocalAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_IngestionFailure,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        bool exceptionInCaseOfError = false;
        
        for(vector<string>::iterator it = generatedFramesFileNames.begin(); 
                it != generatedFramesFileNames.end(); ++it) 
        {
            string workspaceIngestionBinaryPathName = workspaceIngestionRepository + "/" + *it;
            
            _logger->info(__FILEREF__ + "Remove file"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
                + ", workspaceIngestionBinaryPathName: " + workspaceIngestionBinaryPathName
            );
            FileIO::remove(workspaceIngestionBinaryPathName, exceptionInCaseOfError);
        }
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "handleMultiLocalAssetIngestionEvent failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (multiLocalAssetIngestionEvent.getIngestionJobKey(),
				MMSEngineDBFacade::IngestionStatus::End_IngestionFailure,
				e.what()
			);
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
				+ ", errorMessage: " + ex.what()
				);
		}

        bool exceptionInCaseOfError = false;
        
        for(vector<string>::iterator it = generatedFramesFileNames.begin(); 
                it != generatedFramesFileNames.end(); ++it) 
        {
            string workspaceIngestionBinaryPathName = workspaceIngestionRepository + "/" + *it;
            
            _logger->info(__FILEREF__ + "Remove file"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(multiLocalAssetIngestionEvent.getIngestionJobKey())
                + ", workspaceIngestionBinaryPathName: " + workspaceIngestionBinaryPathName
            );
            FileIO::remove(workspaceIngestionBinaryPathName, exceptionInCaseOfError);
        }
        
        throw e;
    }
    
}

void MMSEngineProcessor::manageGenerateFramesTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        MMSEngineDBFacade::IngestionType ingestionType,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong number of dependencies"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::EncodingPriority encodingPriority;
        string field = "EncodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = 
                    static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority =
                MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
        }

		int64_t sourceMediaItemKey;
		int64_t sourcePhysicalPathKey;
		string sourcePhysicalPathName;
		string sourceFileName;
        {
			tuple<int64_t,MMSEngineDBFacade::ContentType,
				Validator::DependencyType, bool> keyAndDependencyType = dependencies[0];

			int64_t key;
			MMSEngineDBFacade::ContentType referenceContentType;
			Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (referenceContentType != MMSEngineDBFacade::ContentType::Video)
			{
				string errorMessage = __FILEREF__ + "ContentTpe is not a Video"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			if (dependencyType == Validator::DependencyType::MediaItemKey)
			{
				int64_t encodingProfileKey = -1;
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails
					= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey,
						warningIfMissing);
				tie(sourcePhysicalPathKey, sourcePhysicalPathName, ignore, ignore,
					sourceFileName, ignore, ignore) = physicalPathDetails;

				sourceMediaItemKey = key;
			}
			else
			{
				sourcePhysicalPathKey = key;

				tuple<string, int, string, string, int64_t, string>                                       
					physicalPathDetails = _mmsStorage->getPhysicalPathDetails(sourcePhysicalPathKey);                       
				tie(sourcePhysicalPathName, ignore, ignore, ignore, ignore, ignore)                       
					= physicalPathDetails;                                                                

				bool warningIfMissing = false;
				tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
						workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);
				tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore, sourceFileName, ignore)
						= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
			}
		}

        int periodInSeconds;
        double startTimeInSeconds;
        int maxFramesNumber;
        string videoFilter;
        bool mjpeg;
        int imageWidth;
        int imageHeight;
        int64_t durationInMilliSeconds;
        fillGenerateFramesParameters(
			workspace,
			ingestionJobKey,
			ingestionType,
			parametersRoot,
			sourceMediaItemKey, sourcePhysicalPathKey,

			periodInSeconds, startTimeInSeconds,
			maxFramesNumber, videoFilter,
			mjpeg, imageWidth, imageHeight,
			durationInMilliSeconds);

		// calculate delivery URL in case of an external encoder
		string sourcePhysicalDeliveryURL;
		{
			int64_t utcNow;
			{
				chrono::system_clock::time_point now = chrono::system_clock::now();
				utcNow = chrono::system_clock::to_time_t(now);
			}

			pair<string, string> deliveryAuthorizationDetails =
				_mmsDeliveryAuthorization->createDeliveryAuthorization(
				-1,	// userKey,
				workspace,
				"",	// clientIPAddress,

				-1,	// mediaItemKey,
				"",	// uniqueName,
				-1,	// encodingProfileKey,
				"",	// encodingProfileLabel,

				sourcePhysicalPathKey,

				-1,	// ingestionJobKey,	(in case of live)
				-1,	// deliveryCode,

				365 * 24 * 60 * 60,	// ttlInSeconds, 365 days!!!
				999999,	// maxRetries,
				false,	// save,
				"MMS_SignedToken",	// deliveryType,

				false,	// warningIfMissingMediaItemKey,
				true,	// filteredByStatistic
				""		// userId (it is not needed it filteredByStatistic is true
			);

			tie(sourcePhysicalDeliveryURL, ignore) = deliveryAuthorizationDetails;
		}

		string sourceTranscoderStagingAssetPathName;	// used in case of external encoder
		string transcoderStagingImagesDirectory;				// used in case of external encoder
		{
			bool removeLinuxPathIfExist = false;
			bool neededForTranscoder = true;
			sourceTranscoderStagingAssetPathName = _mmsStorage->getStagingAssetPathName(
				neededForTranscoder,
				workspace->_directoryName,	// workspaceDirectoryName
				to_string(ingestionJobKey),		// directoryNamePrefix
				"/",							// relativePath,
				sourceFileName,				// fileName
				-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
				-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
				removeLinuxPathIfExist);

			string directoryNameForFrames = 
				to_string(ingestionJobKey)
				// + "_"
				// + to_string(encodingProfileKey)
			;
			transcoderStagingImagesDirectory = _mmsStorage->getStagingAssetPathName(
				neededForTranscoder,
				workspace->_directoryName,	// workspaceDirectoryName
				to_string(ingestionJobKey),					// directoryNamePrefix
				"/",										// relativePath,
				directoryNameForFrames,
				-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
				-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
				removeLinuxPathIfExist);
		}

		string nfsImagesDirectory = _mmsStorage->getWorkspaceIngestionRepository(
                workspace);

		_mmsEngineDBFacade->addEncoding_GenerateFramesJob (
			workspace,
			ingestionJobKey, encodingPriority,
			nfsImagesDirectory,
			transcoderStagingImagesDirectory,		// used in case of external encoder
			sourcePhysicalDeliveryURL,				// used in case of external encoder
			sourceTranscoderStagingAssetPathName,	// used in case of external encoder
			sourcePhysicalPathName,
			sourcePhysicalPathKey,
			sourceFileName,
			durationInMilliSeconds,
			startTimeInSeconds, maxFramesNumber, 
			videoFilter, periodInSeconds, 
			mjpeg, imageWidth, imageHeight,
			_mmsWorkflowIngestionURL, _mmsBinaryIngestionURL, _mmsIngestionURL
		);
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageGenerateFramesTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageGenerateFramesTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::fillGenerateFramesParameters(
    shared_ptr<Workspace> workspace,
    int64_t ingestionJobKey,
    MMSEngineDBFacade::IngestionType ingestionType,
    Json::Value parametersRoot,
	int64_t sourceMediaItemKey, int64_t sourcePhysicalPathKey,
        
    int& periodInSeconds, double& startTimeInSeconds,
    int& maxFramesNumber, string& videoFilter,
    bool& mjpeg, int& imageWidth, int& imageHeight,
    int64_t& durationInMilliSeconds
)
{
    try
    {
        string field;
        
        periodInSeconds = -1;
		{
			if (ingestionType == MMSEngineDBFacade::IngestionType::Frame)
			{
			}
			else if (ingestionType == MMSEngineDBFacade::IngestionType::PeriodicalFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByPeriodicalFrames)
			{
				field = "PeriodInSeconds";
				if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				periodInSeconds = JSONUtils::asInt(parametersRoot, field, 0);
			}
			else // if (ingestionType == MMSEngineDBFacade::IngestionType::IFrames || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByIFrames)
			{

			}
		}
            
        startTimeInSeconds = 0;
		{
			if (ingestionType == MMSEngineDBFacade::IngestionType::Frame)
			{
				field = "InstantInSeconds";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					startTimeInSeconds = JSONUtils::asDouble(parametersRoot, field, 0);
				}
			}
			else if (ingestionType == MMSEngineDBFacade::IngestionType::PeriodicalFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::IFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByPeriodicalFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByIFrames)
			{
				field = "StartTimeInSeconds";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					startTimeInSeconds = JSONUtils::asDouble(parametersRoot, field, 0);
				}
			}
		}

        maxFramesNumber = -1;
		{
			if (ingestionType == MMSEngineDBFacade::IngestionType::Frame)
			{
				maxFramesNumber = 1;
			}
			else if (ingestionType == MMSEngineDBFacade::IngestionType::PeriodicalFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::IFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByPeriodicalFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByIFrames)
			{
				field = "MaxFramesNumber";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
				{
					maxFramesNumber = JSONUtils::asInt(parametersRoot, field, 0);
				}
			}
		}

		// 2021-09-14: default is set to true because often we have the error
		//	endTimeInSeconds is bigger of few milliseconds of the duration of the media
		//	For this reason this field is set to true by default
		bool fixStartTimeIfOvercomeDuration = true;
		if (JSONUtils::isMetadataPresent(parametersRoot, "FixInstantInSecondsIfOvercomeDuration"))
			fixStartTimeIfOvercomeDuration = JSONUtils::asBool(parametersRoot,
				"FixInstantInSecondsIfOvercomeDuration", true);
		else if (JSONUtils::isMetadataPresent(parametersRoot, "FixStartTimeIfOvercomeDuration"))
			fixStartTimeIfOvercomeDuration = JSONUtils::asBool(parametersRoot,
				"FixStartTimeIfOvercomeDuration", true);

		{
			if (ingestionType == MMSEngineDBFacade::IngestionType::Frame)
			{
			}
			else if (ingestionType == MMSEngineDBFacade::IngestionType::PeriodicalFrames)
			{
				videoFilter = "PeriodicFrame";
			}
			else if (ingestionType == MMSEngineDBFacade::IngestionType::IFrames)
			{
				videoFilter = "All-I-Frames";
			}
		}

		{
			if (ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByPeriodicalFrames
                || ingestionType == MMSEngineDBFacade::IngestionType::MotionJPEGByIFrames)
			{
				mjpeg = true;
			}
			else
			{
				mjpeg = false;
			}
		}

        int width = -1;
		{
			field = "Width";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				width = JSONUtils::asInt64(parametersRoot, field, 0);
			}
		}

        int height = -1;
		{
			field = "Height";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				height = JSONUtils::asInt(parametersRoot, field, 0);
			}
		}

        int videoWidth;
        int videoHeight;
        try
        {
			vector<tuple<int64_t, int, int64_t, int, int, string, string, long, string>> videoTracks;
			vector<tuple<int64_t, int, int64_t, long, string, long, int, string>> audioTracks;

			_mmsEngineDBFacade->getVideoDetails(
				sourceMediaItemKey, sourcePhysicalPathKey, videoTracks, audioTracks);
			if (videoTracks.size() == 0)
			{
				string errorMessage = __FILEREF__ + "No video track are present"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				;

				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			tuple<int64_t, int, int64_t, int, int, string, string, long, string> videoTrack = videoTracks[0];

			tie(ignore, ignore, durationInMilliSeconds, videoWidth, videoHeight, ignore, ignore,
				ignore, ignore) = videoTrack;

			if (durationInMilliSeconds <= 0)
			{
				durationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
					sourceMediaItemKey, sourcePhysicalPathKey);
			}
        }
        catch(runtime_error e)
        {
            string errorMessage = __FILEREF__ + "_mmsEngineDBFacade->getVideoDetails failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", e.what(): " + e.what()
            ;

            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        catch(exception e)
        {
            string errorMessage = __FILEREF__ + "_mmsEngineDBFacade->getVideoDetails failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", e.what(): " + e.what()
            ;

            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        imageWidth = width == -1 ? videoWidth : width;
        imageHeight = height == -1 ? videoHeight : height;

        if (durationInMilliSeconds < startTimeInSeconds * 1000)
        {
			if (fixStartTimeIfOvercomeDuration)
			{
				double previousStartTimeInSeconds = startTimeInSeconds;
				startTimeInSeconds = durationInMilliSeconds / 1000;

				_logger->info(__FILEREF__ + "startTimeInSeconds was changed to durationInMilliSeconds"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", fixStartTimeIfOvercomeDuration: " + to_string(fixStartTimeIfOvercomeDuration)
					+ ", previousStartTimeInSeconds: " + to_string(previousStartTimeInSeconds)
					+ ", new startTimeInSeconds: " + to_string(startTimeInSeconds)
				);
			}
			else
			{
				string errorMessage = __FILEREF__ + "Frame was not generated because instantInSeconds is bigger than the video duration"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", video sourceMediaItemKey: " + to_string(sourceMediaItemKey)
                    + ", startTimeInSeconds: " + to_string(startTimeInSeconds)
                    + ", durationInMilliSeconds: " + to_string(durationInMilliSeconds)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
        }
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "fillGenerateFramesParameters failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "fillGenerateFramesParameters failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        throw e;
    }
}

void MMSEngineProcessor::manageSlideShowTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No images found"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        
        MMSEngineDBFacade::EncodingPriority encodingPriority;
        string field = "EncodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = 
                    static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority =
                MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
        }

        // MMSEngineDBFacade::ContentType slideshowContentType;
        // bool slideshowContentTypeInitialized = false;
        vector<string> imagesSourcePhysicalPaths;
        vector<string> audiosSourcePhysicalPaths;
		double shortestAudioDurationInSeconds = -1;

        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
            // int64_t encodingProfileKey = -1;
            // string sourcePhysicalPath = _mmsStorage->getPhysicalPathDetails(keyAndDependencyType.first, encodingProfileKey);

            int64_t sourceMediaItemKey;
            int64_t sourcePhysicalPathKey;
            string sourcePhysicalPath;

            int64_t key;
            MMSEngineDBFacade::ContentType referenceContentType;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

            tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;
        
            if (dependencyType == Validator::DependencyType::MediaItemKey)
            {
				int64_t encodingProfileKey = -1;
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails
					= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
                tie(sourcePhysicalPathKey, sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore) =
					physicalPathDetails;

                sourceMediaItemKey = key;
            }
            else
            {
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(key);
				tie(sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore) = physicalPathDetails;

                sourcePhysicalPathKey = key;

                bool warningIfMissing = false;
                tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemDetails = _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                        workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

                tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
					= mediaItemDetails;
            }

			if (referenceContentType == MMSEngineDBFacade::ContentType::Image)
				imagesSourcePhysicalPaths.push_back(sourcePhysicalPath);
			else if (referenceContentType == MMSEngineDBFacade::ContentType::Audio)
			{
				audiosSourcePhysicalPaths.push_back(sourcePhysicalPath);
				double mediaDurationInMilliseconds =
					(double) _mmsEngineDBFacade->getMediaDurationInMilliseconds(
					sourceMediaItemKey, sourcePhysicalPathKey);
				if (shortestAudioDurationInSeconds == -1
						|| shortestAudioDurationInSeconds > mediaDurationInMilliseconds / 1000)
					shortestAudioDurationInSeconds = mediaDurationInMilliseconds / 1000;
			}
			else
			{
				string errorMessage = __FILEREF__ + "It is not possible to build a slideshow with a media that is not an Image-Audio"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", referenceContentType: " + MMSEngineDBFacade::toString(referenceContentType)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
            
			/*
            bool warningIfMissing = false;
            
            tuple<MMSEngineDBFacade::ContentType,string,string,string, int64_t, int64_t>
				contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey 
                    = _mmsEngineDBFacade->getMediaItemKeyDetails(
					workspace->_workspaceKey, sourceMediaItemKey, warningIfMissing);
           
            MMSEngineDBFacade::ContentType contentType;
            string localTitle;
            string userData;
            string ingestionDate;
			int64_t localIngestionJobKey;
            tie(contentType, localTitle, userData, ingestionDate, ignore, localIngestionJobKey)
				= contentTypeTitleUserDataIngestionDateRemovedInAndIngestionJobKey;
            
            if (!slideshowContentTypeInitialized)
            {
                slideshowContentType = contentType;
                if (slideshowContentType != MMSEngineDBFacade::ContentType::Image)
                {
                    string errorMessage = __FILEREF__ + "It is not possible to build a slideshow with a media that is not an Image"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", slideshowContentType: " + MMSEngineDBFacade::toString(slideshowContentType)
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
            else
            {
                if (slideshowContentType != contentType)
                {
                    string errorMessage = __FILEREF__ + "Not all the References have the same ContentType"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", contentType: " + MMSEngineDBFacade::toString(contentType)
                            + ", slideshowContentType: " + MMSEngineDBFacade::toString(slideshowContentType)
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
			*/
        }

        double durationOfEachSlideInSeconds = 2;
        field = "DurationOfEachSlideInSeconds";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
            durationOfEachSlideInSeconds = JSONUtils::asDouble(parametersRoot, field, 0);

        string videoSyncMethod = "vfr";
        field = "VideoSyncMethod";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
            videoSyncMethod = parametersRoot.get(field, "vfr").asString();

        int outputFrameRate = 25;
        
        _mmsEngineDBFacade->addEncoding_SlideShowJob(workspace, ingestionJobKey,
			imagesSourcePhysicalPaths, durationOfEachSlideInSeconds,
			audiosSourcePhysicalPaths, shortestAudioDurationInSeconds,
			videoSyncMethod,
			outputFrameRate, encodingPriority);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageSlideShowTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageSlideShowTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::generateAndIngestConcatenationThread(
        shared_ptr<long> processorsThreadsNumber, int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"generateAndIngestConcatenationThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
		_logger->info(__FILEREF__ + "generateAndIngestConcatenationThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        if (dependencies.size() < 1)
        {
            string errorMessage = __FILEREF__ + "No enough media to be concatenated"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::ContentType concatContentType;
        bool concatContentTypeInitialized = false;
        vector<string> sourcePhysicalPaths;
        string forcedAvgFrameRate;
        
		// In case the first and the last chunk will have TimeCode, we will report them
		// in the new content
		int64_t utcStartTimeInMilliSecs = -1;
		int64_t utcEndTimeInMilliSecs = -1;
		bool firstMedia = true;
		string lastUserData;

        for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType: dependencies)
        {
            int64_t key;
            MMSEngineDBFacade::ContentType referenceContentType;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

            tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			_logger->info(__FILEREF__ + "generateAndIngestConcatenationThread"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", key: " + to_string(key)
			);

            int64_t sourceMediaItemKey;
            int64_t sourcePhysicalPathKey;
            string sourcePhysicalPath;
            if (dependencyType == Validator::DependencyType::MediaItemKey)
            {
				int64_t encodingProfileKey = -1;
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string>
					physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName
					= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey, warningIfMissing);
                tie(sourcePhysicalPathKey, sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore) =
					physicalPathKeyPhysicalPathFileNameSizeInBytesAndDeliveryFileName;

                sourceMediaItemKey = key;
            }
            else
            {
				tuple<string, int, string, string, int64_t, string>
					physicalPathFileNameSizeInBytesAndDeliveryFileName =
					_mmsStorage->getPhysicalPathDetails(key);
				tie(sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore)
					= physicalPathFileNameSizeInBytesAndDeliveryFileName;

                sourcePhysicalPathKey = key;

                bool warningIfMissing = false;
                tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                    _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                        workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

                tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
                        = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
            }

            sourcePhysicalPaths.push_back(sourcePhysicalPath);
            
            bool warningIfMissing = false;
            tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
				mediaItemKeyDetails
				= _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                        workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);
            
            MMSEngineDBFacade::ContentType contentType;
            {
                int64_t localMediaItemKey;
                string localTitle;
                string ingestionDate;
				int64_t localIngestionJobKey;
                tie(localMediaItemKey, contentType, localTitle, lastUserData, ingestionDate,
						localIngestionJobKey, ignore, ignore)
					= mediaItemKeyDetails;
            }

			if (firstMedia)
			{
				firstMedia = false;

				if (lastUserData != "")
				{
					// try to retrieve time codes
					Json::Value sourceUserDataRoot;
					try
					{
						Json::CharReaderBuilder builder;
						Json::CharReader* reader = builder.newCharReader();
						string errors;

						bool parsingSuccessful = reader->parse(lastUserData.c_str(),
							lastUserData.c_str() + lastUserData.size(), 
							&sourceUserDataRoot, &errors);
						delete reader;

						if (!parsingSuccessful)
						{
							string errorMessage = __FILEREF__ + "failed to parse userData"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errors: " + errors
								+ ", lastUserData: " + lastUserData
							;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
					}
					catch(...)
					{
						string errorMessage = string("userData json is not well format")
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", lastUserData: " + lastUserData
						;
						_logger->error(__FILEREF__ + errorMessage);

						throw runtime_error(errorMessage);
					}

					string field = "mmsData";
					if (JSONUtils::isMetadataPresent(sourceUserDataRoot, field))
					{
						Json::Value sourceMmsDataRoot = sourceUserDataRoot[field];

						string utcStartTimeInMilliSecsField = "utcStartTimeInMilliSecs";
						string utcChunkStartTimeField = "utcChunkStartTime";
						if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcStartTimeInMilliSecsField))
						{
							utcStartTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcStartTimeInMilliSecsField, 0);
						}
						else if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcChunkStartTimeField))
						{
							utcStartTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcChunkStartTimeField, 0);
							utcStartTimeInMilliSecs *= 1000;
						}
					}
				}
			}

            if (!concatContentTypeInitialized)
            {
                concatContentType = contentType;
                if (concatContentType != MMSEngineDBFacade::ContentType::Video
                        && concatContentType != MMSEngineDBFacade::ContentType::Audio)
                {
                    string errorMessage = __FILEREF__ + "It is not possible to concatenate a media that is not video or audio"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", concatContentType: " + MMSEngineDBFacade::toString(concatContentType)
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
            else
            {
                if (concatContentType != contentType)
                {
                    string errorMessage = __FILEREF__ + "Not all the References have the same ContentType"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", contentType: " + MMSEngineDBFacade::toString(contentType)
                            + ", concatContentType: " + MMSEngineDBFacade::toString(concatContentType)
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
            
            // to manage a ffmpeg bug generating a corrupted/wrong avgFrameRate, we will
            // force the concat file to have the same avgFrameRate of the source media
            if (concatContentType == MMSEngineDBFacade::ContentType::Video
                    && forcedAvgFrameRate == "")
            {
				/*
                tuple<int64_t,long,string,string,int,int,string,long,string,long,int,long> videoDetails 
                    = _mmsEngineDBFacade->getVideoDetails(sourceMediaItemKey, sourcePhysicalPathKey);

                tie(ignore, ignore, ignore,
                    ignore, ignore, ignore, forcedAvgFrameRate,
                    ignore, ignore, ignore, ignore, ignore)
                    = videoDetails;
				*/
				vector<tuple<int64_t, int, int64_t, int, int, string, string, long, string>> videoTracks;
				vector<tuple<int64_t, int, int64_t, long, string, long, int, string>> audioTracks;

				_mmsEngineDBFacade->getVideoDetails(
					sourceMediaItemKey, sourcePhysicalPathKey, videoTracks, audioTracks);
				if (videoTracks.size() == 0)
				{
					string errorMessage = __FILEREF__ + "No video track are present"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					;

					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}

				tuple<int64_t, int, int64_t, int, int, string, string, long, string> videoTrack = videoTracks[0];

				tie(ignore, ignore, ignore, ignore, ignore, forcedAvgFrameRate, ignore, ignore, ignore) = videoTrack;
            }
		}

		_logger->info(__FILEREF__ + "generateAndIngestConcatenationThread, retrying time code"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", utcStartTimeInMilliSecs: " + to_string(utcStartTimeInMilliSecs)
			+ ", lastUserData: " + lastUserData
		);

		if (utcStartTimeInMilliSecs != -1)
		{
			if (lastUserData != "")
			{
				// try to retrieve time codes
				Json::Value sourceUserDataRoot;
				try
				{
					Json::CharReaderBuilder builder;
					Json::CharReader* reader = builder.newCharReader();
					string errors;

					bool parsingSuccessful = reader->parse(lastUserData.c_str(),
						lastUserData.c_str() + lastUserData.size(), 
						&sourceUserDataRoot, &errors);
					delete reader;

					if (!parsingSuccessful)
					{
						string errorMessage = __FILEREF__ + "failed to parse userData"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", errors: " + errors
							+ ", lastUserData: " + lastUserData
						;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}
				}
				catch(...)
				{
					string errorMessage = string("userData json is not well format")
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", lastUserData: " + lastUserData
					;
					_logger->error(__FILEREF__ + errorMessage);

					throw runtime_error(errorMessage);
				}

				string field = "mmsData";
				if (JSONUtils::isMetadataPresent(sourceUserDataRoot, field))
				{
					Json::Value sourceMmsDataRoot = sourceUserDataRoot[field];

					string utcEndTimeInMilliSecsField = "utcEndTimeInMilliSecs";
					string utcChunkEndTimeField = "utcChunkEndTime";
					if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcEndTimeInMilliSecsField))
					{
						utcEndTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcEndTimeInMilliSecsField, 0);
					}
					else if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcChunkEndTimeField))
					{
						utcEndTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcChunkEndTimeField, 0);
						utcEndTimeInMilliSecs *= 1000;
					}
				}
			}

			// utcStartTimeInMilliSecs and utcEndTimeInMilliSecs will be set in parametersRoot
			if (utcStartTimeInMilliSecs != -1 && utcEndTimeInMilliSecs != -1)
			{
				Json::Value destUserDataRoot;

				/*
				{
					Json::StreamWriterBuilder wbuilder;
					string json = Json::writeString(wbuilder, parametersRoot);

					_logger->info(__FILEREF__ + "generateAndIngestConcatenationThread"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", parametersRoot: " + json
					);
				}
				*/

				string field = "UserData";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					destUserDataRoot = parametersRoot[field];

				Json::Value destMmsDataRoot;

				field = "mmsData";
				if (JSONUtils::isMetadataPresent(destUserDataRoot, field))
					destMmsDataRoot = destUserDataRoot[field];

				field = "utcStartTimeInMilliSecs";
				if (JSONUtils::isMetadataPresent(destMmsDataRoot, field))
					destMmsDataRoot.removeMember(field);
				destMmsDataRoot[field] = utcStartTimeInMilliSecs;

				field = "utcEndTimeInMilliSecs";
				if (JSONUtils::isMetadataPresent(destMmsDataRoot, field))
					destMmsDataRoot.removeMember(field);
				destMmsDataRoot[field] = utcEndTimeInMilliSecs;


				/*
				{
					Json::StreamWriterBuilder wbuilder;
					string json = Json::writeString(wbuilder, destMmsDataRoot);

					_logger->info(__FILEREF__ + "generateAndIngestConcatenationThread"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", destMmsDataRoot: " + json
					);
				}
				{
					Json::StreamWriterBuilder wbuilder;
					string json = Json::writeString(wbuilder, parametersRoot);

					_logger->info(__FILEREF__ + "generateAndIngestConcatenationThread"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", parametersRoot: " + json
					);
				}
				*/

				// next statements will provoke an std::exception in case parametersRoot -> UserData
				// is a string (i.e.: "UserData" : "{\"matchId\": 363615, \"groupName\": \"CI\",
				//		\"homeTeamName\": \"Pescara Calcio\", \"awayTeamName\": \"Olbia Calcio 1905\",
				//		\"start\": 1629398700000 }")
				//	and NOT a json

				field = "mmsData";
				destUserDataRoot[field] = destMmsDataRoot;

				field = "UserData";
				parametersRoot[field] = destUserDataRoot;
			}
		}

		// this is a concat, so destination file name shall have the same
        // extension as the source file name
        string fileFormat;
        size_t extensionIndex = sourcePhysicalPaths.front().find_last_of(".");
        if (extensionIndex == string::npos)
        {
            string errorMessage = __FILEREF__ + "No fileFormat (extension of the file) found in sourcePhysicalPath"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", sourcePhysicalPaths.front(): " + sourcePhysicalPaths.front()
            ;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        fileFormat = sourcePhysicalPaths.front().substr(extensionIndex + 1);

        string localSourceFileName = to_string(ingestionJobKey)
                + "_concat"
                + "." + fileFormat // + "_source"
                ;

        string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(
            workspace);
        string concatenatedMediaPathName = workspaceIngestionRepository + "/" 
                + localSourceFileName;
        
        if (sourcePhysicalPaths.size() == 1)
        {
            string sourcePhysicalPath = sourcePhysicalPaths.at(0);
            _logger->info(__FILEREF__ + "Coping"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", sourcePhysicalPath: " + sourcePhysicalPath
                + ", concatenatedMediaPathName: " + concatenatedMediaPathName
            );

            FileIO::copyFile(sourcePhysicalPath, concatenatedMediaPathName);
        }
        else
        {
            FFMpeg ffmpeg (_configuration, _logger);
            ffmpeg.concat(ingestionJobKey,
				concatContentType == MMSEngineDBFacade::ContentType::Video ? true : false,
				sourcePhysicalPaths, concatenatedMediaPathName);
        }

        _logger->info(__FILEREF__ + "generateConcatMediaToIngest done"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", concatenatedMediaPathName: " + concatenatedMediaPathName
        );

        double maxDurationInSeconds = 0.0;
        double extraSecondsToCutWhenMaxDurationIsReached = 0.0;
        string field = "MaxDurationInSeconds";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
		{
			maxDurationInSeconds = JSONUtils::asDouble(parametersRoot, field, 0.0);

			field = "ExtraSecondsToCutWhenMaxDurationIsReached";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				extraSecondsToCutWhenMaxDurationIsReached = JSONUtils::asDouble(parametersRoot, field, 0.0);

				if (extraSecondsToCutWhenMaxDurationIsReached >= abs(maxDurationInSeconds))
					extraSecondsToCutWhenMaxDurationIsReached = 0.0;
			}
		}
		_logger->info(__FILEREF__ + "duration check"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", maxDurationInSeconds: " + to_string(maxDurationInSeconds)
			+ ", extraSecondsToCutWhenMaxDurationIsReached: " + to_string(extraSecondsToCutWhenMaxDurationIsReached)
		);
		if (maxDurationInSeconds != 0.0)
		{
			pair<int64_t, long> mediaInfoDetails;
			vector<tuple<int, int64_t, string, string, int, int, string, long>> videoTracks;
			vector<tuple<int, int64_t, string, long, int, long, string>> audioTracks;
			int64_t durationInMilliSeconds;


			_logger->info(__FILEREF__ + "Calling ffmpeg.getMediaInfo"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", concatenatedMediaPathName: " + concatenatedMediaPathName
			);
			bool isMMSAssetPathName = true;
			FFMpeg ffmpeg (_configuration, _logger);
			mediaInfoDetails = ffmpeg.getMediaInfo(ingestionJobKey, 
				isMMSAssetPathName, concatenatedMediaPathName, videoTracks, audioTracks);

			//tie(durationInMilliSeconds, ignore,
			//	ignore, ignore, ignore, ignore, ignore, ignore,
			//	ignore, ignore, ignore, ignore) = mediaInfo;
			tie(durationInMilliSeconds, ignore) = mediaInfoDetails;

			_logger->info(__FILEREF__ + "duration check"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", durationInMilliSeconds: " + to_string(durationInMilliSeconds)
				+ ", maxDurationInSeconds: " + to_string(maxDurationInSeconds)
				+ ", extraSecondsToCutWhenMaxDurationIsReached: " + to_string(extraSecondsToCutWhenMaxDurationIsReached)
			);
			if (durationInMilliSeconds > abs(maxDurationInSeconds) * 1000)
			{
				string localCutSourceFileName = to_string(ingestionJobKey)
					+ "_concat_cut"
					+ "." + fileFormat // + "_source"
				;

				string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(
					workspace);
				string cutMediaPathName = workspaceIngestionRepository + "/" 
					+ localCutSourceFileName;

				string cutType = "KeyFrameSeeking";
				double startTimeInSeconds;
				double endTimeInSeconds;
				if (maxDurationInSeconds < 0.0)
				{
					startTimeInSeconds = ((durationInMilliSeconds / 1000) -
							(abs(maxDurationInSeconds) - extraSecondsToCutWhenMaxDurationIsReached));
					endTimeInSeconds = durationInMilliSeconds / 1000;
				}
				else
				{
					startTimeInSeconds = 0.0;
					endTimeInSeconds = maxDurationInSeconds - extraSecondsToCutWhenMaxDurationIsReached;
				}
				int framesNumber = -1;

				_logger->info(__FILEREF__ + "Calling ffmpeg.cut"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", concatenatedMediaPathName: " + concatenatedMediaPathName
					+ ", cutType: " + cutType
					+ ", startTimeInSeconds: " + to_string(startTimeInSeconds)
					+ ", endTimeInSeconds: " + to_string(endTimeInSeconds)
					+ ", framesNumber: " + to_string(framesNumber)
				);

				ffmpeg.cutWithoutEncoding(ingestionJobKey, concatenatedMediaPathName, 
					cutType,
					concatContentType == MMSEngineDBFacade::ContentType::Video ? true : false,
					startTimeInSeconds, endTimeInSeconds, framesNumber,
					cutMediaPathName);

				_logger->info(__FILEREF__ + "cut done"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", cutMediaPathName: " + cutMediaPathName
				);

				localSourceFileName = localCutSourceFileName;

				_logger->info(__FILEREF__ + "Remove file"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", concatenatedMediaPathName: " + concatenatedMediaPathName
				);

				bool exceptionInCaseOfError = false;
				FileIO::remove(concatenatedMediaPathName, exceptionInCaseOfError);
			}
		}

		{
			string title;
			int64_t imageOfVideoMediaItemKey = -1;
			int64_t cutOfVideoMediaItemKey = -1;
			int64_t cutOfAudioMediaItemKey = -1;
			double startTimeInSeconds = 0.0;
			double endTimeInSeconds = 0.0;
			string mediaMetaDataContent = generateMediaMetadataToIngest(
				ingestionJobKey,
				// concatContentType == MMSEngineDBFacade::ContentType::Video ? true : false,
				fileFormat,
				title,
				imageOfVideoMediaItemKey,
				cutOfVideoMediaItemKey, cutOfAudioMediaItemKey, startTimeInSeconds, endTimeInSeconds,
				parametersRoot
			);

			{
				shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent = _multiEventsSet->getEventsFactory()
					->getFreeEvent<LocalAssetIngestionEvent>(MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);

				localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
				localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
				localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

				localAssetIngestionEvent->setExternalReadOnlyStorage(false);
				localAssetIngestionEvent->setIngestionJobKey(ingestionJobKey);
				localAssetIngestionEvent->setIngestionSourceFileName(localSourceFileName);
				localAssetIngestionEvent->setMMSSourceFileName(localSourceFileName);
				localAssetIngestionEvent->setWorkspace(workspace);
				localAssetIngestionEvent->setIngestionType(MMSEngineDBFacade::IngestionType::AddContent);            
				localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(true);

				// to manage a ffmpeg bug generating a corrupted/wrong avgFrameRate, we will
				// force the concat file to have the same avgFrameRate of the source media
				if (forcedAvgFrameRate != "" && concatContentType == MMSEngineDBFacade::ContentType::Video)
					localAssetIngestionEvent->setForcedAvgFrameRate(forcedAvgFrameRate);            


				localAssetIngestionEvent->setMetadataContent(mediaMetaDataContent);

				shared_ptr<Event2>    event = dynamic_pointer_cast<Event2>(localAssetIngestionEvent);
				_multiEventsSet->addEvent(event);

				_logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (INGESTASSETEVENT)"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", getEventKey().first: " + to_string(event->getEventKey().first)
					+ ", getEventKey().second: " + to_string(event->getEventKey().second));
			}
        }
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "generateAndIngestConcatenationThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
		// it's a thread, no throw
        // throw e;
        return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "generateAndIngestConcatenationThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
		// it's a thread, no throw
        // throw e;
        return;
    }
}

void MMSEngineProcessor::generateAndIngestCutMediaThread(
        shared_ptr<long> processorsThreadsNumber,
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
			dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"generateAndIngestCutMediaThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
		_logger->info(__FILEREF__ + "generateAndIngestCutMediaThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong number of media to be cut"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		int64_t sourceMediaItemKey;
		int64_t sourcePhysicalPathKey;
		string sourcePhysicalPath;
		{
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies.back();

			int64_t key;
			MMSEngineDBFacade::ContentType referenceContentType;
			Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType == Validator::DependencyType::MediaItemKey)
			{
				int64_t encodingProfileKey = -1;
				bool warningIfMissing = false;
				tuple<int64_t, string, int, string, string, int64_t, string> physicalPathDetails
					= _mmsStorage->getPhysicalPathDetails(key, encodingProfileKey,
						warningIfMissing);
				tie(sourcePhysicalPathKey, sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore) =
					physicalPathDetails;

				sourceMediaItemKey = key;
			}
			else
			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(key);
				tie(sourcePhysicalPath, ignore, ignore, ignore, ignore, ignore) = physicalPathDetails;

				sourcePhysicalPathKey = key;

				bool warningIfMissing = false;
				tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemDetails = _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
						workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);
				tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
					= mediaItemDetails;
			}
		}

		MMSEngineDBFacade::ContentType contentType;
		string userData;
		{
			bool warningIfMissing = false;

			tuple<MMSEngineDBFacade::ContentType,string,string,string, int64_t, int64_t>
				mediaItemDetails
					= _mmsEngineDBFacade->getMediaItemKeyDetails(
					workspace->_workspaceKey, sourceMediaItemKey, warningIfMissing);

			string localTitle;
			string ingestionDate;
			int64_t localIngestionJobKey;
			tie(contentType, localTitle, userData, ingestionDate, ignore, localIngestionJobKey)
				= mediaItemDetails;
		}

        if (contentType != MMSEngineDBFacade::ContentType::Video
			&& contentType != MMSEngineDBFacade::ContentType::Audio)
        {
            string errorMessage = __FILEREF__ + "It is not possible to cut a media that is not video or audio"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", contentType: " + MMSEngineDBFacade::toString(contentType)
                    ;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		int64_t sourceDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
			sourceMediaItemKey, sourcePhysicalPathKey);

		// check start time / end time
		int framesNumber = -1;
		double startTimeInSeconds;
		double endTimeInSeconds = 0.0;
		{
			string field = "StartTimeInSeconds";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			startTimeInSeconds = JSONUtils::asDouble(parametersRoot, field, 0.0);

			field = "EndTimeInSeconds";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				if (contentType == MMSEngineDBFacade::ContentType::Audio)
				{
					// endTimeInSeconds in case of Audio is mandatory
					// because we cannot use the other option (FramesNumber)

					string errorMessage = __FILEREF__ + "Field is not present or it is null, endTimeInSeconds in case of Audio is mandatory because we cannot use the other option (FramesNumber)"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", Field: " + field;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
			}
			endTimeInSeconds = JSONUtils::asDouble(parametersRoot, field, 0.0);

			if (contentType == MMSEngineDBFacade::ContentType::Video)
			{
				field = "FramesNumber";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					framesNumber = JSONUtils::asInt(parametersRoot, field, 0);
			}

			// 2021-02-05: default is set to true because often we have the error
			//	endTimeInSeconds is bigger of few milliseconds of the duration of the media
			//	For this reason this field is set to true by default
			bool fixEndTimeIfOvercomeDuration = true;
			field = "FixEndTimeIfOvercomeDuration";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				fixEndTimeIfOvercomeDuration = JSONUtils::asBool(parametersRoot, field, true);

			/*
			if (endTimeInSeconds == -1 && framesNumber == -1)
			{
				string errorMessage = __FILEREF__ + "Both 'EndTimeInSeconds' and 'FramesNumber' fields are not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    ;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			*/

			if (framesNumber == -1)
			{
				if (endTimeInSeconds < 0)
				{
					// if negative, it has to be subtract by the durationInMilliSeconds
					double newEndTimeInSeconds  = (sourceDurationInMilliSeconds
						- (endTimeInSeconds * -1000)) / 1000;

					_logger->error(__FILEREF__ + "endTimeInSeconds was changed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", video sourceMediaItemKey: " + to_string(sourceMediaItemKey)
						+ ", startTimeInSeconds: " + to_string(startTimeInSeconds)
						+ ", endTimeInSeconds: " + to_string(endTimeInSeconds)
						+ ", newEndTimeInSeconds: " + to_string(newEndTimeInSeconds)
						+ ", sourceDurationInMilliSeconds: " + to_string(sourceDurationInMilliSeconds)
					);

					endTimeInSeconds = newEndTimeInSeconds;
				}
			}

			if (startTimeInSeconds > endTimeInSeconds)
			{
				string errorMessage = __FILEREF__ + "Cut was not done because startTimeInSeconds is bigger than endTimeInSeconds"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", video sourceMediaItemKey: " + to_string(sourceMediaItemKey)
						+ ", startTimeInSeconds: " + to_string(startTimeInSeconds)
						+ ", endTimeInSeconds: " + to_string(endTimeInSeconds)
						+ ", sourceDurationInMilliSeconds: " + to_string(sourceDurationInMilliSeconds)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			else
			{
				if (framesNumber == -1)
				{
					if (sourceDurationInMilliSeconds < endTimeInSeconds * 1000)
					{
						if (fixEndTimeIfOvercomeDuration)
						{
							double previousEndTimeInSeconds = endTimeInSeconds;
							endTimeInSeconds = sourceDurationInMilliSeconds / 1000;

							_logger->info(__FILEREF__ + "endTimeInSeconds was changed to durationInMilliSeconds"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", fixEndTimeIfOvercomeDuration: " + to_string(fixEndTimeIfOvercomeDuration)
								+ ", video sourceMediaItemKey: " + to_string(sourceMediaItemKey)
								+ ", previousEndTimeInSeconds: " + to_string(previousEndTimeInSeconds)
								+ ", new endTimeInSeconds: " + to_string(endTimeInSeconds)
								+ ", sourceDurationInMilliSeconds (input media): " + to_string(sourceDurationInMilliSeconds)
							);
						}
						else
						{
							string errorMessage = __FILEREF__ + "Cut was not done because endTimeInSeconds is bigger than durationInMilliSeconds (input media)"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", video sourceMediaItemKey: " + to_string(sourceMediaItemKey)
								+ ", startTimeInSeconds: " + to_string(startTimeInSeconds)
								+ ", endTimeInSeconds: " + to_string(endTimeInSeconds)
								+ ", sourceDurationInMilliSeconds (input media): " + to_string(sourceDurationInMilliSeconds)
							;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
					}
				}
			}
		}

		int64_t newUtcStartTimeInMilliSecs = -1;
		int64_t newUtcEndTimeInMilliSecs = -1;
		{
			// In case the media has TimeCode, we will report them in the new content
			if (framesNumber == -1 && userData != "")
			{
				// try to retrieve time codes
				Json::Value sourceUserDataRoot;
				try
				{
					Json::CharReaderBuilder builder;
					Json::CharReader* reader = builder.newCharReader();
					string errors;

					bool parsingSuccessful = reader->parse(userData.c_str(),
						userData.c_str() + userData.size(), 
						&sourceUserDataRoot, &errors);
					delete reader;

					if (!parsingSuccessful)
					{
						string errorMessage = __FILEREF__ + "failed to parse userData"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", errors: " + errors
							+ ", userData: " + userData
						;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}
				}
				catch(...)
				{
					string errorMessage = string("userData json is not well format")
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", userData: " + userData
					;
					_logger->error(__FILEREF__ + errorMessage);

					throw runtime_error(errorMessage);
				}

				int64_t utcStartTimeInMilliSecs = -1;
				int64_t utcEndTimeInMilliSecs = -1;

				string field = "mmsData";
				if (JSONUtils::isMetadataPresent(sourceUserDataRoot, field))
				{
					Json::Value sourceMmsDataRoot = sourceUserDataRoot[field];

					string utcStartTimeInMilliSecsField = "utcStartTimeInMilliSecs";
					string utcChunkStartTimeField = "utcChunkStartTime";
					if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcStartTimeInMilliSecsField))
					{
						utcStartTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcStartTimeInMilliSecsField, 0);
					}
					else if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcChunkStartTimeField))
					{
						utcStartTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcChunkStartTimeField, 0);
						utcStartTimeInMilliSecs *= 1000;
					}

					if (utcStartTimeInMilliSecs != -1)
					{
						string utcEndTimeInMilliSecsField = "utcEndTimeInMilliSecs";
						string utcChunkEndTimeField = "utcChunkEndTime";
						if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcEndTimeInMilliSecsField))
						{
							utcEndTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcEndTimeInMilliSecsField, 0);
						}
						else if (JSONUtils::isMetadataPresent(sourceMmsDataRoot, utcChunkEndTimeField))
						{
							utcEndTimeInMilliSecs = JSONUtils::asInt64(sourceMmsDataRoot, utcChunkEndTimeField, 0);
							utcEndTimeInMilliSecs *= 1000;
						}

						// utcStartTimeInMilliSecs and utcEndTimeInMilliSecs will be set in parametersRoot
						if (utcStartTimeInMilliSecs != -1 && utcEndTimeInMilliSecs != -1)
						{
							newUtcStartTimeInMilliSecs = utcStartTimeInMilliSecs;
							newUtcStartTimeInMilliSecs += ((int64_t) (startTimeInSeconds * 1000));
							newUtcEndTimeInMilliSecs = utcStartTimeInMilliSecs + ((int64_t) (endTimeInSeconds * 1000));
						}
					}
				}
			}
		}

		string cutType = "KeyFrameSeeking";
        string field = "CutType";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
			cutType = parametersRoot.get(field, "KeyFrameSeeking").asString();

		_logger->info(__FILEREF__ + "generateAndIngestCutMediaThread new start/end"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", cutType: " + cutType
			+ ", sourceMediaItemKey: " + to_string(sourceMediaItemKey)
			+ ", sourcePhysicalPathKey: " + to_string(sourcePhysicalPathKey)
			+ ", sourcePhysicalPath: " + sourcePhysicalPath
			+ ", sourceDurationInMilliSeconds: " + to_string(sourceDurationInMilliSeconds)
			+ ", framesNumber: " + to_string(framesNumber)
			+ ", startTimeInSeconds: " + to_string(startTimeInSeconds)
			+ ", endTimeInSeconds: " + to_string(endTimeInSeconds)
			+ ", newUtcStartTimeInMilliSecs: " + to_string(newUtcStartTimeInMilliSecs)
			+ ", newUtcEndTimeInMilliSecs: " + to_string(newUtcEndTimeInMilliSecs)
		);
		if (cutType == "KeyFrameSeeking" || cutType == "FrameAccurateWithoutEncoding")
		{
			string outputFileFormat;
			field = "OutputFileFormat";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
				outputFileFormat = parametersRoot.get(field, "").asString();

			_logger->info(__FILEREF__ + "1 generateAndIngestCutMediaThread new start/end"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			);

			// to manage a ffmpeg bug generating a corrupted/wrong avgFrameRate, we will
			// force the cut file to have the same avgFrameRate of the source media
			string forcedAvgFrameRate;
			{
				try
				{
					if (contentType == MMSEngineDBFacade::ContentType::Video)
					{
						vector<tuple<int64_t, int, int64_t, int, int, string, string, long, string>> videoTracks;
						vector<tuple<int64_t, int, int64_t, long, string, long, int, string>> audioTracks;

						_mmsEngineDBFacade->getVideoDetails(
							sourceMediaItemKey, sourcePhysicalPathKey, videoTracks, audioTracks);
						if (videoTracks.size() == 0)
						{
							string errorMessage = __FILEREF__ + "No video track are present"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							;

							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}

						tuple<int64_t, int, int64_t, int, int, string, string, long, string> videoTrack
							= videoTracks[0];

						tie(ignore, ignore, ignore, ignore, ignore, forcedAvgFrameRate, ignore,
							ignore, ignore) = videoTrack;
					}
				}
				catch(runtime_error e)
				{
					string errorMessage = __FILEREF__ + "_mmsEngineDBFacade->getVideoDetails failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", e.what(): " + e.what()
					;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				catch(exception e)
				{
					string errorMessage = __FILEREF__ + "_mmsEngineDBFacade->getVideoDetails failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", e.what(): " + e.what()
					;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
			}

			_logger->info(__FILEREF__ + "generateAndIngestCutMediaThread frame rate"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", forcedAvgFrameRate" + forcedAvgFrameRate
			);

			// this is a cut so destination file name shall have the same
			// extension as the source file name
			string fileFormat;
			if (outputFileFormat == "")
			{
				size_t extensionIndex = sourcePhysicalPath.find_last_of(".");
				if (extensionIndex == string::npos)
				{
					string errorMessage = __FILEREF__ + "No fileFormat (extension of the file) found in sourcePhysicalPath"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", sourcePhysicalPath: " + sourcePhysicalPath
					;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				string extension = sourcePhysicalPath.substr(extensionIndex + 1);

				if (extension == "m3u8")
					fileFormat = "ts";
				else
					fileFormat = extension;
			}
			else
			{
				fileFormat = outputFileFormat;
			}

			_logger->info(__FILEREF__ + "generateAndIngestCutMediaThread file format"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", fileFormatorcedAvgFrameRate" + fileFormat
			);

			if (newUtcStartTimeInMilliSecs != -1 && newUtcEndTimeInMilliSecs != -1)
			{
				Json::Value destUserDataRoot;

				field = "UserData";
				if (JSONUtils::isMetadataPresent(parametersRoot, field))
					destUserDataRoot = parametersRoot[field];

				Json::Value destMmsDataRoot;

				field = "mmsData";
				if (JSONUtils::isMetadataPresent(destUserDataRoot, field))
					destMmsDataRoot = destUserDataRoot[field];

				field = "utcStartTimeInMilliSecs";
				if (JSONUtils::isMetadataPresent(destMmsDataRoot, field))
					destMmsDataRoot.removeMember(field);
				destMmsDataRoot[field] = newUtcStartTimeInMilliSecs;

				field = "utcEndTimeInMilliSecs";
				if (JSONUtils::isMetadataPresent(destMmsDataRoot, field))
					destMmsDataRoot.removeMember(field);
				destMmsDataRoot[field] = newUtcEndTimeInMilliSecs;

				field = "mmsData";
				destUserDataRoot[field] = destMmsDataRoot;

				field = "UserData";
				parametersRoot[field] = destUserDataRoot;
			}

			_logger->info(__FILEREF__ + "generateAndIngestCutMediaThread usr data management"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			);

			string localSourceFileName = to_string(ingestionJobKey)
                + "_cut"
                + "." + fileFormat // + "_source"
                ;
        
			string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(
                workspace);
			string cutMediaPathName = workspaceIngestionRepository + "/"
                + localSourceFileName;
        
			FFMpeg ffmpeg (_configuration, _logger);
			ffmpeg.cutWithoutEncoding(ingestionJobKey, sourcePhysicalPath, 
				cutType,
				contentType == MMSEngineDBFacade::ContentType::Video ? true : false,
				startTimeInSeconds, endTimeInSeconds, framesNumber,
				cutMediaPathName);

			_logger->info(__FILEREF__ + "cut done"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", cutMediaPathName: " + cutMediaPathName
			);
        
			string title;
			int64_t imageOfVideoMediaItemKey = -1;
			int64_t cutOfVideoMediaItemKey = -1;
			int64_t cutOfAudioMediaItemKey = -1;
			if (contentType == MMSEngineDBFacade::ContentType::Video)
				cutOfVideoMediaItemKey = sourceMediaItemKey;
			else if (contentType == MMSEngineDBFacade::ContentType::Audio)
				cutOfAudioMediaItemKey = sourceMediaItemKey;
			string mediaMetaDataContent = generateMediaMetadataToIngest(
				ingestionJobKey,
				fileFormat,
				title,
				imageOfVideoMediaItemKey,
				cutOfVideoMediaItemKey, cutOfAudioMediaItemKey, startTimeInSeconds, endTimeInSeconds,
				parametersRoot
			);

			{
				shared_ptr<LocalAssetIngestionEvent>    localAssetIngestionEvent = _multiEventsSet->getEventsFactory()
                    ->getFreeEvent<LocalAssetIngestionEvent>(MMSENGINE_EVENTTYPEIDENTIFIER_LOCALASSETINGESTIONEVENT);

				localAssetIngestionEvent->setSource(MMSENGINEPROCESSORNAME);
				localAssetIngestionEvent->setDestination(MMSENGINEPROCESSORNAME);
				localAssetIngestionEvent->setExpirationTimePoint(chrono::system_clock::now());

				localAssetIngestionEvent->setExternalReadOnlyStorage(false);
				localAssetIngestionEvent->setIngestionJobKey(ingestionJobKey);
				localAssetIngestionEvent->setIngestionSourceFileName(localSourceFileName);
				localAssetIngestionEvent->setMMSSourceFileName(localSourceFileName);
				localAssetIngestionEvent->setWorkspace(workspace);
				localAssetIngestionEvent->setIngestionType(MMSEngineDBFacade::IngestionType::AddContent);
				localAssetIngestionEvent->setIngestionRowToBeUpdatedAsSuccess(true);
				// to manage a ffmpeg bug generating a corrupted/wrong avgFrameRate, we will
				// force the concat file to have the same avgFrameRate of the source media
				if (forcedAvgFrameRate != "" && contentType == MMSEngineDBFacade::ContentType::Video)
					localAssetIngestionEvent->setForcedAvgFrameRate(forcedAvgFrameRate);            

				localAssetIngestionEvent->setMetadataContent(mediaMetaDataContent);

				shared_ptr<Event2>    event = dynamic_pointer_cast<Event2>(localAssetIngestionEvent);
				_multiEventsSet->addEvent(event);

				_logger->info(__FILEREF__ + "addEvent: EVENT_TYPE (LOCALASSETINGESTIONEVENT)"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", getEventKey().first: " + to_string(event->getEventKey().first)
					+ ", getEventKey().second: " + to_string(event->getEventKey().second));
			}
		}
		else
		{
			MMSEngineDBFacade::EncodingPriority encodingPriority;
			string field = "EncodingPriority";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
				encodingPriority =
					static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
			else
				encodingPriority =
					MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "").asString());

			int64_t encodingProfileKey;
			Json::Value encodingProfileDetailsRoot;
			{
				string keyField = "EncodingProfileKey";
				string labelField = "EncodingProfileLabel";
				if (JSONUtils::isMetadataPresent(parametersRoot, keyField))
				{
					encodingProfileKey = JSONUtils::asInt64(parametersRoot, keyField, 0);
				}
				else if (JSONUtils::isMetadataPresent(parametersRoot, labelField))
				{
					string encodingProfileLabel = parametersRoot.get(labelField, "").asString();

					MMSEngineDBFacade::ContentType videoContentType = MMSEngineDBFacade::ContentType::Video;
					encodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
						workspace->_workspaceKey, videoContentType, encodingProfileLabel);
				}
				else
				{
					string errorMessage = __FILEREF__ + "Both fields are not present or it is null"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", Field: " + keyField
						+ ", Field: " + labelField
					;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}

				{
					string jsonEncodingProfile;

					tuple<string, MMSEngineDBFacade::ContentType, MMSEngineDBFacade::DeliveryTechnology, string>
						encodingProfileDetails = _mmsEngineDBFacade->getEncodingProfileDetailsByKey(
						workspace->_workspaceKey, encodingProfileKey);
					tie(ignore, ignore, ignore, jsonEncodingProfile) = encodingProfileDetails;

					{
						Json::CharReaderBuilder builder;
						Json::CharReader* reader = builder.newCharReader();
						string errors;

						bool parsingSuccessful = reader->parse(jsonEncodingProfile.c_str(),
							jsonEncodingProfile.c_str() + jsonEncodingProfile.size(), 
							&encodingProfileDetailsRoot,
							&errors);
						delete reader;

						if (!parsingSuccessful)
						{
							string errorMessage = __FILEREF__ + "failed to parse 'parameters'"
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errors: " + errors
							;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
					}
				}
			}

			_mmsEngineDBFacade->addEncoding_CutFrameAccurate(workspace, ingestionJobKey,
				sourceMediaItemKey,
				sourcePhysicalPathKey,
				sourcePhysicalPath,
				// sourceDurationInMilliSeconds,
				endTimeInSeconds,
				encodingProfileKey,
				encodingProfileDetailsRoot, encodingPriority,
				newUtcStartTimeInMilliSecs, newUtcEndTimeInMilliSecs);
		}
	}
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "generateAndIngestCutMediaThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            

		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
		// it's a thread, no throw
        // throw e;
        return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "generateAndIngestCutMediaThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
		// it's a thread, no throw
        // throw e;
        return;
    }
}

void MMSEngineProcessor::manageEncodeTask(
	int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
		dependencies
)
{
    try
    {
        if (dependencies.size() == 0)
        {
            string errorMessage = __FILEREF__ + "No media received to be encoded"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		MMSEngineDBFacade::ContentType contentType;
		{
			tuple<int64_t, MMSEngineDBFacade::ContentType, Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[0];

			tie(ignore, contentType, ignore, ignore) = keyAndDependencyType;
		}

        MMSEngineDBFacade::EncodingPriority encodingPriority;
		{
			string field = "EncodingPriority";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				encodingPriority = static_cast<MMSEngineDBFacade::EncodingPriority>(
					workspace->_maxEncodingPriority);
			}
			else
			{
				encodingPriority = MMSEngineDBFacade::toEncodingPriority(
						parametersRoot.get(field, "").asString());
			}
		}

		int64_t encodingProfileKey = -1;
		Json::Value encodingProfileDetailsRoot;
		{
			// This task shall contain EncodingProfileKey or EncodingProfileLabel.
			// We cannot have EncodingProfilesSetKey because we replaced it with a GroupOfTasks
			//  having just EncodingProfileKey        

			string keyField = "EncodingProfileKey";
			string labelField = "EncodingProfileLabel";
			if (JSONUtils::isMetadataPresent(parametersRoot, keyField))
			{
				encodingProfileKey = JSONUtils::asInt64(parametersRoot, keyField, 0);
			}
			else if (JSONUtils::isMetadataPresent(parametersRoot, labelField))
			{
				string encodingProfileLabel = parametersRoot.get(labelField, "").asString();

				encodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
					workspace->_workspaceKey, contentType, encodingProfileLabel);
			}
			else
			{
				string errorMessage = __FILEREF__ + "Both fields are not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", Field: " + keyField
						+ ", Field: " + labelField
						;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				string jsonEncodingProfile;

				tuple<string, MMSEngineDBFacade::ContentType, MMSEngineDBFacade::DeliveryTechnology,
					string> encodingProfileDetails
						= _mmsEngineDBFacade->getEncodingProfileDetailsByKey(
							workspace->_workspaceKey, encodingProfileKey);
				tie(ignore, ignore, ignore, jsonEncodingProfile) = encodingProfileDetails;

				{
					Json::CharReaderBuilder builder;
					Json::CharReader* reader = builder.newCharReader();
					string errors;

					bool parsingSuccessful = reader->parse(jsonEncodingProfile.c_str(),
						jsonEncodingProfile.c_str() + jsonEncodingProfile.size(), 
						&encodingProfileDetailsRoot,
						&errors);
					delete reader;

					if (!parsingSuccessful)
					{
						string errorMessage = __FILEREF__ + "failed to parse 'parameters'"
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", errors: " + errors
						;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}
				}
			}
		}

		// it is not possible to manage more than one encode because:
		// 1. inside _mmsEngineDBFacade->addEncodingJob, the ingestionJob is updated to encodingQueue
		//		and the second call will fail (because the update of the ingestion was already done
		//	2. The ingestionJob mantains the status of the encoding, how would be managed
		//		the status in case of more than one encoding?
		//	3. EncoderVideoAudioProxy::encodeContent_VideoAudio_through_ffmpeg saves
		//		encoder URL and staging directory into database to recover the scenario
		//		where the engine reboot. 
		// 2021-06-07: we have the need to manage more than one encoding.
		//	For example, we have the I-Frame task and, on success, we want to encode
		//	all the images generated by the I-Frames task.
		//	In this scenario the Encode task receives a lot of images as input.
		//	Solution no. 1:
		//		we manage all the inputs sequentially (as it is doing the RemoveContent task).
		//		This is not a good solution because, in case of the Encode task and in case of videos,
		//		every encoding would take a lot of time. Manage all these encodings sequentially
		//		is not what the User expect to see.
		//	Solution no. 2:
		//		we can create one EncodingJob for each encoding. This is exactly what the User expects
		//		because the encodings will run in parallel.
		//
		//		Issue 1: How to manage the ingestionJob status in case of multiple encodings?
		//		Issue 2: GUI and API are planned to manage one EncodingJob for each IngestionJob
		//
		//	2021-08-25: In case the Encode Task is received by the MMS with multiple References
		//	as input during the ingestion, it will be automatically converted with a
		//	GroupOfTasks with all the Encode Tasks as children (just done).
		//	The problem is when the input references are generated dinamically as output
		//	of the parent task. We will manage this issue ONLY in case of images doing
		//	the encoding sequentially.
		//	For video/audio we cannot manage it sequentially (like images) mainly because
		//	the encoder URL and the staging directory are saved into the database
		//	to manage the recovering in case of reboot of the Engine.
		//	This recovery is very important and I do not know how to manage it
		//	in case the task has in his queue a list of encodings to do!!!
		//	We should save into DB also the specific encoding it is doing?!?!??!
		//	Also che encoding progress would not have sense in the "sequential/queue" scenario
		Json::Value sourcesToBeEncodedRoot(Json::arrayValue);
		{
			for (tuple<int64_t, MMSEngineDBFacade::ContentType, Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
			{
				MMSEngineDBFacade::ContentType referenceContentType;
				int64_t key;
				Validator::DependencyType dependencyType;
				bool stopIfReferenceProcessingError;

				tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
					= keyAndDependencyType;

				try
				{
					if (contentType != referenceContentType)
					{
						string errorMessage = __FILEREF__ + "Wrong content type"
							+ ", contentType: " + MMSEngineDBFacade::toString(contentType)
							+ ", referenceContentType: "
								+ MMSEngineDBFacade::toString(referenceContentType)
							;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}

					int64_t sourceMediaItemKey;
					int64_t sourcePhysicalPathKey;
					string sourceFileName;
					string sourceRelativePath;
					{
						if (dependencyType == Validator::DependencyType::MediaItemKey)
						{
							sourceMediaItemKey = key;

							bool warningIfMissing = true;
							tuple<int64_t, int, string, string, int64_t, bool> sourcePhysicalPathDetails =
								_mmsEngineDBFacade->getSourcePhysicalPath(sourceMediaItemKey, warningIfMissing);
							tie(sourcePhysicalPathKey, ignore, sourceRelativePath, sourceFileName,
									ignore, ignore) = sourcePhysicalPathDetails;
						}
						else
						{
							sourcePhysicalPathKey = key;

							bool warningIfMissing = false;
							tuple<int64_t,MMSEngineDBFacade::ContentType,string,string, string, int64_t,
								string, string> mediaItemDetails =
								_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
									workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

							tie(sourceMediaItemKey,ignore, ignore, ignore, ignore,
								ignore, sourceFileName, sourceRelativePath) = mediaItemDetails;
						}
					}

					// check if the profile is already present for the source content
					{
						try
						{
							bool warningIfMissing = true;
							int64_t localPhysicalPathKey = _mmsEngineDBFacade->getPhysicalPathDetails(
								sourceMediaItemKey, encodingProfileKey, warningIfMissing);

							string errorMessage = __FILEREF__ + "Content profile is already present"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", sourceMediaItemKey: " + to_string(sourceMediaItemKey)
								+ ", encodingProfileKey: " + to_string(encodingProfileKey)
								;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
						catch(MediaItemKeyNotFound e)
						{
						}
					}

					int64_t sourceDurationInMilliSecs = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
							sourceMediaItemKey, sourcePhysicalPathKey);

					string sourceFileExtension;
					{
						size_t extensionIndex = sourceFileName.find_last_of(".");
						if (extensionIndex == string::npos)
						{
							string errorMessage = __FILEREF__ + "No extension find in the asset file name"
								+ ", encodingItem->_encodeData->_fileName: " + sourceFileName;
							_logger->error(errorMessage);

							throw runtime_error(errorMessage);
						}
						sourceFileExtension = sourceFileName.substr(extensionIndex);
					}

					string mmsSourceAssetPathName;
					{
						tuple<string, int, string, string, int64_t, string> physicalPathDetails =
							_mmsStorage->getPhysicalPathDetails(sourcePhysicalPathKey);
						tie(mmsSourceAssetPathName, ignore, ignore, ignore, ignore, ignore)
							= physicalPathDetails;
					}

					// calculate delivery URL in case of an external encoder
					string sourcePhysicalDeliveryURL;
					{
						int64_t utcNow;
						{
							chrono::system_clock::time_point now = chrono::system_clock::now();
							utcNow = chrono::system_clock::to_time_t(now);
						}

						pair<string, string> deliveryAuthorizationDetails =
							_mmsDeliveryAuthorization->createDeliveryAuthorization(
							-1,	// userKey,
							workspace,
							"",	// clientIPAddress,

							-1,	// mediaItemKey,
							"",	// uniqueName,
							-1,	// encodingProfileKey,
							"",	// encodingProfileLabel,

							sourcePhysicalPathKey,

							-1,	// ingestionJobKey,	(in case of live)
							-1,	// deliveryCode,

							365 * 24 * 60 * 60,	// ttlInSeconds, 365 days!!!
							999999,	// maxRetries,
							false,	// save,
							"MMS_SignedToken",	// deliveryType,

							false,	// warningIfMissingMediaItemKey,
							true,	// filteredByStatistic
							""		// userId (it is not needed it filteredByStatistic is true
						);

						tie(sourcePhysicalDeliveryURL, ignore) = deliveryAuthorizationDetails;
					}

					string encodedFileName;
					{
						string fileFormat = encodingProfileDetailsRoot.get("FileFormat", "").asString();
						string fileFormatLowerCase;
						fileFormatLowerCase.resize(fileFormat.size());
						transform(fileFormat.begin(), fileFormat.end(), fileFormatLowerCase.begin(),
							[](unsigned char c){return tolower(c); } );

						encodedFileName =
							to_string(ingestionJobKey)
							+ "_"
							+ to_string(encodingProfileKey);

						if (fileFormatLowerCase == "hls"
							|| fileFormatLowerCase == "dash")
						{
							;
						}
						else
						{
							encodedFileName.append(".");
							encodedFileName.append(fileFormatLowerCase);
						}
					}
    
					string sourceTranscoderStagingAssetPathName;	// used in case of external encoder
					string encodedTranscoderStagingAssetPathName;	// used in case of external encoder
					string encodedNFSStagingAssetPathName;
					{
						bool removeLinuxPathIfExist = false;
						bool neededForTranscoder = true;
						sourceTranscoderStagingAssetPathName = _mmsStorage->getStagingAssetPathName(
							neededForTranscoder,
							workspace->_directoryName,	// workspaceDirectoryName
							to_string(ingestionJobKey),		// directoryNamePrefix
							"/",							// relativePath,
							sourceFileName,				// fileName
							-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
							-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
							removeLinuxPathIfExist);

						encodedTranscoderStagingAssetPathName = _mmsStorage->getStagingAssetPathName(
							neededForTranscoder,
							workspace->_directoryName,	// workspaceDirectoryName
							to_string(ingestionJobKey),					// directoryNamePrefix
							"/",										// relativePath,
							// as specified by doc (TASK_01_Add_Content_JSON_Format.txt),
							// in case of hls and external encoder (binary is ingested through PUSH),
							// the directory inside the tar.gz has to be 'content'
							"content",	// encodedFileName,
							-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
							-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
							removeLinuxPathIfExist);

						neededForTranscoder = false;
						encodedNFSStagingAssetPathName = _mmsStorage->getStagingAssetPathName(
							neededForTranscoder,
							workspace->_directoryName,	// workspaceDirectoryName
							to_string(ingestionJobKey),		// directoryNamePrefix
							"/",							// relativePath,
							encodedFileName,				// fileName
							-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
							-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
							removeLinuxPathIfExist);
					}

					Json::Value videoTracksRoot(Json::arrayValue);
					Json::Value audioTracksRoot(Json::arrayValue);
					{
						if (contentType == MMSEngineDBFacade::ContentType::Video)
						{
							vector<tuple<int64_t, int, int64_t, int, int, string, string, long, string>> videoTracks;
							vector<tuple<int64_t, int, int64_t, long, string, long, int, string>> audioTracks;

							int64_t sourceMediaItemKey = -1;
							_mmsEngineDBFacade->getVideoDetails(
								sourceMediaItemKey, sourcePhysicalPathKey, videoTracks, audioTracks);

							for (tuple<int64_t, int, int64_t, int, int, string, string, long, string> videoTrack:
									videoTracks)
							{
								int trackIndex;
								tie(ignore, trackIndex, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
									= videoTrack;

								if (trackIndex != -1)
								{
									Json::Value videoTrackRoot;

									string field = "trackIndex";
									videoTrackRoot[field] = trackIndex;

									videoTracksRoot.append(videoTrackRoot);
								}
							}

							for (tuple<int64_t, int, int64_t, long, string, long, int, string> audioTrack:
									audioTracks)
							{
								int trackIndex;
								string language;
								tie(ignore, trackIndex, ignore, ignore, ignore, ignore, ignore, language)
									= audioTrack;

								if (trackIndex != -1 && language != "")
								{
									Json::Value audioTrackRoot;

									string field = "trackIndex";
									audioTrackRoot[field] = trackIndex;

									field = "language";
									audioTrackRoot[field] = language;

									audioTracksRoot.append(audioTrackRoot);
								}
							}
						}
						else if (contentType == MMSEngineDBFacade::ContentType::Audio)
						{
							vector<tuple<int64_t, int, int64_t, long, string, long, int, string>> audioTracks;

							int64_t sourceMediaItemKey = -1;
							_mmsEngineDBFacade->getAudioDetails(
								sourceMediaItemKey, sourcePhysicalPathKey, audioTracks);

							for (tuple<int64_t, int, int64_t, long, string, long, int, string> audioTrack:
									audioTracks)
							{
								int trackIndex;
								string language;
								tie(ignore, trackIndex, ignore, ignore, ignore, ignore, ignore, language)
									= audioTrack;

								if (trackIndex != -1 && language != "")
								{
									Json::Value audioTrackRoot;

									string field = "trackIndex";
									audioTrackRoot[field] = trackIndex;

									field = "language";
									audioTrackRoot[field] = language;

									audioTracksRoot.append(audioTrackRoot);
								}
							}
						}
					}

					Json::Value sourceRoot;

					string field = "stopIfReferenceProcessingError";
					sourceRoot[field] = stopIfReferenceProcessingError;

					field = "sourceMediaItemKey";
					sourceRoot[field] = sourceMediaItemKey;

					field = "sourcePhysicalPathKey";
					sourceRoot[field] = sourcePhysicalPathKey;

					field = "mmsSourceAssetPathName";
					sourceRoot[field] = mmsSourceAssetPathName;

					field = "sourcePhysicalDeliveryURL";
					sourceRoot[field] = sourcePhysicalDeliveryURL;

					field = "sourceDurationInMilliSecs";
					sourceRoot[field] = sourceDurationInMilliSecs;

					field = "sourceFileName";
					sourceRoot[field] = sourceFileName;

					field = "sourceRelativePath";
					sourceRoot[field] = sourceRelativePath;

					field = "sourceFileExtension";
					sourceRoot[field] = sourceFileExtension;

					field = "videoTracks";
					sourceRoot[field] = videoTracksRoot;

					field = "audioTracks";
					sourceRoot[field] = audioTracksRoot;

					field = "sourceTranscoderStagingAssetPathName";
					sourceRoot[field] = sourceTranscoderStagingAssetPathName;

					field = "encodedTranscoderStagingAssetPathName";
					sourceRoot[field] = encodedTranscoderStagingAssetPathName;

					field = "encodedNFSStagingAssetPathName";
					sourceRoot[field] = encodedNFSStagingAssetPathName;

					sourcesToBeEncodedRoot.append(sourceRoot);
				}
				catch(runtime_error e)
				{
					_logger->error(__FILEREF__ + "processing media input failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", referenceContentType: "
							+ MMSEngineDBFacade::toString(referenceContentType)
						+ ", key: " + to_string(key)
					);

					if (stopIfReferenceProcessingError)
						throw e;
				}
			}
		}

		_mmsEngineDBFacade->addEncodingJob (workspace, ingestionJobKey,
			contentType, encodingPriority,
			encodingProfileKey, encodingProfileDetailsRoot,
			sourcesToBeEncodedRoot,
			_mmsWorkflowIngestionURL, _mmsBinaryIngestionURL);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageEncodeTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageEncodeTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageVideoSpeedTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong media number to be encoded"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::VideoSpeedType videoSpeedType;
        string field = "SpeedType";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            videoSpeedType = MMSEngineDBFacade::VideoSpeedType::SlowDown;
        }
        else
        {
            videoSpeedType = MMSEngineDBFacade::toVideoSpeedType(
					parametersRoot.get(field, "SlowDown").asString());
        }

		int videoSpeedSize = 3;
        field = "SpeedSize";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            videoSpeedSize = JSONUtils::asInt(parametersRoot, field, 3);
        }

        MMSEngineDBFacade::EncodingPriority encodingPriority;
        field = "EncodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = static_cast<MMSEngineDBFacade::EncodingPriority>(
				workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority = MMSEngineDBFacade::toEncodingPriority(
					parametersRoot.get(field, "XXX").asString());
        }

		// Since it was a copy anc past, next commant has to be checked.
		// It is not possible to manage more than one encode because:
		// 1. inside _mmsEngineDBFacade->addEncodingJob, the ingestionJob is updated to encodingQueue
		//		and the second call will fail (because the update of the ingestion was already done
		//	2. The ingestionJob mantains the status of the encoding, how would be managed
		//		the status in case of more than one encoding?
        // for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType>&
		// 		keyAndDependencyType: dependencies)
        MMSEngineDBFacade::ContentType referenceContentType;
		int64_t sourceMediaItemKey;
		int64_t sourcePhysicalPathKey;
        {
            int64_t key;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;
            
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType	= dependencies[0];
            tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType == Validator::DependencyType::MediaItemKey)
			{
				sourceMediaItemKey = key;

				sourcePhysicalPathKey = -1;
			}
			else
			{
				sourcePhysicalPathKey = key;
            
				bool warningIfMissing = false;
				tuple<int64_t,MMSEngineDBFacade::ContentType,string,string, string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
					workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

				MMSEngineDBFacade::ContentType localContentType;
				string localTitle;
				string userData;
                string ingestionDate;
				int64_t localIngestionJobKey;
				tie(sourceMediaItemKey,localContentType, localTitle, userData, ingestionDate,
						localIngestionJobKey, ignore, ignore)
                    = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
			}
		}

// 2021-08-26: si dovrebbe cambiare l'implementazione:
//	aggiungere la gestione di multi-video-speed: l'encoding dovrebbe eseguire il processing in modo sequenziale e utilizzare il bool
//	stopIfReferenceProcessingError per decidere se interrompere in caso di errore
		_mmsEngineDBFacade->addEncoding_VideoSpeed (workspace, ingestionJobKey,
			sourceMediaItemKey, sourcePhysicalPathKey,
			videoSpeedType, videoSpeedSize, encodingPriority);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageVideoSpeedTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageVideoSpeedTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::managePictureInPictureTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 2)
        {
            string errorMessage = __FILEREF__ + "Wrong number of dependencies"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::EncodingPriority encodingPriority;
        string field = "EncodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = 
                    static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority =
                MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
        }

        bool secondVideoOverlayedOnFirst;
        field = "SecondVideoOverlayedOnFirst";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
			secondVideoOverlayedOnFirst = true;
        }
		else
			secondVideoOverlayedOnFirst = JSONUtils::asBool(parametersRoot, field, false);

        bool soundOfFirstVideo;
        field = "SoundOfFirstVideo";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
			soundOfFirstVideo = true;
        }
		else
			soundOfFirstVideo = JSONUtils::asBool(parametersRoot, field, false);

        string overlayPosition_X_InPixel;
        field = "OverlayPosition_X_InPixel";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
			overlayPosition_X_InPixel = "0";
        }
		else
			overlayPosition_X_InPixel = parametersRoot.get(field, "XXX").asString();

        string overlayPosition_Y_InPixel;
        field = "OverlayPosition_Y_InPixel";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
			overlayPosition_Y_InPixel = "0";
        }
		else
			overlayPosition_Y_InPixel = parametersRoot.get(field, "XXX").asString();

        string overlay_Width_InPixel;
        field = "Overlay_Width_InPixel";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
			overlay_Width_InPixel = "100";
        }
		else
			overlay_Width_InPixel = parametersRoot.get(field, "XXX").asString();

        string overlay_Height_InPixel;
        field = "Overlay_Height_InPixel";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
			overlay_Height_InPixel = "100";
        }
		else
			overlay_Height_InPixel = parametersRoot.get(field, "XXX").asString();

        int64_t sourceMediaItemKey_1;
        int64_t sourcePhysicalPathKey_1;
        tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType_1 = dependencies[0];

        int64_t key_1;
        MMSEngineDBFacade::ContentType referenceContentType_1;
        Validator::DependencyType dependencyType_1;
		bool stopIfReferenceProcessingError_1;

        tie(key_1, referenceContentType_1, dependencyType_1, stopIfReferenceProcessingError_1)
			= keyAndDependencyType_1;

        if (dependencyType_1 == Validator::DependencyType::MediaItemKey)
        {
            sourceMediaItemKey_1 = key_1;

            sourcePhysicalPathKey_1 = -1;
        }
        else if (dependencyType_1 == Validator::DependencyType::PhysicalPathKey)
        {
            sourcePhysicalPathKey_1 = key_1;
            
            bool warningIfMissing = false;
            tuple<int64_t,MMSEngineDBFacade::ContentType,string,string, string,int64_t, string, string>
				mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                    workspace->_workspaceKey, sourcePhysicalPathKey_1, warningIfMissing);

            tie(sourceMediaItemKey_1, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
				= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
        }
		else
        {
            string errorMessage = __FILEREF__ + "Wrong dependencyType"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", dependencyType_1: " + to_string(static_cast<int>(dependencyType_1));
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        int64_t sourceMediaItemKey_2;
        int64_t sourcePhysicalPathKey_2;
        tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
			keyAndDependencyType_2 = dependencies[1];

        int64_t key_2;
        MMSEngineDBFacade::ContentType referenceContentType_2;
        Validator::DependencyType dependencyType_2;
		bool stopIfReferenceProcessingError_2;

        tie(key_2, referenceContentType_2, dependencyType_2, stopIfReferenceProcessingError_2)
			= keyAndDependencyType_2;

        if (dependencyType_2 == Validator::DependencyType::MediaItemKey)
        {
            sourceMediaItemKey_2 = key_2;

            sourcePhysicalPathKey_2 = -1;
        }
        else if (dependencyType_2 == Validator::DependencyType::PhysicalPathKey)
        {
            sourcePhysicalPathKey_2 = key_2;
            
            bool warningIfMissing = false;
            tuple<int64_t,MMSEngineDBFacade::ContentType,string,string, string,int64_t, string, string>
				mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                    workspace->_workspaceKey, sourcePhysicalPathKey_2, warningIfMissing);

            tie(sourceMediaItemKey_2, ignore, ignore, ignore, ignore, ignore, ignore, ignore)
				= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
        }
		else
        {
            string errorMessage = __FILEREF__ + "Wrong dependencyType"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", dependencyType_2: " + to_string(static_cast<int>(dependencyType_2));
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		int64_t mainMediaItemKey;
		int64_t mainPhysicalPathKey;
		int64_t overlayMediaItemKey;
		int64_t overlayPhysicalPathKey;

		bool soundOfMain;
        if (secondVideoOverlayedOnFirst)
		{
			mainMediaItemKey			= sourceMediaItemKey_1;
			mainPhysicalPathKey			= sourcePhysicalPathKey_1;
			overlayMediaItemKey			= sourceMediaItemKey_2;
			overlayPhysicalPathKey		= sourcePhysicalPathKey_2;

			if (soundOfFirstVideo)
				soundOfMain = true;
			else
				soundOfMain = false;
		}
		else
		{
			mainMediaItemKey			= sourceMediaItemKey_2;
			mainPhysicalPathKey			= sourcePhysicalPathKey_2;
			overlayMediaItemKey			= sourceMediaItemKey_1;
			overlayPhysicalPathKey		= sourcePhysicalPathKey_1;

			if (soundOfFirstVideo)
				soundOfMain = false;
			else
				soundOfMain = true;
		}

		_mmsEngineDBFacade->addEncoding_PictureInPictureJob (workspace, ingestionJobKey,
			mainMediaItemKey, mainPhysicalPathKey,
			overlayMediaItemKey, overlayPhysicalPathKey,
			overlayPosition_X_InPixel, overlayPosition_Y_InPixel,
			overlay_Width_InPixel, overlay_Height_InPixel,
			soundOfMain, encodingPriority);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "managePictureInPictureTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "managePictureInPictureTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageIntroOutroOverlayTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 3)
        {
            string errorMessage = __FILEREF__ + "Wrong number of dependencies"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::EncodingPriority encodingPriority;
        string field = "EncodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = 
                    static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority =
                MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
        }

		int64_t introVideoPhysicalPathKey;
		string introVideoAssetPathName;
		int64_t introVideoDurationInMilliSeconds;
		{
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[0];

			int64_t key;
			MMSEngineDBFacade::ContentType referenceContentType;
			Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType== Validator::DependencyType::MediaItemKey)
			{
				int64_t sourceMediaItemKey = key;

				bool warningIfMissing = false;
				introVideoPhysicalPathKey = _mmsEngineDBFacade->getPhysicalPathDetails(
					sourceMediaItemKey,
					-1,	// encodingProfileKey
					warningIfMissing);
			}
			else if (dependencyType == Validator::DependencyType::PhysicalPathKey)
			{
				introVideoPhysicalPathKey = key;
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong dependencyType"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", dependencyType: " + to_string(static_cast<int>(dependencyType));
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(introVideoPhysicalPathKey);
				tie(introVideoAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathDetails;
			}

			introVideoDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
				-1, introVideoPhysicalPathKey);
		}

		int64_t mainVideoPhysicalPathKey;
		string mainVideoAssetPathName;
		int64_t mainVideoDurationInMilliSeconds;
		{
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[1];

			int64_t key;
			MMSEngineDBFacade::ContentType referenceContentType;
			Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType== Validator::DependencyType::MediaItemKey)
			{
				int64_t sourceMediaItemKey = key;

				bool warningIfMissing = false;
				mainVideoPhysicalPathKey = _mmsEngineDBFacade->getPhysicalPathDetails(
					sourceMediaItemKey,
					-1,	// encodingProfileKey
					warningIfMissing);
			}
			else if (dependencyType == Validator::DependencyType::PhysicalPathKey)
			{
				mainVideoPhysicalPathKey = key;
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong dependencyType"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", dependencyType: " + to_string(static_cast<int>(dependencyType));
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(mainVideoPhysicalPathKey);
				tie(mainVideoAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathDetails;
			}

			mainVideoDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
				-1, mainVideoPhysicalPathKey);
		}

		int64_t outroVideoPhysicalPathKey;
		string outroVideoAssetPathName;
		int64_t outroVideoDurationInMilliSeconds;
		{
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[2];

			int64_t key;
			MMSEngineDBFacade::ContentType referenceContentType;
			Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType== Validator::DependencyType::MediaItemKey)
			{
				int64_t sourceMediaItemKey = key;

				bool warningIfMissing = false;
				outroVideoPhysicalPathKey = _mmsEngineDBFacade->getPhysicalPathDetails(
					sourceMediaItemKey,
					-1,	// encodingProfileKey
					warningIfMissing);
			}
			else if (dependencyType == Validator::DependencyType::PhysicalPathKey)
			{
				outroVideoPhysicalPathKey = key;
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong dependencyType"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", dependencyType: " + to_string(static_cast<int>(dependencyType));
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(outroVideoPhysicalPathKey);
				tie(outroVideoAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathDetails;
			}

			outroVideoDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
				-1, outroVideoPhysicalPathKey);
		}

		int64_t encodingProfileKey;
		Json::Value encodingProfileDetailsRoot;
		{
			string keyField = "EncodingProfileKey";
			string labelField = "EncodingProfileLabel";
			if (JSONUtils::isMetadataPresent(parametersRoot, keyField))
			{
				encodingProfileKey = JSONUtils::asInt64(parametersRoot, keyField, 0);
			}
			else if (JSONUtils::isMetadataPresent(parametersRoot, labelField))
			{
				string encodingProfileLabel = parametersRoot.get(labelField, "").asString();

				MMSEngineDBFacade::ContentType videoContentType = MMSEngineDBFacade::ContentType::Video;
				encodingProfileKey = _mmsEngineDBFacade->getEncodingProfileKeyByLabel(
					workspace->_workspaceKey, videoContentType, encodingProfileLabel);
			}
			else
			{
				string errorMessage = __FILEREF__ + "Both fields are not present or it is null"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", Field: " + keyField
					+ ", Field: " + labelField
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				string jsonEncodingProfile;

				tuple<string, MMSEngineDBFacade::ContentType, MMSEngineDBFacade::DeliveryTechnology, string>
					encodingProfileDetails = _mmsEngineDBFacade->getEncodingProfileDetailsByKey(
					workspace->_workspaceKey, encodingProfileKey);
				tie(ignore, ignore, ignore, jsonEncodingProfile) = encodingProfileDetails;

				{
					Json::CharReaderBuilder builder;
					Json::CharReader* reader = builder.newCharReader();
					string errors;

					bool parsingSuccessful = reader->parse(jsonEncodingProfile.c_str(),
						jsonEncodingProfile.c_str() + jsonEncodingProfile.size(), 
						&encodingProfileDetailsRoot,
						&errors);
					delete reader;

					if (!parsingSuccessful)
					{
						string errorMessage = __FILEREF__ + "failed to parse 'parameters'"
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", errors: " + errors
						;
						_logger->error(errorMessage);

						throw runtime_error(errorMessage);
					}
				}
			}
		}

		_mmsEngineDBFacade->addEncoding_IntroOutroOverlayJob (workspace, ingestionJobKey,
			encodingProfileKey,
			encodingProfileDetailsRoot,

			introVideoPhysicalPathKey,
			introVideoAssetPathName,
			introVideoDurationInMilliSeconds,
			mainVideoPhysicalPathKey,
			mainVideoAssetPathName,
			mainVideoDurationInMilliSeconds,
			outroVideoPhysicalPathKey,
			outroVideoAssetPathName,
			outroVideoDurationInMilliSeconds,

			encodingPriority);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageIntroOutroOverlayTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageIntroOutroOverlayTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageOverlayImageOnVideoTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 2)
        {
            string errorMessage = __FILEREF__ + "Wrong number of dependencies"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::EncodingPriority encodingPriority;
        string field = "EncodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = 
                    static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority =
                MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
        }

		int64_t sourceMediaItemKey_1;
		int64_t sourcePhysicalPathKey_1;
		MMSEngineDBFacade::ContentType referenceContentType_1;
		string mmsSourceAssetPathName_1;
		string sourcePhysicalDeliveryURL_1;
		{
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType_1 = dependencies[0];

			int64_t key_1;
			Validator::DependencyType dependencyType_1;
			bool stopIfReferenceProcessingError_1;

			tie(key_1, referenceContentType_1, dependencyType_1, stopIfReferenceProcessingError_1)
				= keyAndDependencyType_1;

			if (dependencyType_1 == Validator::DependencyType::MediaItemKey)
			{
				sourceMediaItemKey_1 = key_1;

				bool warningIfMissing = true;
				tuple<int64_t, int, string, string, int64_t, bool> sourcePhysicalPathDetails =
					_mmsEngineDBFacade->getSourcePhysicalPath(sourceMediaItemKey_1, warningIfMissing);
				tie(sourcePhysicalPathKey_1, ignore, ignore, ignore,
					ignore, ignore) = sourcePhysicalPathDetails;
			}
			else if (dependencyType_1 == Validator::DependencyType::PhysicalPathKey)
			{
				sourcePhysicalPathKey_1 = key_1;
            
				bool warningIfMissing = false;
				tuple<int64_t, MMSEngineDBFacade::ContentType, string, string,
					string,int64_t, string, string> mediaItemDetails =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
						workspace->_workspaceKey, sourcePhysicalPathKey_1, warningIfMissing);

				tie(sourceMediaItemKey_1, ignore, ignore, ignore, ignore,
					ignore, ignore, ignore) = mediaItemDetails;
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong dependencyType"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", dependencyType_1: " + to_string(static_cast<int>(dependencyType_1));
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(sourcePhysicalPathKey_1);
				tie(mmsSourceAssetPathName_1, ignore, ignore, ignore, ignore, ignore)
					= physicalPathDetails;
			}

			// calculate delivery URL in case of an external encoder
			{
				int64_t utcNow;
				{
					chrono::system_clock::time_point now = chrono::system_clock::now();
					utcNow = chrono::system_clock::to_time_t(now);
				}

				pair<string, string> deliveryAuthorizationDetails =
					_mmsDeliveryAuthorization->createDeliveryAuthorization(
					-1,	// userKey,
					workspace,
					"",	// clientIPAddress,

					-1,	// mediaItemKey,
					"",	// uniqueName,
					-1,	// encodingProfileKey,
					"",	// encodingProfileLabel,

					sourcePhysicalPathKey_1,

					-1,	// ingestionJobKey,	(in case of live)
					-1,	// deliveryCode,

					365 * 24 * 60 * 60,	// ttlInSeconds, 365 days!!!
					999999,	// maxRetries,
					false,	// save,
					"MMS_SignedToken",	// deliveryType,

					false,	// warningIfMissingMediaItemKey,
					true,	// filteredByStatistic
					""		// userId (it is not needed it filteredByStatistic is true
				);

				tie(sourcePhysicalDeliveryURL_1, ignore) = deliveryAuthorizationDetails;
			}
		}

		int64_t sourceMediaItemKey_2;
		int64_t sourcePhysicalPathKey_2;
		MMSEngineDBFacade::ContentType referenceContentType_2;
		string mmsSourceAssetPathName_2;
		string sourcePhysicalDeliveryURL_2;
		{
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType_2 = dependencies[1];

			int64_t key_2;
			Validator::DependencyType dependencyType_2;
			bool stopIfReferenceProcessingError_2;

			tie(key_2, referenceContentType_2, dependencyType_2, stopIfReferenceProcessingError_2)
				= keyAndDependencyType_2;

			if (dependencyType_2 == Validator::DependencyType::MediaItemKey)
			{
				sourceMediaItemKey_2 = key_2;

				bool warningIfMissing = true;
				tuple<int64_t, int, string, string, int64_t, bool> sourcePhysicalPathDetails =
					_mmsEngineDBFacade->getSourcePhysicalPath(sourceMediaItemKey_2, warningIfMissing);
				tie(sourcePhysicalPathKey_2, ignore, ignore, ignore,
					ignore, ignore) = sourcePhysicalPathDetails;
			}
			else if (dependencyType_2 == Validator::DependencyType::PhysicalPathKey)
			{
				sourcePhysicalPathKey_2 = key_2;
            
				bool warningIfMissing = false;
				tuple<int64_t, MMSEngineDBFacade::ContentType, string, string,
					string,int64_t, string, string> mediaItemDetails =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
						workspace->_workspaceKey, sourcePhysicalPathKey_2, warningIfMissing);

				tie(sourceMediaItemKey_2, ignore, ignore, ignore, ignore,
					ignore, ignore, ignore) = mediaItemDetails;
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong dependencyType"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", dependencyType_2: " + to_string(static_cast<int>(dependencyType_2));
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(sourcePhysicalPathKey_2);
				tie(mmsSourceAssetPathName_2, ignore, ignore, ignore, ignore, ignore)
					= physicalPathDetails;
			}

			// calculate delivery URL in case of an external encoder
			{
				int64_t utcNow;
				{
					chrono::system_clock::time_point now = chrono::system_clock::now();
					utcNow = chrono::system_clock::to_time_t(now);
				}

				pair<string, string> deliveryAuthorizationDetails =
					_mmsDeliveryAuthorization->createDeliveryAuthorization(
					-1,	// userKey,
					workspace,
					"",	// clientIPAddress,

					-1,	// mediaItemKey,
					"",	// uniqueName,
					-1,	// encodingProfileKey,
					"",	// encodingProfileLabel,

					sourcePhysicalPathKey_2,

					-1,	// ingestionJobKey,	(in case of live)
					-1,	// deliveryCode,

					365 * 24 * 60 * 60,	// ttlInSeconds, 365 days!!!
					999999,	// maxRetries,
					false,	// save,
					"MMS_SignedToken",	// deliveryType,

					false,	// warningIfMissingMediaItemKey,
					true,	// filteredByStatistic
					""		// userId (it is not needed it filteredByStatistic is true
				);

				tie(sourcePhysicalDeliveryURL_2, ignore) = deliveryAuthorizationDetails;
			}
		}

		int64_t sourceVideoMediaItemKey;
		int64_t sourceVideoPhysicalPathKey;
		string mmsSourceVideoAssetPathName;
		string sourceVideoPhysicalDeliveryURL;

		int64_t sourceImageMediaItemKey;
		int64_t sourceImagePhysicalPathKey;
		string mmsSourceImageAssetPathName;
		string sourceImagePhysicalDeliveryURL;

		if (referenceContentType_1 == MMSEngineDBFacade::ContentType::Video
			&& referenceContentType_2 == MMSEngineDBFacade::ContentType::Image)
		{
			sourceVideoMediaItemKey = sourceMediaItemKey_1;
			sourceVideoPhysicalPathKey = sourcePhysicalPathKey_1;
			mmsSourceVideoAssetPathName = mmsSourceAssetPathName_1;
			sourceVideoPhysicalDeliveryURL = sourcePhysicalDeliveryURL_1;

			sourceImageMediaItemKey = sourceMediaItemKey_2;
			sourceImagePhysicalPathKey = sourcePhysicalPathKey_2;
			mmsSourceImageAssetPathName = mmsSourceAssetPathName_2;
			sourceImagePhysicalDeliveryURL = sourcePhysicalDeliveryURL_2;
		}
		else if (referenceContentType_1 == MMSEngineDBFacade::ContentType::Image
			&& referenceContentType_2 == MMSEngineDBFacade::ContentType::Video)
		{
			sourceVideoMediaItemKey = sourceMediaItemKey_2;
			sourceVideoPhysicalPathKey = sourcePhysicalPathKey_2;
			mmsSourceVideoAssetPathName = mmsSourceAssetPathName_2;
			sourceVideoPhysicalDeliveryURL = sourcePhysicalDeliveryURL_2;

			sourceImageMediaItemKey = sourceMediaItemKey_1;
			sourceImagePhysicalPathKey = sourcePhysicalPathKey_1;
			mmsSourceImageAssetPathName = mmsSourceAssetPathName_1;
			sourceImagePhysicalDeliveryURL = sourcePhysicalDeliveryURL_1;
		}
		else
		{
			string errorMessage = __FILEREF__ + "OverlayImageOnVideo is not receiving one Video and one Image"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", referenceContentType_1: " + MMSEngineDBFacade::toString(referenceContentType_1)
				+ ", sourceMediaItemKey_1: " + to_string(sourceMediaItemKey_1)
				+ ", sourcePhysicalPathKey_1: " + to_string(sourcePhysicalPathKey_1)
				+ ", contentType_2: " + MMSEngineDBFacade::toString(referenceContentType_2)
				+ ", sourceMediaItemKey_2: " + to_string(sourceMediaItemKey_2)
				+ ", sourcePhysicalPathKey_2: " + to_string(sourcePhysicalPathKey_2)
			;
			_logger->error(errorMessage);

			throw runtime_error(errorMessage);
		}

		string sourceFileName;
		string encodedFileName;
		{
			size_t extensionIndex = mmsSourceVideoAssetPathName.find_last_of(".");
			if (extensionIndex == string::npos)
			{
				string errorMessage = __FILEREF__ + "No extension find in the asset file name"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", mmsSourceVideoAssetPathName: " + mmsSourceVideoAssetPathName;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			encodedFileName = to_string(ingestionJobKey)
				+ "_overlayedimage"                                                                   
				+  mmsSourceVideoAssetPathName.substr(extensionIndex);     

			size_t sourceFileNameIndex = mmsSourceVideoAssetPathName.find_last_of("/");
			if (sourceFileNameIndex == string::npos)
			{
				string errorMessage = __FILEREF__ + "No sourceFileNameIndex find in the asset file name"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", mmsSourceVideoAssetPathName: " + mmsSourceVideoAssetPathName;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			sourceFileName = mmsSourceVideoAssetPathName.substr(sourceFileNameIndex + 1);
		}

		string sourceVideoTranscoderStagingAssetPathName;	// used in case of external encoder
		string encodedTranscoderStagingAssetPathName;	// used in case of external encoder
		string encodedNFSStagingAssetPathName;
		{
			bool removeLinuxPathIfExist = false;
			bool neededForTranscoder = true;
			sourceVideoTranscoderStagingAssetPathName = _mmsStorage->getStagingAssetPathName(
				neededForTranscoder,
				workspace->_directoryName,	// workspaceDirectoryName
				to_string(ingestionJobKey),		// directoryNamePrefix
				"/",							// relativePath,
				sourceFileName,				// fileName
				-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
				-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
				removeLinuxPathIfExist);

			encodedTranscoderStagingAssetPathName = _mmsStorage->getStagingAssetPathName(
				neededForTranscoder,
				workspace->_directoryName,	// workspaceDirectoryName
				to_string(ingestionJobKey),					// directoryNamePrefix
				"/",										// relativePath,
				// as specified by doc (TASK_01_Add_Content_JSON_Format.txt),
				// in case of hls and external encoder (binary is ingested through PUSH),
				// the directory inside the tar.gz has to be 'content'
				"content",	// encodedFileName,
				-1, // _encodingItem->_mediaItemKey, not used because encodedFileName is not ""
				-1, // _encodingItem->_physicalPathKey, not used because encodedFileName is not ""
				removeLinuxPathIfExist);

			string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(workspace);
			encodedNFSStagingAssetPathName = workspaceIngestionRepository + "/" + encodedFileName;
		}

		int64_t videoDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
			sourceVideoMediaItemKey, sourceVideoPhysicalPathKey);

        _mmsEngineDBFacade->addEncoding_OverlayImageOnVideoJob (workspace, ingestionJobKey,
			sourceVideoMediaItemKey, sourceVideoPhysicalPathKey, videoDurationInMilliSeconds,
			mmsSourceVideoAssetPathName, sourceVideoPhysicalDeliveryURL,
			sourceImageMediaItemKey, sourceImagePhysicalPathKey,
			mmsSourceImageAssetPathName, sourceImagePhysicalDeliveryURL,
			sourceVideoTranscoderStagingAssetPathName,
			encodedTranscoderStagingAssetPathName,
			encodedNFSStagingAssetPathName,
			encodingPriority);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageOverlayImageOnVideoTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageOverlayImageOnVideoTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::manageOverlayTextOnVideoTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {

        if (dependencies.size() != 1)
        {
            string errorMessage = __FILEREF__ + "Wrong number of dependencies"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        MMSEngineDBFacade::EncodingPriority encodingPriority;
        string field = "encodingPriority";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            encodingPriority = 
                    static_cast<MMSEngineDBFacade::EncodingPriority>(workspace->_maxEncodingPriority);
        }
        else
        {
            encodingPriority =
                MMSEngineDBFacade::toEncodingPriority(parametersRoot.get(field, "XXX").asString());
        }

		string videoFileNameExtension;
		int64_t sourceDurationInMilliSeconds;
		string sourceAssetPathName;
		{
			int64_t sourceMediaItemKey;
			int64_t sourcePhysicalPathKey;
			string sourceRelativePath;
			string sourceFileName;

			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[0];

			int64_t key;
			MMSEngineDBFacade::ContentType referenceContentType;
			Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

			tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

			if (dependencyType == Validator::DependencyType::MediaItemKey)
			{
				sourceMediaItemKey = key;

				bool warningIfMissing = true;
				tuple<int64_t, int, string, string, int64_t, bool> sourcePhysicalPathDetails =
					_mmsEngineDBFacade->getSourcePhysicalPath(sourceMediaItemKey, warningIfMissing);
				tie(sourcePhysicalPathKey, ignore, sourceRelativePath, sourceFileName,
					ignore, ignore) = sourcePhysicalPathDetails;
			}
			else
			{
				sourcePhysicalPathKey = key;

				bool warningIfMissing = false;
				tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
					_mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
						workspace->_workspaceKey, sourcePhysicalPathKey, warningIfMissing);

				tie(sourceMediaItemKey, ignore, ignore, ignore, ignore, ignore,
					sourceFileName, sourceRelativePath)
					= mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
			}

			{
				tuple<string, int, string, string, int64_t, string> physicalPathDetails =
					_mmsStorage->getPhysicalPathDetails(sourcePhysicalPathKey);
				tie(sourceAssetPathName, ignore, ignore, ignore, ignore, ignore)
					= physicalPathDetails;
			}

			sourceDurationInMilliSeconds = _mmsEngineDBFacade->getMediaDurationInMilliseconds(
				sourceMediaItemKey, sourcePhysicalPathKey);

			{
				size_t extensionIndex = sourceFileName.find_last_of(".");
				if (extensionIndex == string::npos)
				{
					string errorMessage = __FILEREF__ + "No extension find in the asset file name"
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", sourceFileName: " + sourceFileName;
					_logger->error(errorMessage);

					throw runtime_error(errorMessage);
				}
				videoFileNameExtension = sourceFileName.substr(extensionIndex);
			}
		}

		_logger->info(__FILEREF__ + "addEncoding_OverlayTextOnVideoJob"
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", encodingPriority: " + MMSEngineDBFacade::toString(encodingPriority)
		);
        _mmsEngineDBFacade->addEncoding_OverlayTextOnVideoJob (
			workspace, ingestionJobKey, encodingPriority,

			sourceAssetPathName, sourceDurationInMilliSeconds,
			videoFileNameExtension
		);
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageOverlayTextOnVideoTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageOverlayTextOnVideoTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
}

void MMSEngineProcessor::emailNotificationThread(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot,
	vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>
		dependencies
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"emailNotificationThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

	try
	{
		string sParameters;
		{
			Json::StreamWriterBuilder wbuilder;
			sParameters = Json::writeString(wbuilder, parametersRoot);
		}

		_logger->info(__FILEREF__ + "emailNotificationThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): "
				+ to_string(_processorsThreadsNumber.use_count())
			+ ", dependencies.size: " + to_string(dependencies.size())
			+ ", sParameters: " + sParameters
		);

        string sDependencies;
		{
			for (tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType: dependencies)
			{
				try
				{
					int64_t key;
					MMSEngineDBFacade::ContentType referenceContentType;
					Validator::DependencyType dependencyType;
					bool stopIfReferenceProcessingError;

					tie(key, referenceContentType, dependencyType, stopIfReferenceProcessingError)
						= keyAndDependencyType;
        
					if (dependencyType == Validator::DependencyType::MediaItemKey)
					{
						bool warningIfMissing = false;

						tuple<MMSEngineDBFacade::ContentType, string, string, string, int64_t, int64_t>
							mediaItemDetails = _mmsEngineDBFacade->getMediaItemKeyDetails(
								workspace->_workspaceKey, key, warningIfMissing);
        
						MMSEngineDBFacade::ContentType contentType;
						string title;
						string userData;
						string ingestionDate;
						int64_t localIngestionJobKey;
						tie(contentType, title, userData, ingestionDate, ignore, localIngestionJobKey)
							= mediaItemDetails;

						sDependencies += string("MediaItemKey")
							+ ", mediaItemKey: " + to_string(key)
							+ ", title: " + title
							+ ". "
						;
					}
					else if (dependencyType == Validator::DependencyType::PhysicalPathKey)
					{
						bool warningIfMissing = false;
						tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
							mediaItemDetails = _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
								workspace->_workspaceKey, key, warningIfMissing);

						int64_t mediaItemKey;
						string title;
						MMSEngineDBFacade::ContentType localContentType;
						string userData;
						string ingestionDate;
						int64_t localIngestionJobKey;
						tie(mediaItemKey, localContentType, title, userData, ingestionDate,
							localIngestionJobKey, ignore, ignore) = mediaItemDetails;

						sDependencies += string("PhysicalPathKey")
							+ ", physicalPathKey: " + to_string(key)
							+ ", title: " + title
							+ ". "
						;
					}
					else // if (dependencyType == Validator::DependencyType::IngestionJobKey)
					{
						bool warningIfMissing = false;
						tuple<string, MMSEngineDBFacade::IngestionType, MMSEngineDBFacade::IngestionStatus,
							string, string> ingestionJobDetails = _mmsEngineDBFacade->getIngestionJobDetails(
								workspace->_workspaceKey, key);

						string label;
						MMSEngineDBFacade::IngestionType ingestionType;
						MMSEngineDBFacade::IngestionStatus ingestionStatus;
						string metaDataContent;
						string errorMessage;

						tie(label, ingestionType, ingestionStatus, metaDataContent, errorMessage)
							= ingestionJobDetails;

						sDependencies += string("<br>IngestionJob")
							+ ", dependencyType: " + to_string(static_cast<int>(dependencyType))
							+ ", ingestionJobKey: " + to_string(key)
							+ ", label: " + label
							+ ". "
						;
					}
				}
				catch(...)
				{
					string errorMessage = string("Exception processing dependencies")
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					;
					_logger->error(__FILEREF__ + errorMessage);

					throw runtime_error(errorMessage);
				}
			}
		}

        string sReferencies;
		string checkStreaming_streamingName;
		string checkStreaming_streamingUrl;
		{
			string field = "References";
			if (JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				Json::Value referencesRoot = parametersRoot[field];
				for (int referenceIndex = 0; referenceIndex < referencesRoot.size();
					referenceIndex++)
				{
					try
					{
						Json::Value referenceRoot = referencesRoot[referenceIndex];
						field = "ReferenceIngestionJobKey";
						if (JSONUtils::isMetadataPresent(referenceRoot, field))
						{
							int64_t referenceIngestionJobKey =
								JSONUtils::asInt64(referenceRoot, field, 0);

							string referenceLabel;
							MMSEngineDBFacade::IngestionType ingestionType;
							string parameters;
							string referenceErrorMessage;

							tuple<string, MMSEngineDBFacade::IngestionType,
								MMSEngineDBFacade::IngestionStatus,
								string, string> ingestionJobDetails =
								_mmsEngineDBFacade->getIngestionJobDetails(
										workspace->_workspaceKey, referenceIngestionJobKey);
							tie(referenceLabel, ingestionType, ignore, parameters,
								referenceErrorMessage) = ingestionJobDetails;

							sReferencies += string("<br>IngestionJob")
								+ ", ingestionType: " 
									+ MMSEngineDBFacade::toString(ingestionType)
								+ ", ingestionJobKey: " + to_string(referenceIngestionJobKey)
								+ ", label: " + referenceLabel
								+ ", errorMessage: " + referenceErrorMessage
								+ ". "
							;

							if (ingestionType ==
								MMSEngineDBFacade::IngestionType::CheckStreaming)
							{
								Json::Value parametersRoot;
								{
									Json::CharReaderBuilder builder;
									Json::CharReader* reader = builder.newCharReader();
									string errors;

									bool parsingSuccessful = reader->parse(parameters.c_str(),
										parameters.c_str() + parameters.size(), 
										&parametersRoot, &errors);
									delete reader;

									if (!parsingSuccessful)
									{
										string errorMessage = __FILEREF__
											+ "failed to parse the parameters"
											+ ", _processorIdentifier: "
												+ to_string(_processorIdentifier)
											+ ", ingestionJobKey: " + to_string(ingestionJobKey)
											+ ", errors: " + errors
											+ ", parameters: " + parameters
										;
										_logger->error(errorMessage);

										throw runtime_error(errorMessage);
									}
								}

								string inputType;
								field = "inputType";
								if (JSONUtils::isMetadataPresent(parametersRoot, field))
									inputType = parametersRoot.get(field, "").asString();

								if (inputType == "Channel")
								{
									field = "channelConfigurationLabel";
									if (JSONUtils::isMetadataPresent(parametersRoot,
										field))
									{
										checkStreaming_streamingName
											= parametersRoot.get(field, "").asString();

										bool warningIfMissing = false;
										tuple<int64_t, string, string, string, string, int64_t, string,
											int, string, int, int, string, int,
											int, int, int, int, int64_t>
											channelDetails =
											_mmsEngineDBFacade->getStreamDetails(
											workspace->_workspaceKey,
											checkStreaming_streamingName,
											warningIfMissing);

										string streamSourceType;
										tie(ignore, streamSourceType,
											ignore, checkStreaming_streamingUrl,
											ignore, ignore, ignore, ignore, ignore,
											ignore, ignore, ignore, ignore, ignore,
											ignore, ignore, ignore, ignore)
											= channelDetails;
									}
								}
								else
								{
									field = "streamingName";
									if (JSONUtils::isMetadataPresent(parametersRoot, field))
										checkStreaming_streamingName
											= parametersRoot.get(field, "").asString();
									field = "streamingUrl";
									if (JSONUtils::isMetadataPresent(parametersRoot, field))
										checkStreaming_streamingUrl
											= parametersRoot.get(field, "").asString();
								}
							}
						}
					}
					catch(...)
					{
						string errorMessage = string("Exception processing referencies")
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						;
						_logger->error(__FILEREF__ + errorMessage);

						throw runtime_error(errorMessage);
					}
				}
			}
		}

        string field = "ConfigurationLabel";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", Field: " + field;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        string configurationLabel = parametersRoot.get(field, "XXX").asString();

		string emailAddresses;
		string subject;
		string message;
        tuple<string, string, string> email = _mmsEngineDBFacade->getEMailByConfigurationLabel(
			workspace->_workspaceKey, configurationLabel);            
        tie(emailAddresses, subject, message) = email;

        field = "UserSubstitutions";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
		{
			Json::Value userSubstitutionsRoot = parametersRoot[field];

			for (int userSubstitutionIndex = 0;
				userSubstitutionIndex < userSubstitutionsRoot.size();
				userSubstitutionIndex++)
			{
				Json::Value userSubstitutionRoot = userSubstitutionsRoot[userSubstitutionIndex];

				field = "ToBeReplaced";
				if (!JSONUtils::isMetadataPresent(userSubstitutionRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", Field: " + field;
					_logger->warn(errorMessage);

					continue;
				}
				string strToBeReplaced = userSubstitutionRoot.get(field, "").asString();

				field = "ReplaceWith";
				if (!JSONUtils::isMetadataPresent(userSubstitutionRoot, field))
				{
					string errorMessage = __FILEREF__ + "Field is not present or it is null"
						+ ", Field: " + field;
					_logger->warn(errorMessage);

					continue;
				}
				string strToReplace = userSubstitutionRoot.get(field, "").asString();

				_logger->info(__FILEREF__ + "User substitution"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", strToBeReplaced: " + strToBeReplaced
					+ ", strToReplace: " + strToReplace
				);
				if (strToBeReplaced != "")
				{
					while (subject.find(strToBeReplaced) != string::npos)
						subject.replace(subject.find(strToBeReplaced), strToBeReplaced.length(),
							strToReplace);
					while (message.find(strToBeReplaced) != string::npos)
						message.replace(message.find(strToBeReplaced), strToBeReplaced.length(),
							strToReplace);
				}
			}
        }
		else
		{
			_logger->info(__FILEREF__ + "NO User substitution"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			);
		}

        {
            string strToBeReplaced = "${Dependencies}";
            string strToReplace = sDependencies;
            while (subject.find(strToBeReplaced) != string::npos)
                subject.replace(subject.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
            while (message.find(strToBeReplaced) != string::npos)
                message.replace(message.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
        }
        {
            string strToBeReplaced = "${Referencies}";
            string strToReplace = sReferencies;
            while (subject.find(strToBeReplaced) != string::npos)
                subject.replace(subject.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
            while (message.find(strToBeReplaced) != string::npos)
                message.replace(message.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
        }
        {
            string strToBeReplaced = "${CheckStreaming_streamingName}";
            string strToReplace = checkStreaming_streamingName;
            while (subject.find(strToBeReplaced) != string::npos)
                subject.replace(subject.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
            while (message.find(strToBeReplaced) != string::npos)
                message.replace(message.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
        }
        {
            string strToBeReplaced = "${CheckStreaming_streamingUrl}";
            string strToReplace = checkStreaming_streamingUrl;
            while (subject.find(strToBeReplaced) != string::npos)
                subject.replace(subject.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
            while (message.find(strToBeReplaced) != string::npos)
                message.replace(message.find(strToBeReplaced), strToBeReplaced.length(),
					strToReplace);
        }

        vector<string> emailBody;
        emailBody.push_back(message);

        EMailSender emailSender(_logger, _configuration);
		bool useMMSCCToo = false;
        emailSender.sendEmail(emailAddresses, subject, emailBody, useMMSCCToo);

        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_TaskSuccess"
            + ", errorMessage: " + ""
        );
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
        );
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "sendEmail failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
        return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "sendEmail failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
        return;
    }
}

void MMSEngineProcessor::checkStreamingThread(
	shared_ptr<long> processorsThreadsNumber,
	int64_t ingestionJobKey,
	shared_ptr<Workspace> workspace,
	Json::Value parametersRoot
)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"checkStreamingThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try
    {
		_logger->info(__FILEREF__ + "checkStreamingThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): "
				+ to_string(_processorsThreadsNumber.use_count())
		);

        string field = "inputType";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", Field: " + field;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        string inputType = parametersRoot.get(field, "").asString();

		string streamingUrl;
		if (inputType == "Channel")
		{
			string field = "channelConfigurationLabel";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			string configurationLabel = parametersRoot.get(field, "").asString();

			bool warningIfMissing = false;
			tuple<int64_t, string, string, string, string, int64_t, string, int, string, int,
				int, string, int, int, int, int, int, int64_t>
				ipChannelDetails = _mmsEngineDBFacade->getStreamDetails(
				workspace->_workspaceKey, configurationLabel, warningIfMissing);
			string streamSourceType;
			tie(ignore, streamSourceType, ignore, streamingUrl,
				ignore, ignore, ignore, ignore, ignore, ignore,
				ignore, ignore, ignore, ignore, ignore, ignore,
				ignore, ignore) = ipChannelDetails;
		}
		else
		{
			// StreamingName is mandatory even if it is not used here
			// It is mandatory because in case into the workflow we have the EMail task,
			// the Email task may need the StreamingName information to add it into the email
			string field = "streamingName";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			string streamingName = parametersRoot.get(field, "").asString();

			field = "streamingUrl";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Field is not present or it is null"
					+ ", Field: " + field;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			streamingUrl = parametersRoot.get(field, "").asString();
		}

		_logger->info(__FILEREF__ + "checkStreamingThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", inputType: " + inputType
			+ ", streamingUrl: " + streamingUrl
		);

		if (streamingUrl == "")
        {
            string errorMessage = __FILEREF__ + "streamingUrl is wrong"
                    + ", streamingUrl: " + streamingUrl;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

		{
			_logger->info(__FILEREF__ + "Calling ffmpeg.getMediaInfo"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", streamingUrl: " + streamingUrl
			);
			bool isMMSAssetPathName = false;
			pair<int64_t, long> mediaInfoDetails;
			vector<tuple<int, int64_t, string, string, int, int, string, long>>
				videoTracks;
			vector<tuple<int, int64_t, string, long, int, long, string>> audioTracks;
			FFMpeg ffmpeg (_configuration, _logger);
			mediaInfoDetails = ffmpeg.getMediaInfo(ingestionJobKey,
				isMMSAssetPathName, streamingUrl,
				videoTracks, audioTracks);
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_TaskSuccess"
            + ", errorMessage: " + ""
        );
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
        );
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "checkStreamingThread failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
        return;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "checkStreamingThread failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + re.what()
				);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", errorMessage: " + ex.what()
				);
		}
        
        return;
    }
}

void MMSEngineProcessor::manageMediaCrossReferenceTask(
        int64_t ingestionJobKey,
        shared_ptr<Workspace> workspace,
        Json::Value parametersRoot,
        vector<tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>>&
			dependencies
)
{
    try
    {
        if (dependencies.size() != 2)
        {
            string errorMessage = __FILEREF__ + "No configured Two Media in order to create the Cross Reference"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size());
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        
        string field = "Type";
        if (!JSONUtils::isMetadataPresent(parametersRoot, field))
        {
            string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", Field: " + field;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        MMSEngineDBFacade::CrossReferenceType crossReferenceType =
			MMSEngineDBFacade::toCrossReferenceType(parametersRoot.get(field, "").asString());
		if (crossReferenceType == MMSEngineDBFacade::CrossReferenceType::VideoOfImage)
			crossReferenceType = MMSEngineDBFacade::CrossReferenceType::ImageOfVideo;
		else if (crossReferenceType == MMSEngineDBFacade::CrossReferenceType::AudioOfImage)
			crossReferenceType = MMSEngineDBFacade::CrossReferenceType::ImageOfAudio;

        MMSEngineDBFacade::ContentType firstContentType;
		int64_t firstMediaItemKey;
        {
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[0];

            int64_t key;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

            tie(key, firstContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

            if (dependencyType == Validator::DependencyType::MediaItemKey)
            {
                firstMediaItemKey = key;
            }
            else
            {
                int64_t physicalPathKey = key;

                bool warningIfMissing = false;
                tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                    _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                        workspace->_workspaceKey, physicalPathKey, warningIfMissing);

                tie(firstMediaItemKey,ignore, ignore, ignore, ignore, ignore, ignore, ignore)
                        = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
            }
		}

        MMSEngineDBFacade::ContentType secondContentType;
		int64_t secondMediaItemKey;
        {
			tuple<int64_t,MMSEngineDBFacade::ContentType,Validator::DependencyType, bool>&
				keyAndDependencyType = dependencies[1];

            int64_t key;
            Validator::DependencyType dependencyType;
			bool stopIfReferenceProcessingError;

            tie(key, secondContentType, dependencyType, stopIfReferenceProcessingError)
				= keyAndDependencyType;

            if (dependencyType == Validator::DependencyType::MediaItemKey)
            {
                secondMediaItemKey = key;
            }
            else
            {
                int64_t physicalPathKey = key;

                bool warningIfMissing = false;
                tuple<int64_t,MMSEngineDBFacade::ContentType,string,string,string,int64_t, string, string>
					mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName =
                    _mmsEngineDBFacade->getMediaItemKeyDetailsByPhysicalPathKey(
                        workspace->_workspaceKey, physicalPathKey, warningIfMissing);

                tie(secondMediaItemKey,ignore, ignore, ignore, ignore, ignore, ignore, ignore)
                        = mediaItemKeyContentTypeTitleUserDataIngestionDateIngestionJobKeyAndFileName;
            }
		}

		if (crossReferenceType == MMSEngineDBFacade::CrossReferenceType::ImageOfVideo
				|| crossReferenceType == MMSEngineDBFacade::CrossReferenceType::FaceOfVideo
				)
		{
			Json::Value crossReferenceParametersRoot;

			if (firstContentType == MMSEngineDBFacade::ContentType::Video
				&& secondContentType == MMSEngineDBFacade::ContentType::Image)
			{
				_logger->info(__FILEREF__ + "Add Cross Reference"
					+ ", sourceMediaItemKey: " + to_string(secondMediaItemKey)
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
					+ ", targetMediaItemKey: " + to_string(firstMediaItemKey)
				);
				_mmsEngineDBFacade->addCrossReference(
						ingestionJobKey,
                        secondMediaItemKey, crossReferenceType, firstMediaItemKey,
						crossReferenceParametersRoot);
			}
			else if (firstContentType == MMSEngineDBFacade::ContentType::Image
				&& secondContentType == MMSEngineDBFacade::ContentType::Video)
			{
				_logger->info(__FILEREF__ + "Add Cross Reference"
					+ ", sourceMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
					+ ", targetMediaItemKey: " + to_string(secondMediaItemKey)
				);
				_mmsEngineDBFacade->addCrossReference(
					ingestionJobKey,
					firstMediaItemKey, crossReferenceType, secondMediaItemKey,
					crossReferenceParametersRoot);
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong content type"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size())
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                    + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                    + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                    + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
		}
		else if (crossReferenceType == MMSEngineDBFacade::CrossReferenceType::ImageOfAudio)
		{
			Json::Value crossReferenceParametersRoot;

			if (firstContentType == MMSEngineDBFacade::ContentType::Audio
				&& secondContentType == MMSEngineDBFacade::ContentType::Image)
			{
				_logger->info(__FILEREF__ + "Add Cross Reference"
					+ ", sourceMediaItemKey: " + to_string(secondMediaItemKey)
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
					+ ", targetMediaItemKey: " + to_string(firstMediaItemKey)
				);
				_mmsEngineDBFacade->addCrossReference(
					ingestionJobKey,
					secondMediaItemKey, crossReferenceType, firstMediaItemKey,
					crossReferenceParametersRoot);
			}
			else if (firstContentType == MMSEngineDBFacade::ContentType::Image
				&& secondContentType == MMSEngineDBFacade::ContentType::Audio)
			{
				_logger->info(__FILEREF__ + "Add Cross Reference"
					+ ", sourceMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
					+ ", targetMediaItemKey: " + to_string(secondMediaItemKey)
				);
				_mmsEngineDBFacade->addCrossReference(
					ingestionJobKey,
					firstMediaItemKey, crossReferenceType, secondMediaItemKey,
					crossReferenceParametersRoot);
			}
			else
			{
				string errorMessage = __FILEREF__ + "Wrong content type"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size())
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                    + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                    + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                    + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
		}
		else if (crossReferenceType == MMSEngineDBFacade::CrossReferenceType::CutOfVideo)
		{
			if (firstContentType != MMSEngineDBFacade::ContentType::Video
				|| secondContentType != MMSEngineDBFacade::ContentType::Video)
			{
				string errorMessage = __FILEREF__ + "Wrong content type"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size())
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                    + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                    + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                    + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			field = "Parameters";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Cross Reference Parameters are not present"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size())
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                    + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                    + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                    + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			Json::Value crossReferenceParametersRoot = parametersRoot[field];

			_mmsEngineDBFacade->addCrossReference(
				ingestionJobKey,
				firstMediaItemKey, crossReferenceType,
				secondMediaItemKey, crossReferenceParametersRoot);
		}
		else if (crossReferenceType == MMSEngineDBFacade::CrossReferenceType::CutOfAudio)
		{
			if (firstContentType != MMSEngineDBFacade::ContentType::Audio
				|| secondContentType != MMSEngineDBFacade::ContentType::Audio)
			{
				string errorMessage = __FILEREF__ + "Wrong content type"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size())
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                    + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                    + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                    + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			field = "Parameters";
			if (!JSONUtils::isMetadataPresent(parametersRoot, field))
			{
				string errorMessage = __FILEREF__ + "Cross Reference Parameters are not present"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", dependencies.size: " + to_string(dependencies.size())
                    + ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                    + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                    + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                    + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                    + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			Json::Value crossReferenceParametersRoot = parametersRoot[field];

			_mmsEngineDBFacade->addCrossReference(
				ingestionJobKey,
				firstMediaItemKey, crossReferenceType,
				secondMediaItemKey, crossReferenceParametersRoot);
		}
		else
		{
			string errorMessage = __FILEREF__ + "Wrong type"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", dependencies.size: " + to_string(dependencies.size())
				+ ", crossReferenceType: " + MMSEngineDBFacade::toString(crossReferenceType)
                + ", firstContentType: " + MMSEngineDBFacade::toString(firstContentType)
                + ", secondContentType: " + MMSEngineDBFacade::toString(secondContentType)
                + ", firstMediaItemKey: " + to_string(firstMediaItemKey)
                + ", secondMediaItemKey: " + to_string(secondMediaItemKey)
			;
			_logger->error(errorMessage);

			throw runtime_error(errorMessage);
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_TaskSuccess"
            + ", errorMessage: " + ""
        );                            
        _mmsEngineDBFacade->updateIngestionJob (ingestionJobKey,
                MMSEngineDBFacade::IngestionStatus::End_TaskSuccess, 
                "" // errorMessage
        );
    }
    catch(DeadlockFound e)
    {
        _logger->error(__FILEREF__ + "manageMediaCrossReferenceTask failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(runtime_error e)
    {
        _logger->error(__FILEREF__ + "manageMediaCrossReferenceTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", e.what(): " + e.what()
        );
        
        // Update IngestionJob done in the calling method

        throw e;
    }
    catch(exception e)
    {
        _logger->error(__FILEREF__ + "manageMediaCrossReferenceTask failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
        );
        
        // Update IngestionJob done in the calling method
        
        throw e;
    }
}

string MMSEngineProcessor::generateMediaMetadataToIngest(
        int64_t ingestionJobKey,
        string fileFormat,
        string title,
		int64_t imageOfVideoMediaItemKey,
		int64_t cutOfVideoMediaItemKey, int64_t cutOfAudioMediaItemKey, double startTimeInSeconds, double endTimeInSeconds,
        Json::Value parametersRoot
)
{
    string field = "FileFormat";
    if (JSONUtils::isMetadataPresent(parametersRoot, field))
    {
        string fileFormatSpecifiedByUser = parametersRoot.get(field, "XXX").asString();
        if (fileFormatSpecifiedByUser != fileFormat)
        {
            string errorMessage = string("Wrong fileFormat")
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", fileFormatSpecifiedByUser: " + fileFormatSpecifiedByUser
                + ", fileFormat: " + fileFormat
            ;
            _logger->error(__FILEREF__ + errorMessage);

            throw runtime_error(errorMessage);
        }
    }
    else
    {
        parametersRoot[field] = fileFormat;
    }
    
	if (imageOfVideoMediaItemKey != -1)
	{
		MMSEngineDBFacade::CrossReferenceType   crossReferenceType =
			MMSEngineDBFacade::CrossReferenceType::ImageOfVideo;

        Json::Value crossReferenceRoot;

		field = "Type";
		crossReferenceRoot[field] =
			MMSEngineDBFacade::toString(crossReferenceType);

		field = "MediaItemKey";
		crossReferenceRoot[field] = imageOfVideoMediaItemKey;

		field = "CrossReference";
		parametersRoot[field] = crossReferenceRoot;
	}
	else if (cutOfVideoMediaItemKey != -1)
	{
		MMSEngineDBFacade::CrossReferenceType   crossReferenceType =
			MMSEngineDBFacade::CrossReferenceType::CutOfVideo;

        Json::Value crossReferenceRoot;

		field = "Type";
		crossReferenceRoot[field] =
			MMSEngineDBFacade::toString(crossReferenceType);

		field = "MediaItemKey";
		crossReferenceRoot[field] = cutOfVideoMediaItemKey;

        Json::Value crossReferenceParametersRoot;
		{
			field = "StartTimeInSeconds";
			crossReferenceParametersRoot[field] = startTimeInSeconds;

			field = "EndTimeInSeconds";
			crossReferenceParametersRoot[field] = endTimeInSeconds;

			field = "Parameters";
			crossReferenceRoot[field] = crossReferenceParametersRoot;
		}

		field = "CrossReference";
		parametersRoot[field] = crossReferenceRoot;
	}
	else if (cutOfAudioMediaItemKey != -1)
	{
		MMSEngineDBFacade::CrossReferenceType   crossReferenceType =
			MMSEngineDBFacade::CrossReferenceType::CutOfAudio;

        Json::Value crossReferenceRoot;

		field = "Type";
		crossReferenceRoot[field] =
			MMSEngineDBFacade::toString(crossReferenceType);

		field = "MediaItemKey";
		crossReferenceRoot[field] = cutOfAudioMediaItemKey;

        Json::Value crossReferenceParametersRoot;
		{
			field = "StartTimeInSeconds";
			crossReferenceParametersRoot[field] = startTimeInSeconds;

			field = "EndTimeInSeconds";
			crossReferenceParametersRoot[field] = endTimeInSeconds;

			field = "Parameters";
			crossReferenceRoot[field] = crossReferenceParametersRoot;
		}

		field = "CrossReference";
		parametersRoot[field] = crossReferenceRoot;
	}

    field = "Title";
    if (title != "")
        parametersRoot[field] = title;

    // this scenario is for example for the Cut or Concat-Demux or Periodical-Frames
    // that generate a new content (or contents in case of Periodical-Frames)
    // and the Parameters json will contain the parameters
    // for the new content.
    // It will contain also parameters for the Cut or Concat-Demux or Periodical-Frames or ...,
    // we will leave there even because we know they will not be used by the
    // Add-Content task
    
    string mediaMetadata;
    {
        Json::StreamWriterBuilder wbuilder;
        mediaMetadata = Json::writeString(wbuilder, parametersRoot);
    }
                        
    _logger->info(__FILEREF__ + "Media metadata generated"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
        + ", ingestionJobKey: " + to_string(ingestionJobKey)
        + ", mediaMetadata: " + mediaMetadata
            );

    return mediaMetadata;
}

void MMSEngineProcessor::handleCheckEncodingEvent ()
{
	try
	{
		if (isMaintenanceMode())
		{
			_logger->info(__FILEREF__ + "Received handleCheckEncodingEvent, not managed it because of MaintenanceMode"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			return;
		}

		_logger->info(__FILEREF__ + "Received handleCheckEncodingEvent"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		);

		vector<shared_ptr<MMSEngineDBFacade::EncodingItem>> encodingItems;
        
		_mmsEngineDBFacade->getEncodingJobs(_processorMMS, encodingItems,
			_timeBeforeToPrepareResourcesInMinutes, _maxEncodingJobsPerEvent);

		_logger->info(__FILEREF__ + "_pActiveEncodingsManager->addEncodingItems"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", encodingItems.size: " + to_string(encodingItems.size())
		);

		_pActiveEncodingsManager->addEncodingItems(encodingItems);

		_logger->info(__FILEREF__ + "getEncodingJobs result"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", encodingItems.size: " + to_string(encodingItems.size())
		);
	}
	catch(AlreadyLocked e)
	{
		_logger->warn(__FILEREF__ + "getEncodingJobs was not done"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", exception: " + e.what()
		);

		return;
		// throw e;
	}
	catch(runtime_error e)
	{
		_logger->error(__FILEREF__ + "getEncodingJobs failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", exception: " + e.what()
		);

		throw e;
	}
	catch(exception e)
	{
		_logger->error(__FILEREF__ + "getEncodingJobs failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", exception: " + e.what()
		);

		throw e;
	}
}

void MMSEngineProcessor::handleContentRetentionEventThread (
        shared_ptr<long> processorsThreadsNumber)
{

	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"handleContentRetentionEventThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		-1	// ingestionJobKey
	);

	_logger->info(__FILEREF__ + "handleContentRetentionEventThread"
		+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
	);

	chrono::system_clock::time_point start = chrono::system_clock::now();

    {
        vector<tuple<shared_ptr<Workspace>,int64_t, int64_t>> mediaItemKeyOrPhysicalPathKeyToBeRemoved;
        bool moreRemoveToBeDone = true;

        while (moreRemoveToBeDone)
        {
            try
            {
                int maxMediaItemKeysNumber = 100;

                mediaItemKeyOrPhysicalPathKeyToBeRemoved.clear();
                _mmsEngineDBFacade->getExpiredMediaItemKeysCheckingDependencies(
                    _processorMMS, mediaItemKeyOrPhysicalPathKeyToBeRemoved, maxMediaItemKeysNumber);

                if (mediaItemKeyOrPhysicalPathKeyToBeRemoved.size() == 0)
                    moreRemoveToBeDone = false;
            }
            catch(runtime_error e)
            {
                _logger->error(__FILEREF__ + "getExpiredMediaItemKeysCheckingDependencies failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                );

                // no throw since it is running in a detached thread
                // throw e;
                break;
            }
            catch(exception e)
            {
                _logger->error(__FILEREF__ + "getExpiredMediaItemKeysCheckingDependencies failed"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", exception: " + e.what()
                );

                // no throw since it is running in a detached thread
                // throw e;
                break;
            }

            for (tuple<shared_ptr<Workspace>,int64_t, int64_t> workspaceMediaItemKeyOrPhysicalPathKey:
					mediaItemKeyOrPhysicalPathKeyToBeRemoved)
            {
				shared_ptr<Workspace> workspace;
				int64_t mediaItemKey;
				int64_t physicalPathKey;

				tie(workspace, mediaItemKey, physicalPathKey) = workspaceMediaItemKeyOrPhysicalPathKey;

                _logger->info(__FILEREF__ + "Removing because of ContentRetention"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", workspace->_workspaceKey: " + to_string(workspace->_workspaceKey)
                    + ", workspace->_name: " + workspace->_name
                    + ", mediaItemKey: " + to_string(mediaItemKey)
                    + ", physicalPathKey: " + to_string(physicalPathKey)
                );

                try
                {
					if (physicalPathKey == -1)
						_mmsStorage->removeMediaItem(mediaItemKey);
					else
						_mmsStorage->removePhysicalPath(physicalPathKey);
                }
                catch(runtime_error e)
                {
                    _logger->error(__FILEREF__ + "_mmsStorage->removeMediaItem failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", workspace->_workspaceKey: " + to_string(workspace->_workspaceKey)
                        + ", workspace->_name: " + workspace->_name
                        + ", mediaItemKeyToBeRemoved: " + to_string(mediaItemKey)
                        + ", physicalPathKeyToBeRemoved: " + to_string(physicalPathKey)
                        + ", exception: " + e.what()
                    );

					try
					{
						string processorMMSForRetention = "";
						_mmsEngineDBFacade->updateMediaItem(mediaItemKey, processorMMSForRetention);
					}
					catch(runtime_error e)
					{
						_logger->error(__FILEREF__ + "updateMediaItem failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", mediaItemKeyToBeRemoved: " + to_string(mediaItemKey)
							+ ", physicalPathKeyToBeRemoved: " + to_string(physicalPathKey)
							+ ", exception: " + e.what()
						);
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "updateMediaItem failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", mediaItemKeyToBeRemoved: " + to_string(mediaItemKey)
							+ ", physicalPathKeyToBeRemoved: " + to_string(physicalPathKey)
							+ ", exception: " + e.what()
						);
					}

					// one remove failed, procedure has to go ahead to try all the other removes
                    // moreRemoveToBeDone = false;
                    // break;

					continue;
                    // no throw since it is running in a detached thread
                    // throw e;
                }
                catch(exception e)
                {
                    _logger->error(__FILEREF__ + "_mmsStorage->removeMediaItem failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", workspace->_workspaceKey: " + to_string(workspace->_workspaceKey)
                        + ", workspace->_name: " + workspace->_name
						+ ", mediaItemKeyToBeRemoved: " + to_string(mediaItemKey)
						+ ", physicalPathKeyToBeRemoved: " + to_string(physicalPathKey)
                    );

					try
					{
						string processorMMSForRetention = "";
						_mmsEngineDBFacade->updateMediaItem(mediaItemKey, processorMMSForRetention);
					}
					catch(runtime_error e)
					{
						_logger->error(__FILEREF__ + "updateMediaItem failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", mediaItemKeyToBeRemoved: " + to_string(mediaItemKey)
							+ ", physicalPathKeyToBeRemoved: " + to_string(physicalPathKey)
							+ ", exception: " + e.what()
						);
					}
					catch(exception e)
					{
						_logger->error(__FILEREF__ + "updateMediaItem failed"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", mediaItemKeyToBeRemoved: " + to_string(mediaItemKey)
							+ ", physicalPathKeyToBeRemoved: " + to_string(physicalPathKey)
							+ ", exception: " + e.what()
						);
					}

					// one remove failed, procedure has to go ahead to try all the other removes
                    // moreRemoveToBeDone = false;
                    // break;

					continue;
                    // no throw since it is running in a detached thread
                    // throw e;
                }
            }
        }

		chrono::system_clock::time_point end = chrono::system_clock::now();
		_logger->info(__FILEREF__ + "Content retention finished"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
		);
    }

	/* Already done by the crontab script
    {
        _logger->info(__FILEREF__ + "Staging Retention started"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", _mmsStorage->getStagingRootRepository(): " + _mmsStorage->getStagingRootRepository()
        );

        try
        {
            chrono::system_clock::time_point tpNow = chrono::system_clock::now();
    
            FileIO::DirectoryEntryType_t detDirectoryEntryType;
            shared_ptr<FileIO::Directory> directory = FileIO::openDirectory (_mmsStorage->getStagingRootRepository());

            bool scanDirectoryFinished = false;
            while (!scanDirectoryFinished)
            {
                string directoryEntry;
                try
                {
                    string directoryEntry = FileIO::readDirectory (directory,
                        &detDirectoryEntryType);

//                    if (detDirectoryEntryType != FileIO::TOOLS_FILEIO_REGULARFILE)
//                        continue;

                    string pathName = _mmsStorage->getStagingRootRepository()
                            + directoryEntry;
                    chrono::system_clock::time_point tpLastModification =
                            FileIO:: getFileTime (pathName);
                    
                    int elapsedInHours = chrono::duration_cast<chrono::hours>(tpNow - tpLastModification).count();
                    double elapsedInDays =  elapsedInHours / 24;
                    if (elapsedInDays >= _stagingRetentionInDays)
                    {
                        if (detDirectoryEntryType == FileIO:: TOOLS_FILEIO_DIRECTORY) 
                        {
                            _logger->info(__FILEREF__ + "Removing staging directory because of Retention"
                                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                + ", pathName: " + pathName
                                + ", elapsedInDays: " + to_string(elapsedInDays)
                                + ", _stagingRetentionInDays: " + to_string(_stagingRetentionInDays)
                            );
                            
                            try
                            {
                                bool removeRecursively = true;

                                FileIO::removeDirectory(pathName, removeRecursively);
                            }
                            catch(runtime_error e)
                            {
                                _logger->warn(__FILEREF__ + "Error removing staging directory because of Retention"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", pathName: " + pathName
                                    + ", elapsedInDays: " + to_string(elapsedInDays)
                                    + ", _stagingRetentionInDays: " + to_string(_stagingRetentionInDays)
                                    + ", e.what(): " + e.what()
                                );
                            }
                            catch(exception e)
                            {
                                _logger->warn(__FILEREF__ + "Error removing staging directory because of Retention"
                                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                    + ", pathName: " + pathName
                                    + ", elapsedInDays: " + to_string(elapsedInDays)
                                    + ", _stagingRetentionInDays: " + to_string(_stagingRetentionInDays)
                                    + ", e.what(): " + e.what()
                                );
                            }
                        }
                        else
                        {
                            _logger->info(__FILEREF__ + "Removing staging file because of Retention"
                                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                + ", pathName: " + pathName
                                + ", elapsedInDays: " + to_string(elapsedInDays)
                                + ", _stagingRetentionInDays: " + to_string(_stagingRetentionInDays)
                            );
                            
                            bool exceptionInCaseOfError = false;

                            FileIO::remove(pathName, exceptionInCaseOfError);
                        }
                    }
                }
                catch(DirectoryListFinished e)
                {
                    scanDirectoryFinished = true;
                }
                catch(runtime_error e)
                {
                    string errorMessage = __FILEREF__ + "listing directory failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                           + ", e.what(): " + e.what()
                    ;
                    _logger->error(errorMessage);

                    throw e;
                }
                catch(exception e)
                {
                    string errorMessage = __FILEREF__ + "listing directory failed"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                           + ", e.what(): " + e.what()
                    ;
                    _logger->error(errorMessage);

                    throw e;
                }
            }

            FileIO::closeDirectory (directory);
        }
        catch(runtime_error e)
        {
            _logger->error(__FILEREF__ + "removeHavingPrefixFileName failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", e.what(): " + e.what()
            );
        }
        catch(exception e)
        {
            _logger->error(__FILEREF__ + "removeHavingPrefixFileName failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            );
        }

        _logger->info(__FILEREF__ + "Staging Retention finished"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
        );
    }
	*/

}

void MMSEngineProcessor::handleDBDataRetentionEventThread()
{

	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"handleDBDataRetentionEventThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		-1	// ingestionJobKey,
	);

	bool alreadyExecuted = true;

	try
	{
		_logger->info(__FILEREF__ + "DBDataRetention: oncePerDayExecution"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		);

		alreadyExecuted = _mmsEngineDBFacade->oncePerDayExecution(
			MMSEngineDBFacade::OncePerDayType::DBDataRetention);
	}
	catch(runtime_error e)
	{
		_logger->error(__FILEREF__ + "DBDataRetention: Ingestion Data failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", exception: " + e.what()
		);

		// no throw since it is running in a detached thread
		// throw e;
	}
	catch(exception e)
	{
		_logger->error(__FILEREF__ + "DBDataRetention: Ingestion Data failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", exception: " + e.what()
		);

		// no throw since it is running in a detached thread
		// throw e;
	}

	if (!alreadyExecuted)
    {
		{
			chrono::system_clock::time_point start = chrono::system_clock::now();

			_logger->info(__FILEREF__ + "DBDataRetention: Ingestion Data started"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			try
			{
				_mmsEngineDBFacade->retentionOfIngestionData();
			}
			catch(runtime_error e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Ingestion Data failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}
			catch(exception e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Ingestion Data failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}

			chrono::system_clock::time_point end = chrono::system_clock::now();
			_logger->info(__FILEREF__ + "DBDataRetention: Ingestion Data finished"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
			);
		}

		{
			chrono::system_clock::time_point start = chrono::system_clock::now();

			_logger->info(__FILEREF__ + "DBDataRetention: Delivery Autorization started"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			try
			{
				_mmsEngineDBFacade->retentionOfDeliveryAuthorization();
			}
			catch(runtime_error e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Delivery Autorization failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}
			catch(exception e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Delivery Autorization failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}

			chrono::system_clock::time_point end = chrono::system_clock::now();
			_logger->info(__FILEREF__ + "DBDataRetention: Delivery Autorization finished"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
			);
		}

		{
			chrono::system_clock::time_point start = chrono::system_clock::now();

			_logger->info(__FILEREF__ + "DBDataRetention: Statistic Data started"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			try
			{
				_mmsEngineDBFacade->retentionOfStatisticData();
			}
			catch(runtime_error e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Statistic Data failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}
			catch(exception e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Statistic Data failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}

			chrono::system_clock::time_point end = chrono::system_clock::now();
			_logger->info(__FILEREF__ + "DBDataRetention: Statistic Data finished"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
			);
		}

		{
			chrono::system_clock::time_point start = chrono::system_clock::now();

			_logger->info(__FILEREF__ + "DBDataRetention: Fix of EncodingJobs having wrong status started"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			try
			{
				// Scenarios: IngestionJob in final status but EncodingJob not in final status
				_mmsEngineDBFacade->fixEncodingJobsHavingWrongStatus();
			}
			catch(runtime_error e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Fix of EncodingJobs having wrong status failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}
			catch(exception e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Fix of EncodingJobs having wrong status failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}

			chrono::system_clock::time_point end = chrono::system_clock::now();
			_logger->info(__FILEREF__ + "DBDataRetention: Fix of EncodingJobs having wrong status finished"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
			);
		}

		{
			chrono::system_clock::time_point start = chrono::system_clock::now();

			_logger->info(__FILEREF__ + "DBDataRetention: Fix of IngestionJobs having wrong status started"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			);

			try
			{
				// Scenarios: EncodingJob in final status but IngestionJob not in final status
				//		even it it was passed long time
				_mmsEngineDBFacade->fixIngestionJobsHavingWrongStatus();
			}
			catch(runtime_error e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Fix of IngestionJobs having wrong status failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}
			catch(exception e)
			{
				_logger->error(__FILEREF__ + "DBDataRetention: Fix of IngestionJobs having wrong status failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", exception: " + e.what()
				);

				// no throw since it is running in a detached thread
				// throw e;
			}

			chrono::system_clock::time_point end = chrono::system_clock::now();
			_logger->info(__FILEREF__ + "DBDataRetention: Fix of IngestionJobs having wrong status finished"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
			);
		}
	}
}

void MMSEngineProcessor::handleCheckRefreshPartitionFreeSizeEventThread ()
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"handleCheckRefreshPartitionFreeSizeEventThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		-1	// ingestionJobKey,
		);

	chrono::system_clock::time_point start = chrono::system_clock::now();

    {
        _logger->info(__FILEREF__ + "Check Refresh Partition Free Size started"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
        );

		try
		{
			_mmsStorage->refreshPartitionsFreeSizes();
		}
		catch(runtime_error e)
		{
			_logger->error(__FILEREF__ + "refreshPartitionsFreeSizes failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", exception: " + e.what()
			);

			// no throw since it is running in a detached thread
			// throw e;
		}
		catch(exception e)
		{
			_logger->error(__FILEREF__ + "refreshPartitionsFreeSizes failed"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", exception: " + e.what()
			);

			// no throw since it is running in a detached thread
			// throw e;
		}

		chrono::system_clock::time_point end = chrono::system_clock::now();
        _logger->info(__FILEREF__ + "Check Refresh Partition Free Size finished"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", @MMS statistics@ - duration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(end - start).count()) + "@"
		);
    }
}

tuple<MMSEngineDBFacade::IngestionStatus, string, string, string, int, bool>
	MMSEngineProcessor::getMediaSourceDetails(
        int64_t ingestionJobKey, shared_ptr<Workspace> workspace,
		MMSEngineDBFacade::IngestionType ingestionType, Json::Value parametersRoot)        
{
	// only in case of externalReadOnlyStorage, nextIngestionStatus does not change and we do not need it
	// So I set it just to a state
    MMSEngineDBFacade::IngestionStatus nextIngestionStatus = MMSEngineDBFacade::IngestionStatus::Start_TaskQueued;
    string mediaSourceURL;
    string mediaFileFormat;
	bool externalReadOnlyStorage;
    
    string field;
    if (ingestionType != MMSEngineDBFacade::IngestionType::AddContent)
    {
        string errorMessage = __FILEREF__ + "ingestionType is wrong"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", ingestionType: " + MMSEngineDBFacade::toString(ingestionType);
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }

	externalReadOnlyStorage = false;
    {
        field = "SourceURL";
        if (JSONUtils::isMetadataPresent(parametersRoot, field))
            mediaSourceURL = parametersRoot.get(field, "").asString();

        field = "FileFormat";
        mediaFileFormat = parametersRoot.get(field, "").asString();

        string httpPrefix ("http://");
        string httpsPrefix ("https://");
        string ftpPrefix ("ftp://");
        string ftpsPrefix ("ftps://");
        string movePrefix("move://");   // move:///dir1/dir2/.../file
        string copyPrefix("copy://");
        string externalStoragePrefix("externalStorage://");
        if ((mediaSourceURL.size() >= httpPrefix.size()
					&& 0 == mediaSourceURL.compare(0, httpPrefix.size(), httpPrefix))
                || (mediaSourceURL.size() >= httpsPrefix.size()
					&& 0 == mediaSourceURL.compare(0, httpsPrefix.size(), httpsPrefix))
                || (mediaSourceURL.size() >= ftpPrefix.size()
					&& 0 == mediaSourceURL.compare(0, ftpPrefix.size(), ftpPrefix))
                || (mediaSourceURL.size() >= ftpsPrefix.size()
					&& 0 == mediaSourceURL.compare(0, ftpsPrefix.size(), ftpsPrefix))
                )
        {
            nextIngestionStatus = MMSEngineDBFacade::IngestionStatus::SourceDownloadingInProgress;
        }
        else if (mediaSourceURL.size() >= movePrefix.size()
				&& 0 == mediaSourceURL.compare(0, movePrefix.size(), movePrefix))
        {
            nextIngestionStatus = MMSEngineDBFacade::IngestionStatus::SourceMovingInProgress;            
        }
        else if (mediaSourceURL.size() >= copyPrefix.size()
				&& 0 == mediaSourceURL.compare(0, copyPrefix.size(), copyPrefix))
        {
            nextIngestionStatus = MMSEngineDBFacade::IngestionStatus::SourceCopingInProgress;
        }
        else if (mediaSourceURL.size() >= externalStoragePrefix.size()
				&& 0 == mediaSourceURL.compare(0, externalStoragePrefix.size(), externalStoragePrefix))
        {
			externalReadOnlyStorage = true;
        }
        else
        {
            nextIngestionStatus = MMSEngineDBFacade::IngestionStatus::SourceUploadingInProgress;
        }
    }

    string md5FileCheckSum;
    field = "MD5FileCheckSum";
    if (JSONUtils::isMetadataPresent(parametersRoot, field))
    {
        // MD5         md5;
        // char        md5RealDigest [32 + 1];

        md5FileCheckSum = parametersRoot.get(field, "XXX").asString();
    }

    int fileSizeInBytes = -1;
    field = "FileSizeInBytes";
    if (JSONUtils::isMetadataPresent(parametersRoot, field))
        fileSizeInBytes = JSONUtils::asInt(parametersRoot, field, 3);

	/*
    tuple<MMSEngineDBFacade::IngestionStatus, string, string, string, int> mediaSourceDetails;
    get<0>(mediaSourceDetails) = nextIngestionStatus;
    get<1>(mediaSourceDetails) = mediaSourceURL;
    get<2>(mediaSourceDetails) = mediaFileFormat;
    get<3>(mediaSourceDetails) = md5FileCheckSum;
    get<4>(mediaSourceDetails) = fileSizeInBytes;
	*/

    _logger->info(__FILEREF__ + "media source details"
		+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		+ ", nextIngestionStatus: " + MMSEngineDBFacade::toString(nextIngestionStatus)
		+ ", mediaSourceURL: " + mediaSourceURL
		+ ", mediaFileFormat: " + mediaFileFormat
		+ ", md5FileCheckSum: " + md5FileCheckSum
		+ ", fileSizeInBytes: " + to_string(fileSizeInBytes)
		+ ", externalReadOnlyStorage: " + to_string(externalReadOnlyStorage)
	);

    return make_tuple(nextIngestionStatus, mediaSourceURL, mediaFileFormat,
			md5FileCheckSum, fileSizeInBytes, externalReadOnlyStorage);
}

void MMSEngineProcessor::validateMediaSourceFile (int64_t ingestionJobKey,
        string mediaSourcePathName, string mediaFileFormat,
        string md5FileCheckSum, int fileSizeInBytes)
{

	if (mediaFileFormat == "m3u8-tar.gz")
	{
		// in this case it is a directory with segments inside
		if (!FileIO::directoryExisting(mediaSourcePathName,
			_waitingNFSSync_maxMillisecondsToWait,
			_waitingNFSSync_milliSecondsWaitingBetweenChecks))
		{
			string errorMessage = __FILEREF__ + "Media Source directory does not exist (it was not uploaded yet)"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", mediaSourcePathName: " + mediaSourcePathName;
			_logger->error(errorMessage);

			throw runtime_error(errorMessage);
		}
	}
	else
	{
		// we added the following two parameters for the FileIO::fileExisting method
		// because, in the scenario where still MMS generates the file to be ingested
		// (i.e.: generate frames task and other tasks), and the NFS is used,
		// we saw sometimes
		// FileIO::fileExisting returns false even if the file is there.
		// This is due because of NFS 
		// delay to present the file 
		if (!FileIO::fileExisting(mediaSourcePathName,
			_waitingNFSSync_maxMillisecondsToWait,
			_waitingNFSSync_milliSecondsWaitingBetweenChecks))
		{
			string errorMessage = __FILEREF__ + "Media Source file does not exist (it was not uploaded yet)"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", mediaSourcePathName: " + mediaSourcePathName;
			_logger->error(errorMessage);

			throw runtime_error(errorMessage);
		}
	}

	// we just simplify and md5FileCheck is not done in case of segments
    if (mediaFileFormat != "m3u8-tar.gz" && md5FileCheckSum != "")
    {
		char buffer[MD5BUFFERSIZE];
		unsigned char digest[MD5_DIGEST_LENGTH];
		std::stringstream ss;

		std::ifstream ifs(mediaSourcePathName, std::ifstream::binary);
		MD5_CTX md5Context;
		MD5_Init(&md5Context);
		while (ifs.good())
		{
			ifs.read(buffer, MD5BUFFERSIZE);
			MD5_Update(&md5Context, buffer, ifs.gcount());
		}
		ifs.close();
		int res = MD5_Final(digest, &md5Context);

		if(res == 0) // hash failed
        {
            string errorMessage = __FILEREF__ + "MD5 calculation failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", mediaSourcePathName: " + mediaSourcePathName
                + ", md5FileCheckSum: " + md5FileCheckSum
                    ;
            _logger->error(errorMessage);
            throw runtime_error(errorMessage);
        }

		// set up stringstream format
		ss << std::hex << std::setfill('0');
		for(unsigned char uc: digest)
			ss << std::setw(2) << (int)uc;

        string md5RealDigest = ss.str();

		bool isCaseInsensitiveEqual = md5FileCheckSum.length() != md5RealDigest.length()
			? false :
            equal(md5FileCheckSum.begin(), md5FileCheckSum.end(), md5RealDigest.begin(),
				[](int c1, int c2){ return toupper(c1) == toupper(c2); });

        if (!isCaseInsensitiveEqual)
        {
            string errorMessage = __FILEREF__ + "MD5 check failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", mediaSourcePathName: " + mediaSourcePathName
                + ", md5FileCheckSum: " + md5FileCheckSum
                + ", md5RealDigest: " + md5RealDigest
                    ;
            _logger->error(errorMessage);
            throw runtime_error(errorMessage);
        }
    }
    
	// we just simplify and file size check is not done in case of segments
    if (mediaFileFormat != "m3u8-tar.gz" && fileSizeInBytes != -1)
    {
        bool inCaseOfLinkHasItToBeRead = false;
        unsigned long downloadedFileSizeInBytes = 
            FileIO:: getFileSizeInBytes (mediaSourcePathName, inCaseOfLinkHasItToBeRead);

        if (fileSizeInBytes != downloadedFileSizeInBytes)
        {
            string errorMessage = __FILEREF__ + "FileSize check failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", mediaSourcePathName: " + mediaSourcePathName
                + ", metadataFileSizeInBytes: " + to_string(fileSizeInBytes)
                + ", downloadedFileSizeInBytes: " + to_string(downloadedFileSizeInBytes)
            ;
            _logger->error(errorMessage);
            throw runtime_error(errorMessage);
        }
    }    
}

size_t curlDownloadCallback(char* ptr, size_t size, size_t nmemb, void *f)
{
    MMSEngineProcessor::CurlDownloadData* curlDownloadData = (MMSEngineProcessor::CurlDownloadData*) f;
    
    auto logger = spdlog::get("mmsEngineService");

    if (curlDownloadData->currentChunkNumber == 0)
    {
        (curlDownloadData->mediaSourceFileStream).open(
                curlDownloadData->destBinaryPathName, ofstream::binary | ofstream::trunc);
        curlDownloadData->currentChunkNumber += 1;
        
        logger->info(__FILEREF__ + "Opening binary file"
             + ", curlDownloadData -> destBinaryPathName: " + curlDownloadData -> destBinaryPathName
             + ", curlDownloadData->currentChunkNumber: " + to_string(curlDownloadData->currentChunkNumber)
             + ", curlDownloadData->currentTotalSize: " + to_string(curlDownloadData->currentTotalSize)
             + ", curlDownloadData->maxChunkFileSize: " + to_string(curlDownloadData->maxChunkFileSize)
        );
    }
    else if (curlDownloadData->currentTotalSize >= 
            curlDownloadData->currentChunkNumber * curlDownloadData->maxChunkFileSize)
    {
        (curlDownloadData->mediaSourceFileStream).close();

        /*
        string localPathFileName = curlDownloadData->workspaceIngestionBinaryPathName
                // + ".new"
                ;
        if (curlDownloadData->currentChunkNumber >= 2)
        {
            try
            {
                bool removeSrcFileAfterConcat = true;

                logger->info(__FILEREF__ + "Concat file"
                    + ", localPathFileName: " + localPathFileName
                    + ", curlDownloadData->workspaceIngestionBinaryPathName: " + curlDownloadData->workspaceIngestionBinaryPathName
                    + ", removeSrcFileAfterConcat: " + to_string(removeSrcFileAfterConcat)
                );

                FileIO::concatFile(curlDownloadData->workspaceIngestionBinaryPathName, localPathFileName, removeSrcFileAfterConcat);
            }
            catch(runtime_error e)
            {
                string errorMessage = string("Error to concat file")
                    + ", localPathFileName: " + localPathFileName
                    + ", curlDownloadData->workspaceIngestionBinaryPathName: " + curlDownloadData->workspaceIngestionBinaryPathName
                        + ", e.what(): " + e.what()
                ;
                logger->error(__FILEREF__ + errorMessage);

                throw runtime_error(errorMessage);            
            }
            catch(exception e)
            {
                string errorMessage = string("Error to concat file")
                    + ", localPathFileName: " + localPathFileName
                    + ", curlDownloadData->workspaceIngestionBinaryPathName: " + curlDownloadData->workspaceIngestionBinaryPathName
                ;
                logger->error(__FILEREF__ + errorMessage);

                throw runtime_error(errorMessage);            
            }
        }
         */
        // (curlDownloadData->mediaSourceFileStream).open(localPathFileName, ios::binary | ios::out | ios::trunc);
        (curlDownloadData->mediaSourceFileStream).open(curlDownloadData->destBinaryPathName, ofstream::binary | ofstream::app);
        curlDownloadData->currentChunkNumber += 1;

        logger->info(__FILEREF__ + "Opening binary file"
             + ", curlDownloadData->destBinaryPathName: " + curlDownloadData->destBinaryPathName
             + ", curlDownloadData->currentChunkNumber: " + to_string(curlDownloadData->currentChunkNumber)
             + ", curlDownloadData->currentTotalSize: " + to_string(curlDownloadData->currentTotalSize)
             + ", curlDownloadData->maxChunkFileSize: " + to_string(curlDownloadData->maxChunkFileSize)
        );
    }
    
    curlDownloadData->mediaSourceFileStream.write(ptr, size * nmemb);
    curlDownloadData->currentTotalSize += (size * nmemb);
    

    return size * nmemb;        
};

void MMSEngineProcessor::downloadMediaSourceFileThread(
        shared_ptr<long> processorsThreadsNumber, string sourceReferenceURL,
		bool regenerateTimestamps, int m3u8TarGzOrM3u8Streaming,
        int64_t ingestionJobKey, shared_ptr<Workspace> workspace)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"downloadMediaSourceFileThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    bool downloadingCompleted = false;

	_logger->info(__FILEREF__ + "downloadMediaSourceFileThread"
		+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		+ ", m3u8TarGzOrM3u8Streaming: " + to_string(m3u8TarGzOrM3u8Streaming)
		+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
	);
/*
    - aggiungere un timeout nel caso nessun pacchetto è ricevuto entro XXXX seconds
    - per il resume:
        l'apertura dello stream of dovrà essere fatta in append in questo caso
        usare l'opzione CURLOPT_RESUME_FROM o CURLOPT_RESUME_FROM_LARGE (>2GB) per dire da dove ripartire
    per ftp vedere https://raw.githubusercontent.com/curl/curl/master/docs/examples/ftpuploadresume.c
 
RESUMING FILE TRANSFERS 
  
 To continue a file transfer where it was previously aborted, curl supports 
 resume on http(s) downloads as well as ftp uploads and downloads. 
  
 Continue downloading a document: 
  
        curl -C - -o file ftp://ftp.server.com/path/file 
  
 Continue uploading a document(*1): 
  
        curl -C - -T file ftp://ftp.server.com/path/file 
  
 Continue downloading a document from a web server(*2): 
  
        curl -C - -o file http://www.server.com/ 
  
 (*1) = This requires that the ftp server supports the non-standard command 
        SIZE. If it doesn't, curl will say so. 
  
 (*2) = This requires that the web server supports at least HTTP/1.1. If it 
        doesn't, curl will say so. 
 */    

	string localSourceReferenceURL = sourceReferenceURL;
	int localM3u8TarGzOrM3u8Streaming = m3u8TarGzOrM3u8Streaming;
	// in case of youtube url, the real URL to be used has to be calcolated
	{
		string youTubePrefix1 ("https://www.youtube.com/");
		string youTubePrefix2 ("https://youtu.be/");
		if (
			(sourceReferenceURL.size() >= youTubePrefix1.size()
				&& 0 == sourceReferenceURL.compare(0, youTubePrefix1.size(), youTubePrefix1))
			||
			(sourceReferenceURL.size() >= youTubePrefix2.size()
				&& 0 == sourceReferenceURL.compare(0, youTubePrefix2.size(), youTubePrefix2))
			)
		{
			try
			{
				FFMpeg ffmpeg (_configuration, _logger);
				pair<string, string> streamingURLDetails =
					ffmpeg.retrieveStreamingYouTubeURL(
					ingestionJobKey, -1,
					sourceReferenceURL);

				string streamingYouTubeURL;
				tie(streamingYouTubeURL, ignore) = streamingURLDetails;

				_logger->info(__FILEREF__ + "downloadMediaSourceFileThread. YouTube URL calculation"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", _ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", initial YouTube URL: " + sourceReferenceURL
					+ ", streaming YouTube URL: " + streamingYouTubeURL
				);

				localSourceReferenceURL = streamingYouTubeURL;

				// for sure localM3u8TarGzOrM3u8Streaming has to be false
				localM3u8TarGzOrM3u8Streaming = 0;
			}
			catch(runtime_error e)
			{
				string errorMessage = __FILEREF__ + "ffmpeg.retrieveStreamingYouTubeURL failed"
					+ ", may be the YouTube URL is not available anymore"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", YouTube URL: " + sourceReferenceURL
					+ ", e.what(): " + e.what()
				;
				_logger->error(errorMessage);
                    
				_logger->info(__FILEREF__ + "Update IngestionJob"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", IngestionStatus: " + "End_IngestionFailure"
					+ ", errorMessage: " + errorMessage
				);
				try
				{
					// to hide ffmpeg staff
					errorMessage = __FILEREF__ + "retrieveStreamingYouTubeURL failed"
						+ ", may be the YouTube URL is not available anymore"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", YouTube URL: " + sourceReferenceURL
						+ ", e.what(): " + e.what()
					;
					_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
						MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
						errorMessage);
				}
				catch(runtime_error& re)
				{
					_logger->info(__FILEREF__ + "Update IngestionJob failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", errorMessage: " + re.what()
					);
				}
				catch(exception ex)
				{
					_logger->info(__FILEREF__ + "Update IngestionJob failed"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", errorMessage: " + ex.what()
					);
				}

				return;
			}
		}
	}

	string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(workspace);
	string destBinaryPathName =
		workspaceIngestionRepository
		+ "/"
		+ to_string(ingestionJobKey)
		+ "_source";
	// 0: no m3u8
	// 1: m3u8 by .tar.gz
	// 2: m3u8 by streaming (it will be saved as .mp4)
		// .mp4 is used in
		// 1. downloadMediaSourceFileThread (when the m3u8-streaming is downloaded in a .mp4 file
		// 2. handleLocalAssetIngestionEventThread (when the IngestionRepository file name
		//		is built "consistent" with the above step no. 1)
		// 3. here, handleLocalAssetIngestionEventThread (when the MMS file name is generated)
	if (localM3u8TarGzOrM3u8Streaming == 1)
		destBinaryPathName = destBinaryPathName + ".tar.gz";
	else if (localM3u8TarGzOrM3u8Streaming == 2)
		destBinaryPathName = destBinaryPathName + ".mp4";

	if (localM3u8TarGzOrM3u8Streaming == 2)
	{
		try
		{
			_logger->info(__FILEREF__ + "ffmpeg.streamingToFile"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", sourceReferenceURL: " + sourceReferenceURL
				+ ", destBinaryPathName: " + destBinaryPathName
			);

			// regenerateTimestamps (see docs/TASK_01_Add_Content_JSON_Format.txt)
			FFMpeg ffmpeg (_configuration, _logger);
			ffmpeg.streamingToFile(
				ingestionJobKey,
				regenerateTimestamps,
				sourceReferenceURL,
				destBinaryPathName);

			downloadingCompleted = true;

			_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", destBinaryPathName: " + destBinaryPathName
				+ ", downloadingCompleted: " + to_string(downloadingCompleted)
			);
			_mmsEngineDBFacade->updateIngestionJobSourceBinaryTransferred (
				ingestionJobKey, downloadingCompleted);
		}
		catch(runtime_error e)
		{
			string errorMessage = __FILEREF__ + "ffmpeg.streamingToFile failed"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", sourceReferenceURL: " + sourceReferenceURL
				+ ", destBinaryPathName: " + destBinaryPathName
				+ ", e.what(): " + e.what()
			;
			_logger->error(errorMessage);

			_logger->info(__FILEREF__ + "Update IngestionJob"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + errorMessage
			);
			try
			{
				// to hide ffmpeg staff
				errorMessage = __FILEREF__ + "streamingToFile failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", sourceReferenceURL: " + sourceReferenceURL
					+ ", destBinaryPathName: " + destBinaryPathName
					+ ", e.what(): " + e.what()
				;
				_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
					MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
					errorMessage);
			}
			catch(runtime_error& re)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", errorMessage: " + re.what()
				);
			}
			catch(exception ex)
			{
				_logger->info(__FILEREF__ + "Update IngestionJob failed"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", errorMessage: " + ex.what()
				);
			}

			return;
		}
	}
	else
	{
		for (int attemptIndex = 0; attemptIndex < _maxDownloadAttemptNumber && !downloadingCompleted; attemptIndex++)
		{
			bool downloadingStoppedByUser = false;
        
			try 
			{
				_logger->info(__FILEREF__ + "Downloading"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", localSourceReferenceURL: " + localSourceReferenceURL
					+ ", attempt: " + to_string(attemptIndex + 1)
					+ ", _maxDownloadAttemptNumber: " + to_string(_maxDownloadAttemptNumber)
				);
            
				if (attemptIndex == 0)
				{
					CurlDownloadData curlDownloadData;
					curlDownloadData.currentChunkNumber = 0;
					curlDownloadData.currentTotalSize = 0;
					curlDownloadData.destBinaryPathName   = destBinaryPathName;
					curlDownloadData.maxChunkFileSize    = _downloadChunkSizeInMegaBytes * 1000000;
                
					// fstream mediaSourceFileStream(destBinaryPathName, ios::binary | ios::out);
					// mediaSourceFileStream.exceptions(ios::badbit | ios::failbit);   // setting the exception mask
					// FILE *mediaSourceFileStream = fopen(destBinaryPathName.c_str(), "wb");

					curlpp::Cleanup cleaner;
					curlpp::Easy request;

					// Set the writer callback to enable cURL 
					// to write result in a memory area
					// request.setOpt(new curlpp::options::WriteStream(&mediaSourceFileStream));
                
					// which timeout we have to use here???
					// request.setOpt(new curlpp::options::Timeout(curlTimeoutInSeconds));

					curlpp::options::WriteFunctionCurlFunction curlDownloadCallbackFunction(curlDownloadCallback);
					curlpp::OptionTrait<void *, CURLOPT_WRITEDATA> curlDownloadDataData(&curlDownloadData);
					request.setOpt(curlDownloadCallbackFunction);
					request.setOpt(curlDownloadDataData);

					// Setting the URL to retrive.
					request.setOpt(new curlpp::options::Url(localSourceReferenceURL));
					string httpsPrefix("https");
					if (localSourceReferenceURL.size() >= httpsPrefix.size()
						&& 0 == localSourceReferenceURL.compare(0, httpsPrefix.size(), httpsPrefix))
					{
						// disconnect if we can't validate server's cert
						bool bSslVerifyPeer = false;
						curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
						request.setOpt(sslVerifyPeer);

						curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
						request.setOpt(sslVerifyHost);
					}

					chrono::system_clock::time_point lastProgressUpdate = chrono::system_clock::now();
					double lastPercentageUpdated = -1.0;
					curlpp::types::ProgressFunctionFunctor functor = bind(&MMSEngineProcessor::progressDownloadCallback, this,
                        ingestionJobKey, lastProgressUpdate, lastPercentageUpdated, downloadingStoppedByUser,
                        placeholders::_1, placeholders::_2, placeholders::_3, placeholders::_4);
					request.setOpt(new curlpp::options::ProgressFunction(curlpp::types::ProgressFunctionFunctor(functor)));
					request.setOpt(new curlpp::options::NoProgress(0L));
                
					_logger->info(__FILEREF__ + "Downloading media file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", localSourceReferenceURL: " + localSourceReferenceURL
					);
					request.perform();
                
					(curlDownloadData.mediaSourceFileStream).close();

					/*
					string localPathFileName = curlDownloadData.destBinaryPathName
                        + ".new";
					if (curlDownloadData.currentChunkNumber >= 2)
					{
						try
						{
							bool removeSrcFileAfterConcat = true;

							_logger->info(__FILEREF__ + "Concat file"
								+ ", localPathFileName: " + localPathFileName
								+ ", curlDownloadData.destBinaryPathName: " + curlDownloadData.destBinaryPathName
								+ ", removeSrcFileAfterConcat: " + to_string(removeSrcFileAfterConcat)
							);

							FileIO::concatFile(curlDownloadData.destBinaryPathName, localPathFileName, removeSrcFileAfterConcat);
						}
						catch(runtime_error e)
						{
							string errorMessage = string("Error to concat file")
								+ ", localPathFileName: " + localPathFileName
								+ ", curlDownloadData.destBinaryPathName: " + curlDownloadData.destBinaryPathName
									+ ", e.what(): " + e.what()
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);            
						}
						catch(exception e)
						{
							string errorMessage = string("Error to concat file")
								+ ", localPathFileName: " + localPathFileName
								+ ", curlDownloadData.destBinaryPathName: " + curlDownloadData.destBinaryPathName
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);            
						}
					}
					*/
				}
				else
				{
					_logger->warn(__FILEREF__ + "Coming from a download failure, trying to Resume"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					);
                
					// FILE *mediaSourceFileStream = fopen(destBinaryPathName.c_str(), "wb+");
					long long fileSize;
					{
						ofstream mediaSourceFileStream(destBinaryPathName, ofstream::binary | ofstream::app);
						fileSize = mediaSourceFileStream.tellp();
						mediaSourceFileStream.close();
					}

					CurlDownloadData curlDownloadData;
					curlDownloadData.destBinaryPathName   = destBinaryPathName;
					curlDownloadData.maxChunkFileSize    = _downloadChunkSizeInMegaBytes * 1000000;

					curlDownloadData.currentChunkNumber = fileSize % curlDownloadData.maxChunkFileSize;
					// fileSize = curlDownloadData.currentChunkNumber * curlDownloadData.maxChunkFileSize;
					curlDownloadData.currentTotalSize = fileSize;

					curlpp::Cleanup cleaner;
					curlpp::Easy request;

					// Set the writer callback to enable cURL 
					// to write result in a memory area
					// request.setOpt(new curlpp::options::WriteStream(&mediaSourceFileStream));

					curlpp::options::WriteFunctionCurlFunction curlDownloadCallbackFunction(curlDownloadCallback);
					curlpp::OptionTrait<void *, CURLOPT_WRITEDATA> curlDownloadDataData(&curlDownloadData);
					request.setOpt(curlDownloadCallbackFunction);
					request.setOpt(curlDownloadDataData);

					// which timeout we have to use here???
					// request.setOpt(new curlpp::options::Timeout(curlTimeoutInSeconds));

					// Setting the URL to retrive.
					request.setOpt(new curlpp::options::Url(localSourceReferenceURL));
					string httpsPrefix("https");
					if (localSourceReferenceURL.size() >= httpsPrefix.size()
						&& 0 == localSourceReferenceURL.compare(0, httpsPrefix.size(), httpsPrefix))
					{
						_logger->info(__FILEREF__ + "Setting SslEngineDefault"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						);
						request.setOpt(new curlpp::options::SslEngineDefault());
					}

					chrono::system_clock::time_point lastTimeProgressUpdate = chrono::system_clock::now();
					double lastPercentageUpdated = -1.0;
					curlpp::types::ProgressFunctionFunctor functor = bind(&MMSEngineProcessor::progressDownloadCallback, this,
                        ingestionJobKey, lastTimeProgressUpdate, lastPercentageUpdated, downloadingStoppedByUser,
                        placeholders::_1, placeholders::_2, placeholders::_3, placeholders::_4);
					request.setOpt(new curlpp::options::ProgressFunction(curlpp::types::ProgressFunctionFunctor(functor)));
					request.setOpt(new curlpp::options::NoProgress(0L));
                
					if (fileSize > 2 * 1000 * 1000 * 1000)
						request.setOpt(new curlpp::options::ResumeFromLarge(fileSize));
					else
						request.setOpt(new curlpp::options::ResumeFrom(fileSize));
                
					_logger->info(__FILEREF__ + "Resume Download media file"
						+ ", _processorIdentifier: " + to_string(_processorIdentifier)
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
						+ ", localSourceReferenceURL: " + localSourceReferenceURL
						+ ", resuming from fileSize: " + to_string(fileSize)
					);
					request.perform();
                
					(curlDownloadData.mediaSourceFileStream).close();

					/*
					string localPathFileName = curlDownloadData.destBinaryPathName
                        + ".new";
					if (curlDownloadData.currentChunkNumber >= 2)
					{
						try
						{
							bool removeSrcFileAfterConcat = true;

							_logger->info(__FILEREF__ + "Concat file"
								+ ", localPathFileName: " + localPathFileName
								+ ", curlDownloadData.destBinaryPathName: " + curlDownloadData.destBinaryPathName
								+ ", removeSrcFileAfterConcat: " + to_string(removeSrcFileAfterConcat)
							);

							FileIO::concatFile(curlDownloadData.destBinaryPathName, localPathFileName, removeSrcFileAfterConcat);
						}
						catch(runtime_error e)
						{
							string errorMessage = string("Error to concat file")
								+ ", localPathFileName: " + localPathFileName
								+ ", curlDownloadData.destBinaryPathName: " + curlDownloadData.destBinaryPathName
									+ ", e.what(): " + e.what()
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);            
						}
						catch(exception e)
						{
							string errorMessage = string("Error to concat file")
								+ ", localPathFileName: " + localPathFileName
								+ ", curlDownloadData.destBinaryPathName: " + curlDownloadData.destBinaryPathName
							;
							_logger->error(__FILEREF__ + errorMessage);

							throw runtime_error(errorMessage);            
						}
					}
					*/
				}

				if (localM3u8TarGzOrM3u8Streaming == 1)
				{
					try
					{
						// by a convention, the directory inside the tar file has to be named as 'content'
						string sourcePathName = "/content.tar.gz";

						_mmsStorage->manageTarFileInCaseOfIngestionOfSegments(ingestionJobKey,
							destBinaryPathName, workspaceIngestionRepository,
							sourcePathName);
					}
					catch(runtime_error e)
					{
						string errorMessage = string("manageTarFileInCaseOfIngestionOfSegments failed")
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
							+ ", localSourceReferenceURL: " + localSourceReferenceURL 
						;
           
						_logger->error(__FILEREF__ + errorMessage);
           
						throw runtime_error(errorMessage);
					}
				}

				downloadingCompleted = true;

				_logger->info(__FILEREF__ + "Update IngestionJob"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", destBinaryPathName: " + destBinaryPathName
					+ ", downloadingCompleted: " + to_string(downloadingCompleted)
				);
				_mmsEngineDBFacade->updateIngestionJobSourceBinaryTransferred (
					ingestionJobKey, downloadingCompleted);
			}
			catch (curlpp::LogicError & e) 
			{
				_logger->error(__FILEREF__ + "Download failed (LogicError)"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", localSourceReferenceURL: " + localSourceReferenceURL 
					+ ", exception: " + e.what()
				);

				if (downloadingStoppedByUser)
				{
					downloadingCompleted = true;
				}
				else
				{
					if (attemptIndex + 1 == _maxDownloadAttemptNumber)
					{
						_logger->error(__FILEREF__ + "Reached the max number of download attempts"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", _maxDownloadAttemptNumber: " + to_string(_maxDownloadAttemptNumber)
						);
                    
						_logger->info(__FILEREF__ + "Update IngestionJob"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_IngestionFailure"
							+ ", errorMessage: " + e.what()
						);                            
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
								MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
								e.what());
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + re.what()
								);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + ex.what()
							);
						}

						return;
					}
					else
					{
						_logger->info(__FILEREF__ + "Download failed. sleeping before to attempt again"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
							+ ", localSourceReferenceURL: " + localSourceReferenceURL 
							+ ", _secondsWaitingAmongDownloadingAttempt: " + to_string(_secondsWaitingAmongDownloadingAttempt)
						);
						this_thread::sleep_for(chrono::seconds(_secondsWaitingAmongDownloadingAttempt));
					}
				}
			}
			catch (curlpp::RuntimeError & e) 
			{
				_logger->error(__FILEREF__ + "Download failed (RuntimeError)"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", localSourceReferenceURL: " + localSourceReferenceURL 
					+ ", exception: " + e.what()
				);

				if (downloadingStoppedByUser)
				{
					downloadingCompleted = true;
				}
				else
				{
					if (attemptIndex + 1 == _maxDownloadAttemptNumber)
					{
						_logger->info(__FILEREF__ + "Reached the max number of download attempts"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", _maxDownloadAttemptNumber: " + to_string(_maxDownloadAttemptNumber)
						);
                    
						_logger->info(__FILEREF__ + "Update IngestionJob"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_IngestionFailure"
							+ ", errorMessage: " + e.what()
						);                            
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
								MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
								e.what());
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + re.what()
							);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + ex.what()
							);
						}

						return;
					}
					else
					{
						_logger->info(__FILEREF__ + "Download failed. sleeping before to attempt again"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
							+ ", localSourceReferenceURL: " + localSourceReferenceURL 
							+ ", _secondsWaitingAmongDownloadingAttempt: " + to_string(_secondsWaitingAmongDownloadingAttempt)
						);
						this_thread::sleep_for(chrono::seconds(_secondsWaitingAmongDownloadingAttempt));
					}
				}
			}
			catch (runtime_error e)
			{
				_logger->error(__FILEREF__ + "Download failed (runtime_error)"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", localSourceReferenceURL: " + localSourceReferenceURL 
					+ ", exception: " + e.what()
				);

				if (downloadingStoppedByUser)
				{
					downloadingCompleted = true;
				}
				else
				{
					if (attemptIndex + 1 == _maxDownloadAttemptNumber)
					{
						_logger->info(__FILEREF__ + "Reached the max number of download attempts"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", _maxDownloadAttemptNumber: " + to_string(_maxDownloadAttemptNumber)
						);
                    
						_logger->info(__FILEREF__ + "Update IngestionJob"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_IngestionFailure"
							+ ", errorMessage: " + e.what()
						);                            
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
								MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
								e.what());
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + re.what()
								);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + ex.what()
							);
						}
                    
						return;
					}
					else
					{
						_logger->info(__FILEREF__ + "Download failed. sleeping before to attempt again"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
							+ ", localSourceReferenceURL: " + localSourceReferenceURL 
							+ ", _secondsWaitingAmongDownloadingAttempt: " + to_string(_secondsWaitingAmongDownloadingAttempt)
						);
						this_thread::sleep_for(chrono::seconds(_secondsWaitingAmongDownloadingAttempt));
					}
				}
			}
			catch (exception e)
			{
				_logger->error(__FILEREF__ + "Download failed (exception)"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", localSourceReferenceURL: " + localSourceReferenceURL 
					+ ", exception: " + e.what()
				);

				if (downloadingStoppedByUser)
				{
					downloadingCompleted = true;
				}
				else
				{
					if (attemptIndex + 1 == _maxDownloadAttemptNumber)
					{
						_logger->info(__FILEREF__ + "Reached the max number of download attempts"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", _maxDownloadAttemptNumber: " + to_string(_maxDownloadAttemptNumber)
						);
                    
						_logger->info(__FILEREF__ + "Update IngestionJob"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
							+ ", IngestionStatus: " + "End_IngestionFailure"
							+ ", errorMessage: " + e.what()
						);                            
						try
						{
							_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
								MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
								e.what());
						}
						catch(runtime_error& re)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + re.what()
							);
						}
						catch(exception ex)
						{
							_logger->info(__FILEREF__ + "Update IngestionJob failed"
								+ ", _processorIdentifier: " + to_string(_processorIdentifier)
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
								+ ", errorMessage: " + ex.what()
							);
						}
                    
						return;
					}
					else
					{
						_logger->info(__FILEREF__ + "Download failed. sleeping before to attempt again"
							+ ", _processorIdentifier: " + to_string(_processorIdentifier)
							+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
							+ ", localSourceReferenceURL: " + localSourceReferenceURL 
							+ ", _secondsWaitingAmongDownloadingAttempt: " + to_string(_secondsWaitingAmongDownloadingAttempt)
						);
						this_thread::sleep_for(chrono::seconds(_secondsWaitingAmongDownloadingAttempt));
					}
				}
			}
		}
	}
}

void MMSEngineProcessor::ftpUploadMediaSource(
	string mmsAssetPathName, string fileName, int64_t sizeInBytes,
	int64_t ingestionJobKey, shared_ptr<Workspace> workspace,
	int64_t mediaItemKey, int64_t physicalPathKey,
	string ftpServer, int ftpPort, string ftpUserName, string ftpPassword, 
	string ftpRemoteDirectory, string ftpRemoteFileName)
{

    // curl -T localfile.ext ftp://username:password@ftp.server.com/remotedir/remotefile.zip


    try 
    {
		_logger->info(__FILEREF__ + "ftpUploadMediaSource"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
		);

        string ftpUrl = string("ftp://") + ftpUserName + ":" + ftpPassword + "@" 
                + ftpServer 
                + ":" + to_string(ftpPort) 
                + ftpRemoteDirectory;
        
        if (ftpRemoteDirectory.size() == 0 || ftpRemoteDirectory.back() != '/')
            ftpUrl  += "/";

        if (ftpRemoteFileName == "")
            ftpUrl  += fileName;
        else
            ftpUrl += ftpRemoteFileName;

        _logger->info(__FILEREF__ + "FTP Uploading"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", mmsAssetPathName: " + mmsAssetPathName
            + ", sizeInBytes: " + to_string(sizeInBytes)
            + ", ftpUrl: " + ftpUrl
        );

        ifstream mmsAssetStream(mmsAssetPathName, ifstream::binary);
        // FILE *mediaSourceFileStream = fopen(workspaceIngestionBinaryPathName.c_str(), "wb");

        // 1. PORT-mode FTP (Active) - NO Firewall friendly
        //  - FTP client: Sends a request to open a command channel from its TCP port (i.e.: 6000) to the FTP server’s TCP port 21
        //  - FTP client: Sends a data request (PORT command) to the FTP server. The FTP client includes in the PORT command the data port number 
        //      it opened to receive data. In this example, the FTP client has opened TCP port 6001 to receive the data.
        //  - FTP server opens a new inbound connection to the FTP client on the port indicated by the FTP client in the PORT command. 
        //      The FTP server source port is TCP port 20. In this example, the FTP server sends data from its own TCP port 20 to the FTP client’s TCP port 6001.
        //  In this conversation, two connections were established: an outbound connection initiated by the FTP client and an inbound connection established by the FTP server.
        // 2. PASV-mode FTP (Passive) - Firewall friendly
        //  - FTP client sends a request to open a command channel from its TCP port (i.e.: 6000) to the FTP server’s TCP port 21
        //  - FTP client sends a PASV command requesting that the FTP server open a port number that the FTP client can connect to establish the data channel.
        //      FTP serve sends over the command channel the TCP port number that the FTP client can initiate a connection to establish the data channel (i.e.: 7000)
        //  - FTP client opens a new connection from its own response port TCP 6001 to the FTP server’s data channel 7000. Data transfer takes place through this channel.
        
        // Active/Passive... see the next URL, section 'FTP Peculiarities We Need'
        // https://curl.haxx.se/libcurl/c/libcurl-tutorial.html

        // https://curl.haxx.se/libcurl/c/ftpupload.html
        curlpp::Cleanup cleaner;
        curlpp::Easy request;

        request.setOpt(new curlpp::options::Url(ftpUrl));
        request.setOpt(new curlpp::options::Verbose(false)); 
        request.setOpt(new curlpp::options::Upload(true)); 
        
		// which timeout we have to use here???
		// request.setOpt(new curlpp::options::Timeout(curlTimeoutInSeconds));

        request.setOpt(new curlpp::options::ReadStream(&mmsAssetStream));
        request.setOpt(new curlpp::options::InfileSizeLarge((curl_off_t) sizeInBytes));
        
        
        bool bFtpUseEpsv = false;
        curlpp::OptionTrait<bool, CURLOPT_FTP_USE_EPSV> ftpUseEpsv(bFtpUseEpsv);
        request.setOpt(ftpUseEpsv);

        // curl will default to binary transfer mode for FTP, 
        // and you ask for ascii mode instead with -B, --use-ascii or 
        // by making sure the URL ends with ;type=A.
        
        // timeout (CURLOPT_FTP_RESPONSE_TIMEOUT)
        
        bool bCreatingMissingDir = true;
        curlpp::OptionTrait<bool, CURLOPT_FTP_CREATE_MISSING_DIRS> creatingMissingDir(bCreatingMissingDir);
        request.setOpt(creatingMissingDir);

        string ftpsPrefix("ftps");
        if (ftpUrl.size() >= ftpsPrefix.size() && 0 == ftpUrl.compare(0, ftpsPrefix.size(), ftpsPrefix))
        {
            /* Next statements is in case we want ftp protocol to use SSL or TLS
             * google CURLOPT_FTPSSLAUTH and CURLOPT_FTP_SSL

            // disconnect if we can't validate server's cert
            bool bSslVerifyPeer = false;
            curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
            request.setOpt(sslVerifyPeer);

            curlpp::OptionTrait<curl_ftpssl, CURLOPT_FTP_SSL> ftpSsl(CURLFTPSSL_TRY);
            request.setOpt(ftpSsl);

            curlpp::OptionTrait<curl_ftpauth, CURLOPT_FTPSSLAUTH> ftpSslAuth(CURLFTPAUTH_TLS);
            request.setOpt(ftpSslAuth);
             */
        }

        // FTP progress works only in case of FTP Passive
        chrono::system_clock::time_point lastProgressUpdate = chrono::system_clock::now();
        double lastPercentageUpdated = -1.0;
        bool uploadingStoppedByUser = false;
        curlpp::types::ProgressFunctionFunctor functor = bind(&MMSEngineProcessor::progressUploadCallback, this,
                ingestionJobKey, lastProgressUpdate, lastPercentageUpdated, uploadingStoppedByUser,
                placeholders::_1, placeholders::_2, placeholders::_3, placeholders::_4);
        request.setOpt(new curlpp::options::ProgressFunction(curlpp::types::ProgressFunctionFunctor(functor)));
        request.setOpt(new curlpp::options::NoProgress(0L));

        _logger->info(__FILEREF__ + "FTP Uploading media file"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", mmsAssetPathName: " + mmsAssetPathName
            + ", sizeInBytes: " + to_string(sizeInBytes)
        );
        request.perform();

		// FTP-Delivery just forward the MIK to the next Task
		{
			_logger->info(__FILEREF__ + "addIngestionJobOutput"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", mediaItemKey: " + to_string(mediaItemKey)
				+ ", physicalPathKey: " + to_string(physicalPathKey)
			);
			int64_t liveRecordingIngestionJobKey = -1;
			_mmsEngineDBFacade->addIngestionJobOutput(ingestionJobKey,
				mediaItemKey, physicalPathKey, liveRecordingIngestionJobKey);
		}
    }
    catch (curlpp::LogicError & e) 
    {
        string errorMessage = __FILEREF__ + "Download failed (LogicError)"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", mmsAssetPathName: " + mmsAssetPathName 
            + ", exception: " + e.what()
        ;
		_logger->error(errorMessage);

        throw runtime_error(errorMessage);
	}
    catch (curlpp::RuntimeError & e) 
    {
        string errorMessage = __FILEREF__ + "Download failed (RuntimeError)"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", mmsAssetPathName: " + mmsAssetPathName 
            + ", exception: " + e.what()
        ;
		_logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
    catch (exception e)
    {
        string errorMessage = __FILEREF__ + "Download failed (exception)"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", mmsAssetPathName: " + mmsAssetPathName 
            + ", exception: " + e.what()
        ;
		_logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
}

size_t curlUploadVideoOnFacebookCallback(char* ptr, size_t size, size_t nmemb, void *f)
{
    MMSEngineProcessor::CurlUploadFacebookData* curlUploadData = (MMSEngineProcessor::CurlUploadFacebookData*) f;
    
    auto logger = spdlog::get("mmsEngineService");


    if (!curlUploadData->bodyFirstPartSent)
    {
        if (curlUploadData->bodyFirstPart.size() > size * nmemb)
        {
            logger->error(__FILEREF__ + "Not enougth memory!!!"
                + ", curlUploadData->bodyFirstPartSent: " + to_string(curlUploadData->bodyFirstPartSent)
                + ", curlUploadData->bodyFirstPart: " + curlUploadData->bodyFirstPart
                + ", curlUploadData->bodyLastPartSent: " + to_string(curlUploadData->bodyLastPartSent)
                + ", curlUploadData->bodyLastPart: " + curlUploadData->bodyLastPart
                + ", curlUploadData->startOffset: " + to_string(curlUploadData->startOffset)
                + ", curlUploadData->endOffset: " + to_string(curlUploadData->endOffset)
                + ", curlUploadData->currentOffset: " + to_string(curlUploadData->currentOffset)
                + ", curlUploadData->bodyFirstPart.size(): " + to_string(curlUploadData->bodyFirstPart.size())
                + ", size * nmemb: " + to_string(size * nmemb)
            );

            return CURL_READFUNC_ABORT;
        }
        
        strcpy(ptr, curlUploadData->bodyFirstPart.c_str());
        
        curlUploadData->bodyFirstPartSent = true;

        logger->info(__FILEREF__ + "First read"
             + ", curlUploadData->bodyFirstPartSent: " + to_string(curlUploadData->bodyFirstPartSent)
             + ", curlUploadData->bodyFirstPart: " + curlUploadData->bodyFirstPart
             + ", curlUploadData->bodyLastPartSent: " + to_string(curlUploadData->bodyLastPartSent)
             + ", curlUploadData->bodyLastPart: " + curlUploadData->bodyLastPart
             + ", curlUploadData->startOffset: " + to_string(curlUploadData->startOffset)
             + ", curlUploadData->endOffset: " + to_string(curlUploadData->endOffset)
             + ", curlUploadData->currentOffset: " + to_string(curlUploadData->currentOffset)
        );
        
        return curlUploadData->bodyFirstPart.size();
    }
    else if (curlUploadData->currentOffset == curlUploadData->endOffset)
    {
        if (!curlUploadData->bodyLastPartSent)
        {
            if (curlUploadData->bodyLastPart.size() > size * nmemb)
            {
                logger->error(__FILEREF__ + "Not enougth memory!!!"
                    + ", curlUploadData->bodyFirstPartSent: " + to_string(curlUploadData->bodyFirstPartSent)
                    + ", curlUploadData->bodyFirstPart: " + curlUploadData->bodyFirstPart
                    + ", curlUploadData->bodyLastPartSent: " + to_string(curlUploadData->bodyLastPartSent)
                    + ", curlUploadData->bodyLastPart: " + curlUploadData->bodyLastPart
                    + ", curlUploadData->startOffset: " + to_string(curlUploadData->startOffset)
                    + ", curlUploadData->endOffset: " + to_string(curlUploadData->endOffset)
                    + ", curlUploadData->currentOffset: " + to_string(curlUploadData->currentOffset)
                    + ", curlUploadData->bodyLastPart.size(): " + to_string(curlUploadData->bodyLastPart.size())
                    + ", size * nmemb: " + to_string(size * nmemb)
                );

                return CURL_READFUNC_ABORT;
            }

            strcpy(ptr, curlUploadData->bodyLastPart.c_str());

            curlUploadData->bodyLastPartSent = true;

            logger->info(__FILEREF__ + "Last read"
                + ", curlUploadData->bodyFirstPartSent: " + to_string(curlUploadData->bodyFirstPartSent)
                + ", curlUploadData->bodyFirstPart: " + curlUploadData->bodyFirstPart
                + ", curlUploadData->bodyLastPartSent: " + to_string(curlUploadData->bodyLastPartSent)
                + ", curlUploadData->bodyLastPart: " + curlUploadData->bodyLastPart
                + ", curlUploadData->startOffset: " + to_string(curlUploadData->startOffset)
                + ", curlUploadData->endOffset: " + to_string(curlUploadData->endOffset)
                + ", curlUploadData->currentOffset: " + to_string(curlUploadData->currentOffset)
            );

            return curlUploadData->bodyLastPart.size();
        }
        else
        {
            logger->error(__FILEREF__ + "This scenario should never happen because Content-Length was set"
                + ", curlUploadData->bodyFirstPartSent: " + to_string(curlUploadData->bodyFirstPartSent)
                + ", curlUploadData->bodyFirstPart: " + curlUploadData->bodyFirstPart
                + ", curlUploadData->bodyLastPartSent: " + to_string(curlUploadData->bodyLastPartSent)
                + ", curlUploadData->bodyLastPart: " + curlUploadData->bodyLastPart
                + ", curlUploadData->startOffset: " + to_string(curlUploadData->startOffset)
                + ", curlUploadData->endOffset: " + to_string(curlUploadData->endOffset)
                + ", curlUploadData->currentOffset: " + to_string(curlUploadData->currentOffset)
            );

            return CURL_READFUNC_ABORT;
        }
    }

    if(curlUploadData->currentOffset + (size * nmemb) <= curlUploadData->endOffset)
        curlUploadData->mediaSourceFileStream.read(ptr, size * nmemb);
    else
        curlUploadData->mediaSourceFileStream.read(ptr, curlUploadData->endOffset - curlUploadData->currentOffset);

    int64_t charsRead = curlUploadData->mediaSourceFileStream.gcount();
    
    curlUploadData->currentOffset += charsRead;

    return charsRead;        
};

void MMSEngineProcessor::postVideoOnFacebook(
        string mmsAssetPathName, int64_t sizeInBytes,
        int64_t ingestionJobKey, shared_ptr<Workspace> workspace,
        string facebookNodeId, string facebookConfigurationLabel
        )
{
            
    string facebookURL;
    string sResponse;
    
    try
    {
        _logger->info(__FILEREF__ + "postVideoOnFacebook"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", mmsAssetPathName: " + mmsAssetPathName
            + ", sizeInBytes: " + to_string(sizeInBytes)
            + ", facebookNodeId: " + facebookNodeId
            + ", facebookConfigurationLabel: " + facebookConfigurationLabel
        );
        
        string facebookPageToken = _mmsEngineDBFacade->getFacebookPageTokenByConfigurationLabel(
                workspace->_workspaceKey, facebookConfigurationLabel);            
        
        string fileFormat;
        {
            size_t extensionIndex = mmsAssetPathName.find_last_of(".");
            if (extensionIndex == string::npos)
            {
                string errorMessage = __FILEREF__ + "No fileFormat (extension of the file) found in mmsAssetPathName"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", mmsAssetPathName: " + mmsAssetPathName
                ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            fileFormat = mmsAssetPathName.substr(extensionIndex + 1);
        }
        
        /*
            curl \
                -X POST "https://graph-video.facebook.com/v2.3/1533641336884006/videos"  \
                -F "access_token=XXXXXXXXX" \
                -F "upload_phase=start" \
                -F "file_size=152043520"

                {"upload_session_id":"1564747013773438","video_id":"1564747010440105","start_offset":"0","end_offset":"52428800"}
        */
        string uploadSessionId;
        string videoId;
        int64_t startOffset;
        int64_t endOffset;
        // start
        {
            string facebookURI = string("/") + _facebookGraphAPIVersion + "/" + facebookNodeId + "/videos";
            
            facebookURL = _facebookGraphAPIProtocol
                + "://"
                + _facebookGraphAPIHostName
                + ":" + to_string(_facebookGraphAPIPort)
                + facebookURI;
            
            // we could apply md5 to utc time
            string boundary = to_string(chrono::system_clock::to_time_t(chrono::system_clock::now()));
            string endOfLine = "\r\n";
            string body =
                    "--" + boundary + endOfLine                    
                    + "Content-Disposition: form-data; name=\"access_token\"" + endOfLine + endOfLine
                    + facebookPageToken + endOfLine
                    
                    + "--" + boundary + endOfLine
                    + "Content-Disposition: form-data; name=\"upload_phase\"" + endOfLine + endOfLine
                    + "start" + endOfLine
                    
                    + "--" + boundary + endOfLine
                    + "Content-Disposition: form-data; name=\"file_size\"" + endOfLine + endOfLine
                    + to_string(sizeInBytes) + endOfLine

                    + "--" + boundary + "--" + endOfLine + endOfLine
                    ;

            list<string> header;
            string contentTypeHeader = "Content-Type: multipart/form-data; boundary=\"" + boundary + "\"";
            header.push_back(contentTypeHeader);

            curlpp::Cleanup cleaner;
            curlpp::Easy request;

            request.setOpt(new curlpp::options::PostFields(body));
            request.setOpt(new curlpp::options::PostFieldSize(body.length()));

            request.setOpt(new curlpp::options::Url(facebookURL));
            request.setOpt(new curlpp::options::Timeout(_facebookGraphAPITimeoutInSeconds));

            if (_facebookGraphAPIProtocol == "https")
            {
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
    //                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
    //                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;


                // cert is stored PEM coded in file... 
                // since PEM is default, we needn't set it for PEM 
                // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
                // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
                // equest.setOpt(sslCertType);

                // set the cert for client authentication
                // "testcert.pem"
                // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
                // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
                // request.setOpt(sslCert);

                // sorry, for engine we must set the passphrase
                //   (if the key has one...)
                // const char *pPassphrase = NULL;
                // if(pPassphrase)
                //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

                // if we use a key stored in a crypto engine,
                //   we must set the key type to "ENG"
                // pKeyType  = "PEM";
                // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

                // set the private key (file or ID in engine)
                // pKeyName  = "testkey.pem";
                // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

                // set the file with the certs vaildating the server
                // *pCACertFile = "cacert.pem";
                // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

                // disconnect if we can't validate server's cert
                bool bSslVerifyPeer = false;
                curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
                request.setOpt(sslVerifyPeer);

                curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
                request.setOpt(sslVerifyHost);

                // request.setOpt(new curlpp::options::SslEngineDefault());                                              

            }
            request.setOpt(new curlpp::options::HttpHeader(header));

            ostringstream response;
            request.setOpt(new curlpp::options::WriteStream(&response));

            _logger->info(__FILEREF__ + "Calling facebook"
                    + ", facebookURL: " + facebookURL
                    + ", _facebookGraphAPIProtocol: " + _facebookGraphAPIProtocol
                    + ", _facebookGraphAPIHostName: " + _facebookGraphAPIHostName
                    + ", _facebookGraphAPIPort: " + to_string(_facebookGraphAPIPort)
                    + ", facebookURI: " + facebookURI
                    + ", contentTypeHeader: " + contentTypeHeader
                    + ", body: " + body
            );
            request.perform();

            sResponse = response.str();
            _logger->info(__FILEREF__ + "Called facebook"
                    + ", facebookURL: " + facebookURL
                    + ", contentTypeHeader: " + contentTypeHeader
                    + ", body: " + body
                    + ", sResponse: " + sResponse
            );
            
            Json::Value facebookResponseRoot;
            try
            {
                Json::CharReaderBuilder builder;
                Json::CharReader* reader = builder.newCharReader();
                string errors;

                bool parsingSuccessful = reader->parse(sResponse.c_str(),
                        sResponse.c_str() + sResponse.size(), 
                        &facebookResponseRoot, &errors);
                delete reader;

                if (!parsingSuccessful)
                {
                    string errorMessage = __FILEREF__ + "failed to parse the facebook response"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", errors: " + errors
                            + ", sResponse: " + sResponse
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
            catch(...)
            {
                string errorMessage = string("facebook json response is not well format")
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(__FILEREF__ + errorMessage);

                throw runtime_error(errorMessage);
            }
            
            string field = "upload_session_id";
            if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field into the response is not present or it is null"
                        + ", Field: " + field
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            uploadSessionId = facebookResponseRoot.get(field, "XXX").asString();

            field = "video_id";
            if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field into the response is not present or it is null"
                        + ", Field: " + field
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            videoId = facebookResponseRoot.get(field, "XXX").asString();
            
            field = "start_offset";
            if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field into the response is not present or it is null"
                        + ", Field: " + field
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            string sStartOffset = facebookResponseRoot.get(field, "XXX").asString();
            startOffset = stoll(sStartOffset);
            
            field = "end_offset";
            if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field into the response is not present or it is null"
                        + ", Field: " + field
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            string sEndOffset = facebookResponseRoot.get(field, "XXX").asString();
            endOffset = stoll(sEndOffset);
        }
        
        while (startOffset < endOffset)
        {
            /*
                curl \
                    -X POST "https://graph-video.facebook.com/v2.3/1533641336884006/videos"  \
                    -F "access_token=XXXXXXX" \
                    -F "upload_phase=transfer" \
                    -F “start_offset=0" \
                    -F "upload_session_id=1564747013773438" \
                    -F "video_file_chunk=@chunk1.mp4"
            */
            // transfer
            {
                string facebookURI = string("/") + _facebookGraphAPIVersion + "/" + facebookNodeId + "/videos";

                facebookURL = _facebookGraphAPIProtocol
                    + "://"
                    + _facebookGraphAPIHostName
                    + ":" + to_string(_facebookGraphAPIPort)
                    + facebookURI;

                string mediaContentType = string("video") + "/" + fileFormat;                    
                
                // we could apply md5 to utc time
                string boundary = to_string(chrono::system_clock::to_time_t(chrono::system_clock::now()));
                string endOfLine = "\r\n";
                string bodyFirstPart =
                        "--" + boundary + endOfLine
                        + "Content-Disposition: form-data; name=\"access_token\"" + endOfLine + endOfLine
                        + facebookPageToken + endOfLine

                        + "--" + boundary + endOfLine
                        + "Content-Disposition: form-data; name=\"upload_phase\"" + endOfLine + endOfLine
                        + "transfer" + endOfLine

                        + "--" + boundary + endOfLine
                        + "Content-Disposition: form-data; name=\"start_offset\"" + endOfLine + endOfLine
                        + to_string(startOffset) + endOfLine

                        + "--" + boundary + endOfLine
                        + "Content-Disposition: form-data; name=\"upload_session_id\"" + endOfLine + endOfLine
                        + uploadSessionId + endOfLine

                        + "--" + boundary + endOfLine
                        + "Content-Disposition: form-data; name=\"video_file_chunk\"" + endOfLine
                        + "Content-Type: " + mediaContentType
                        + "Content-Length: " + (to_string(endOffset - startOffset)) + endOfLine + endOfLine
                        ;

                string bodyLastPart =
                        endOfLine + "--" + boundary + "--" + endOfLine + endOfLine
                        ;

                list<string> header;
                string contentTypeHeader = "Content-Type: multipart/form-data; boundary=\"" + boundary + "\"";
                header.push_back(contentTypeHeader);

                curlpp::Cleanup cleaner;
                curlpp::Easy request;

                CurlUploadFacebookData curlUploadData;
                {
                    curlUploadData.mediaSourceFileStream.open(mmsAssetPathName);

                    curlUploadData.bodyFirstPartSent    = false;
                    curlUploadData.bodyFirstPart        = bodyFirstPart;
                    
                    curlUploadData.bodyLastPartSent     = false;
                    curlUploadData.bodyLastPart         = bodyLastPart;

                    curlUploadData.currentOffset        = startOffset;

                    curlUploadData.startOffset          = startOffset;
                    curlUploadData.endOffset            = endOffset;

                    curlpp::options::ReadFunctionCurlFunction curlUploadCallbackFunction(curlUploadVideoOnFacebookCallback);
                    curlpp::OptionTrait<void *, CURLOPT_READDATA> curlUploadDataData(&curlUploadData);
                    request.setOpt(curlUploadCallbackFunction);
                    request.setOpt(curlUploadDataData);

                    bool upload = true;
                    request.setOpt(new curlpp::options::Upload(upload));
                }

                request.setOpt(new curlpp::options::Url(facebookURL));
                request.setOpt(new curlpp::options::Timeout(_facebookGraphAPITimeoutInSeconds));

                if (_facebookGraphAPIProtocol == "https")
                {
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;                            
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;                                          
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;                                  
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;                              
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;                                    
        //                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;                           
        //                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;                                         
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;                                          
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;                                          
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;                                 
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;                                    
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;                          
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;                                    


                    // cert is stored PEM coded in file... 
                    // since PEM is default, we needn't set it for PEM 
                    // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
                    // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
                    // equest.setOpt(sslCertType);

                    // set the cert for client authentication
                    // "testcert.pem"
                    // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
                    // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
                    // request.setOpt(sslCert);

                    // sorry, for engine we must set the passphrase
                    //   (if the key has one...)
                    // const char *pPassphrase = NULL;
                    // if(pPassphrase)
                    //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

                    // if we use a key stored in a crypto engine,
                    //   we must set the key type to "ENG"
                    // pKeyType  = "PEM";
                    // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

                    // set the private key (file or ID in engine)
                    // pKeyName  = "testkey.pem";
                    // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

                    // set the file with the certs vaildating the server
                    // *pCACertFile = "cacert.pem";
                    // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

                    // disconnect if we can't validate server's cert
                    bool bSslVerifyPeer = false;
                    curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
                    request.setOpt(sslVerifyPeer);

                    curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
                    request.setOpt(sslVerifyHost);

                    // request.setOpt(new curlpp::options::SslEngineDefault());                                              

                }
                request.setOpt(new curlpp::options::HttpHeader(header));

                ostringstream response;
                request.setOpt(new curlpp::options::WriteStream(&response));

                _logger->info(__FILEREF__ + "Calling facebook"
                        + ", facebookURL: " + facebookURL
                        + ", _facebookGraphAPIProtocol: " + _facebookGraphAPIProtocol
                        + ", _facebookGraphAPIHostName: " + _facebookGraphAPIHostName
                        + ", _facebookGraphAPIPort: " + to_string(_facebookGraphAPIPort)
                        + ", facebookURI: " + facebookURI
                        + ", bodyFirstPart: " + bodyFirstPart
                );
                request.perform();

                sResponse = response.str();
                _logger->info(__FILEREF__ + "Called facebook"
                        + ", facebookURL: " + facebookURL
                        + ", bodyFirstPart: " + bodyFirstPart
                        + ", sResponse: " + sResponse
                );

                Json::Value facebookResponseRoot;
                try
                {
                    Json::CharReaderBuilder builder;
                    Json::CharReader* reader = builder.newCharReader();
                    string errors;

                    bool parsingSuccessful = reader->parse(sResponse.c_str(),
                            sResponse.c_str() + sResponse.size(), 
                            &facebookResponseRoot, &errors);
                    delete reader;

                    if (!parsingSuccessful)
                    {
                        string errorMessage = __FILEREF__ + "failed to parse the facebook response"
                            + ", _processorIdentifier: " + to_string(_processorIdentifier)
                                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", errors: " + errors
                                + ", sResponse: " + sResponse
                                ;
                        _logger->error(errorMessage);

                        throw runtime_error(errorMessage);
                    }
                }
                catch(...)
                {
                    string errorMessage = string("facebook json response is not well format")
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", sResponse: " + sResponse
                            ;
                    _logger->error(__FILEREF__ + errorMessage);

                    throw runtime_error(errorMessage);
                }

                string field = "start_offset";
                if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
                {
                    string errorMessage = __FILEREF__ + "Field is not present or it is null"
                            + ", Field: " + field
                            + ", sResponse: " + sResponse
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
                string sStartOffset = facebookResponseRoot.get(field, "XXX").asString();
                startOffset = stoll(sStartOffset);

                field = "end_offset";
                if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
                {
                    string errorMessage = __FILEREF__ + "Field is not present or it is null"
                            + ", Field: " + field
                            + ", sResponse: " + sResponse
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
                string sEndOffset = facebookResponseRoot.get(field, "XXX").asString();
                endOffset = stoll(sEndOffset);
            }
        }
        
        /*
            curl \
                -X POST "https://graph-video.facebook.com/v2.3/1533641336884006/videos"  \
                -F "access_token=XXXXXXXX" \
                -F "upload_phase=finish" \
                -F "upload_session_id=1564747013773438" 

            {"success":true}
        */
        // finish: pubblica il video e mettilo in coda per la codifica asincrona
        bool success;
        {
            string facebookURI = string("/") + _facebookGraphAPIVersion + "/" + facebookNodeId + "/videos";
            
            facebookURL = _facebookGraphAPIProtocol
                + "://"
                + _facebookGraphAPIHostName
                + ":" + to_string(_facebookGraphAPIPort)
                + facebookURI;
            
            // we could apply md5 to utc time
            string boundary = to_string(chrono::system_clock::to_time_t(chrono::system_clock::now()));
            string endOfLine = "\r\n";
            string body =
                    "--" + boundary + endOfLine                    
                    + "Content-Disposition: form-data; name=\"access_token\"" + endOfLine + endOfLine
                    + facebookPageToken + endOfLine
                    
                    + "--" + boundary + endOfLine                    
                    + "Content-Disposition: form-data; name=\"upload_phase\"" + endOfLine + endOfLine
                    + "finish" + endOfLine
                    
                    + "--" + boundary + endOfLine                    
                    + "Content-Disposition: form-data; name=\"upload_session_id\"" + endOfLine + endOfLine
                    + uploadSessionId + endOfLine

                    + "--" + boundary + "--" + endOfLine + endOfLine
                    ;

            list<string> header;
            string contentTypeHeader = "Content-Type: multipart/form-data; boundary=\"" + boundary + "\"";
            header.push_back(contentTypeHeader);

            curlpp::Cleanup cleaner;
            curlpp::Easy request;

            request.setOpt(new curlpp::options::PostFields(body));
            request.setOpt(new curlpp::options::PostFieldSize(body.length()));

            request.setOpt(new curlpp::options::Url(facebookURL));
            request.setOpt(new curlpp::options::Timeout(_facebookGraphAPITimeoutInSeconds));

            if (_facebookGraphAPIProtocol == "https")
            {
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;                            
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;                                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;                                  
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;                              
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;                                    
    //                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;                           
    //                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;                                         
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;                                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;                                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;                                 
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;                                    
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;                                    


                // cert is stored PEM coded in file... 
                // since PEM is default, we needn't set it for PEM 
                // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
                // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
                // equest.setOpt(sslCertType);

                // set the cert for client authentication
                // "testcert.pem"
                // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
                // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
                // request.setOpt(sslCert);

                // sorry, for engine we must set the passphrase
                //   (if the key has one...)
                // const char *pPassphrase = NULL;
                // if(pPassphrase)
                //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

                // if we use a key stored in a crypto engine,
                //   we must set the key type to "ENG"
                // pKeyType  = "PEM";
                // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

                // set the private key (file or ID in engine)
                // pKeyName  = "testkey.pem";
                // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

                // set the file with the certs vaildating the server
                // *pCACertFile = "cacert.pem";
                // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

                // disconnect if we can't validate server's cert
                bool bSslVerifyPeer = false;
                curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
                request.setOpt(sslVerifyPeer);

                curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
                request.setOpt(sslVerifyHost);

                // request.setOpt(new curlpp::options::SslEngineDefault());                                              

            }
            request.setOpt(new curlpp::options::HttpHeader(header));

            ostringstream response;
            request.setOpt(new curlpp::options::WriteStream(&response));

            _logger->info(__FILEREF__ + "Calling facebook"
                    + ", facebookURL: " + facebookURL
                    + ", _facebookGraphAPIProtocol: " + _facebookGraphAPIProtocol
                    + ", _facebookGraphAPIHostName: " + _facebookGraphAPIHostName
                    + ", _facebookGraphAPIPort: " + to_string(_facebookGraphAPIPort)
                    + ", facebookURI: " + facebookURI
                    + ", body: " + body
            );
            request.perform();

            sResponse = response.str();
            _logger->info(__FILEREF__ + "Called facebook"
                    + ", facebookURL: " + facebookURL
                    + ", body: " + body
                    + ", sResponse: " + sResponse
            );
            
            Json::Value facebookResponseRoot;
            try
            {
                Json::CharReaderBuilder builder;
                Json::CharReader* reader = builder.newCharReader();
                string errors;

                bool parsingSuccessful = reader->parse(sResponse.c_str(),
                        sResponse.c_str() + sResponse.size(), 
                        &facebookResponseRoot, &errors);
                delete reader;

                if (!parsingSuccessful)
                {
                    string errorMessage = __FILEREF__ + "failed to parse the facebook response"
                        + ", _processorIdentifier: " + to_string(_processorIdentifier)
                            + ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", errors: " + errors
                            + ", sResponse: " + sResponse
                            ;
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
            catch(...)
            {
                string errorMessage = string("facebook json response is not well format")
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                        + ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(__FILEREF__ + errorMessage);

                throw runtime_error(errorMessage);
            }
            
            string field = "success";
            if (!JSONUtils::isMetadataPresent(facebookResponseRoot, field))
            {
                string errorMessage = __FILEREF__ + "Field is not present or it is null"
                        + ", Field: " + field
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            success = JSONUtils::asBool(facebookResponseRoot, field, false);

            if (!success)
            {
                string errorMessage = __FILEREF__ + "Post Video on Facebook failed"
                        + ", Field: " + field
                        + ", success: " + to_string(success)
                        + ", sResponse: " + sResponse
                        ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
        }        
    }
    catch (curlpp::LogicError & e) 
    {
		string errorMessage = __FILEREF__ + "Post video on Facebook failed (LogicError)"
            + ", facebookURL: " + facebookURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
    catch (curlpp::RuntimeError & e) 
    {
		string errorMessage = __FILEREF__ + "Post video on Facebook failed (RuntimeError)"
            + ", facebookURL: " + facebookURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
    catch (runtime_error e)
    {
		string errorMessage = __FILEREF__ + "Post video on Facebook failed (runtime_error)"
            + ", facebookURL: " + facebookURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
    catch (exception e)
    {
		string errorMessage = __FILEREF__ + "Post video on Facebook failed (exception)"
            + ", facebookURL: " + facebookURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

        throw runtime_error(errorMessage);
    }
}

size_t curlUploadVideoOnYouTubeCallback(char* ptr, size_t size, size_t nmemb, void *f)
{
    MMSEngineProcessor::CurlUploadYouTubeData* curlUploadData = (MMSEngineProcessor::CurlUploadYouTubeData*) f;
    
    auto logger = spdlog::get("mmsEngineService");

    int64_t currentFilePosition = curlUploadData->mediaSourceFileStream.tellg();

    /*    
    logger->info(__FILEREF__ + "curlUploadVideoOnYouTubeCallback"
        + ", currentFilePosition: " + to_string(currentFilePosition)
        + ", size: " + to_string(size)
        + ", nmemb: " + to_string(nmemb)
        + ", curlUploadData->fileSizeInBytes: " + to_string(curlUploadData->fileSizeInBytes)
    );
    */

    if(currentFilePosition + (size * nmemb) <= curlUploadData->fileSizeInBytes)
        curlUploadData->mediaSourceFileStream.read(ptr, size * nmemb);
    else
        curlUploadData->mediaSourceFileStream.read(ptr, curlUploadData->fileSizeInBytes - currentFilePosition);

    int64_t charsRead = curlUploadData->mediaSourceFileStream.gcount();
    
    return charsRead;        
};

void MMSEngineProcessor::postVideoOnYouTube(
        string mmsAssetPathName, int64_t sizeInBytes,
        int64_t ingestionJobKey, shared_ptr<Workspace> workspace,
        string youTubeConfigurationLabel, string youTubeTitle,
        string youTubeDescription, Json::Value youTubeTags,
        int youTubeCategoryId, string youTubePrivacy)
{

    string youTubeURL;
    string youTubeUploadURL;
    string sResponse;
    
    try
    {
        _logger->info(__FILEREF__ + "postVideoOnYouTubeThread"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", mmsAssetPathName: " + mmsAssetPathName
            + ", sizeInBytes: " + to_string(sizeInBytes)
            + ", youTubeConfigurationLabel: " + youTubeConfigurationLabel
            + ", youTubeTitle: " + youTubeTitle
            + ", youTubeDescription: " + youTubeDescription
            + ", youTubeCategoryId: " + to_string(youTubeCategoryId)
        );

		// 1. get refresh_token from the configuration
		// 2. call google API
		// 3. the response will have the access token to be used
        string youTubeAccessToken = getYouTubeAccessTokenByConfigurationLabel(
			ingestionJobKey,
            workspace, youTubeConfigurationLabel);

        string fileFormat;
        {
            size_t extensionIndex = mmsAssetPathName.find_last_of(".");
            if (extensionIndex == string::npos)
            {
                string errorMessage = __FILEREF__
					+ "No fileFormat (extension of the file) found in mmsAssetPathName"
                    + ", _processorIdentifier: " + to_string(_processorIdentifier)
                    + ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", mmsAssetPathName: " + mmsAssetPathName
                ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            fileFormat = mmsAssetPathName.substr(extensionIndex + 1);
        }
        
        /*
            POST /upload/youtube/v3/videos?uploadType=resumable&part=snippet,status,contentDetails HTTP/1.1
            Host: www.googleapis.com
            Authorization: Bearer AUTH_TOKEN
            Content-Length: 278
            Content-Type: application/json; charset=UTF-8
            X-Upload-Content-Length: 3000000
            X-Upload-Content-Type: video/*

            {
              "snippet": {
                "title": "My video title",
                "description": "This is a description of my video",
                "tags": ["cool", "video", "more keywords"],
                "categoryId": 22
              },
              "status": {
                "privacyStatus": "public",
                "embeddable": True,
                "license": "youtube"
              }
            }

            HTTP/1.1 200 OK
            Location: https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&upload_id=xa298sd_f&part=snippet,status,contentDetails
            Content-Length: 0
        */
        string videoContentType = "video/*";
        {
            youTubeURL = _youTubeDataAPIProtocol
                + "://"
                + _youTubeDataAPIHostName
                + ":" + to_string(_youTubeDataAPIPort)
                + _youTubeDataAPIUploadVideoURI;
    
            string body;
            {
                Json::Value bodyRoot;
                Json::Value snippetRoot;

                string field = "title";
                snippetRoot[field] = youTubeTitle;

                if (youTubeDescription != "")
                {
                    field = "description";
                    snippetRoot[field] = youTubeDescription;
                }

                if (youTubeTags != Json::nullValue)
                {
                    field = "tags";
                    snippetRoot[field] = youTubeTags;
                }

                if (youTubeCategoryId != -1)
                {
                    field = "categoryId";
                    snippetRoot[field] = youTubeCategoryId;
                }
                
                field = "snippet";
                bodyRoot[field] = snippetRoot;
                

                Json::Value statusRoot;

                field = "privacyStatus";
                statusRoot[field] = youTubePrivacy;

                field = "embeddable";
                statusRoot[field] = true;

                // field = "license";
                // statusRoot[field] = "youtube";

                field = "status";
                bodyRoot[field] = statusRoot;

                {
                    Json::StreamWriterBuilder wbuilder;
                    
                    body = Json::writeString(wbuilder, bodyRoot);
                }
            }

            list<string> headerList;

            {
                string header = "Authorization: Bearer " + youTubeAccessToken;
                headerList.push_back(header);

                header = "Content-Length: " + to_string(body.length());
                headerList.push_back(header);
                
                header = "Content-Type: application/json; charset=UTF-8";
                headerList.push_back(header);

                header = "X-Upload-Content-Length: " + to_string(sizeInBytes);
                headerList.push_back(header);
                
                header = string("X-Upload-Content-Type: ") + videoContentType;
                headerList.push_back(header);
            }                    

            curlpp::Cleanup cleaner;
            curlpp::Easy request;

            request.setOpt(new curlpp::options::PostFields(body));
            request.setOpt(new curlpp::options::PostFieldSize(body.length()));

            request.setOpt(new curlpp::options::Url(youTubeURL));
            request.setOpt(new curlpp::options::Timeout(_youTubeDataAPITimeoutInSeconds));

            if (_youTubeDataAPIProtocol == "https")
            {
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;                            
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;                                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;                                  
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;                              
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;                                    
    //                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;                           
    //                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;                                         
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;                                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;                                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;                                 
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;                                    
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;                          
    //                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;                                    


                // cert is stored PEM coded in file... 
                // since PEM is default, we needn't set it for PEM 
                // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
                // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
                // equest.setOpt(sslCertType);

                // set the cert for client authentication
                // "testcert.pem"
                // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
                // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
                // request.setOpt(sslCert);

                // sorry, for engine we must set the passphrase
                //   (if the key has one...)
                // const char *pPassphrase = NULL;
                // if(pPassphrase)
                //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

                // if we use a key stored in a crypto engine,
                //   we must set the key type to "ENG"
                // pKeyType  = "PEM";
                // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

                // set the private key (file or ID in engine)
                // pKeyName  = "testkey.pem";
                // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

                // set the file with the certs vaildating the server
                // *pCACertFile = "cacert.pem";
                // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

                // disconnect if we can't validate server's cert
                bool bSslVerifyPeer = false;
                curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
                request.setOpt(sslVerifyPeer);

                curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
                request.setOpt(sslVerifyHost);

                // request.setOpt(new curlpp::options::SslEngineDefault());                                              

            }
            
            for (string headerMessage: headerList)
                _logger->info(__FILEREF__ + "Adding header message: " + headerMessage);
            request.setOpt(new curlpp::options::HttpHeader(headerList));

            ostringstream response;
            request.setOpt(new curlpp::options::WriteStream(&response));

            // store response headers in the response
            // You simply have to set next option to prefix the header to the normal body output. 
            request.setOpt(new curlpp::options::Header(true)); 
            
            _logger->info(__FILEREF__ + "Calling youTube (first call)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeURL: " + youTubeURL
				+ ", body: " + body
			);
            request.perform();

            long responseCode = curlpp::infos::ResponseCode::get(request);

            sResponse = response.str();
            _logger->info(__FILEREF__ + "Called youTube (first call)"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", youTubeURL: " + youTubeURL
                + ", body: " + body
                + ", responseCode: " + to_string(responseCode)
                + ", sResponse: " + sResponse
            );
            
            if (responseCode != 200 ||
				(sResponse.find("Location: ") == string::npos &&
				 sResponse.find("location: ") == string::npos)
			)
            {
                string errorMessage = __FILEREF__ + "youTube (first call) failed"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", youTubeURL: " + youTubeURL
                    + ", body: " + body
                    + ", responseCode: " + to_string(responseCode)
                    + ", sResponse: " + sResponse
                ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
            
            /* sResponse:
                HTTP/1.1 200 OK
                X-GUploader-UploadID: AEnB2UqO5ml7GRPs5AjsOSPzSGwudclcEFbyXtEK_TLWRhggwxh9gTWBdusefTgmX2ul9axk4ztG_YBWQXGtm1M42Fz9QVE4xA
                Location: https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status,contentDetails&upload_id=AEnB2UqO5ml7GRPs5AjsOSPzSGwudclcEFbyXtEK_TLWRhggwxh9gTWBdusefTgmX2ul9axk4ztG_YBWQXGtm1M42Fz9QVE4xA
                ETag: "XI7nbFXulYBIpL0ayR_gDh3eu1k/bpNRC6h7Ng2_S5XJ6YzbSMF0qXE"
                Vary: Origin
                Vary: X-Origin
                X-Goog-Correlation-Id: FGN7H2Vxp5I
                Cache-Control: no-cache, no-store, max-age=0, must-revalidate
                Pragma: no-cache
                Expires: Mon, 01 Jan 1990 00:00:00 GMT
                Date: Sun, 09 Dec 2018 09:15:41 GMT
                Content-Length: 0
                Server: UploadServer
                Content-Type: text/html; charset=UTF-8
                Alt-Svc: quic=":443"; ma=2592000; v="44,43,39,35"
             */
            
            int locationStartIndex = sResponse.find("Location: ");
			if (locationStartIndex == string::npos)
				locationStartIndex = sResponse.find("location: ");
            locationStartIndex += string("Location: ").length();
            int locationEndIndex = sResponse.find("\r", locationStartIndex);
            if (locationEndIndex == string::npos)
                locationEndIndex = sResponse.find("\n", locationStartIndex);
            if (locationEndIndex == string::npos)
                youTubeUploadURL = sResponse.substr(locationStartIndex);
            else
                youTubeUploadURL = sResponse.substr(locationStartIndex,
					locationEndIndex - locationStartIndex);
        }

        bool contentCompletelyUploaded = false;
        CurlUploadYouTubeData curlUploadData;
        curlUploadData.mediaSourceFileStream.open(mmsAssetPathName, ios::binary);
        curlUploadData.lastByteSent = -1;
        curlUploadData.fileSizeInBytes = sizeInBytes;
        while (!contentCompletelyUploaded)
        {
            /*
                // In case of the first request
                PUT UPLOAD_URL HTTP/1.1
                Authorization: Bearer AUTH_TOKEN
                Content-Length: CONTENT_LENGTH
                Content-Type: CONTENT_TYPE

                BINARY_FILE_DATA

                // in case of resuming
                PUT UPLOAD_URL HTTP/1.1
                Authorization: Bearer AUTH_TOKEN
                Content-Length: REMAINING_CONTENT_LENGTH
                Content-Range: bytes FIRST_BYTE-LAST_BYTE/TOTAL_CONTENT_LENGTH

                PARTIAL_BINARY_FILE_DATA            
            */

            {                
                list<string> headerList;
                headerList.push_back(string("Authorization: Bearer ")
					+ youTubeAccessToken);
                if (curlUploadData.lastByteSent == -1)
                    headerList.push_back(string("Content-Length: ")
						+ to_string(sizeInBytes));
                else
                    headerList.push_back(string("Content-Length: ")
						+ to_string(sizeInBytes - curlUploadData.lastByteSent + 1));
                if (curlUploadData.lastByteSent == -1)
                    headerList.push_back(string("Content-Type: ")
						+ videoContentType);
                else
                    headerList.push_back(string("Content-Range: bytes ")
						+ to_string(curlUploadData.lastByteSent)
						+ "-" + to_string(sizeInBytes - 1) + "/"
						+ to_string(sizeInBytes));

                curlpp::Cleanup cleaner;
                curlpp::Easy request;

                {
                    curlpp::options::ReadFunctionCurlFunction
						curlUploadCallbackFunction(
						curlUploadVideoOnYouTubeCallback);
                    curlpp::OptionTrait<void *, CURLOPT_READDATA>
						curlUploadDataData(&curlUploadData);
                    request.setOpt(curlUploadCallbackFunction);
                    request.setOpt(curlUploadDataData);
           
                    bool upload = true;
                    request.setOpt(new curlpp::options::Upload(upload));
                }

                request.setOpt(new curlpp::options::CustomRequest{"PUT"});
                request.setOpt(new curlpp::options::Url(youTubeUploadURL));
                request.setOpt(new curlpp::options::Timeout(
					_youTubeDataAPITimeoutInSeconds));

                if (_youTubeDataAPIProtocol == "https")
                {
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
        //                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
        //                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
        //                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;


                    // cert is stored PEM coded in file... 
                    // since PEM is default, we needn't set it for PEM 
                    // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
                    // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
                    // equest.setOpt(sslCertType);

                    // set the cert for client authentication
                    // "testcert.pem"
                    // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
                    // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
                    // request.setOpt(sslCert);

                    // sorry, for engine we must set the passphrase
                    //   (if the key has one...)
                    // const char *pPassphrase = NULL;
                    // if(pPassphrase)
                    //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

                    // if we use a key stored in a crypto engine,
                    //   we must set the key type to "ENG"
                    // pKeyType  = "PEM";
                    // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

                    // set the private key (file or ID in engine)
                    // pKeyName  = "testkey.pem";
                    // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

                    // set the file with the certs vaildating the server
                    // *pCACertFile = "cacert.pem";
                    // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

                    // disconnect if we can't validate server's cert
                    bool bSslVerifyPeer = false;
                    curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(
						bSslVerifyPeer);
                    request.setOpt(sslVerifyPeer);

                    curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST>
						sslVerifyHost(0L);
                    request.setOpt(sslVerifyHost);

                    // request.setOpt(new curlpp::options::SslEngineDefault());                                              

                }

                for (string headerMessage: headerList)
                    _logger->info(__FILEREF__
						+ "Adding header message: " + headerMessage);
                request.setOpt(new curlpp::options::HttpHeader(headerList));

                _logger->info(__FILEREF__ + "Calling youTube (upload)"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", youTubeUploadURL: " + youTubeUploadURL
                );
                request.perform();

                long responseCode = curlpp::infos::ResponseCode::get(request);
                
                _logger->info(__FILEREF__ + "Called youTube (upload)"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", youTubeUploadURL: " + youTubeUploadURL
                    + ", responseCode: " + to_string(responseCode)
                );
                
                if (responseCode == 200 || responseCode == 201)
                {
                    _logger->info(__FILEREF__ + "youTube upload successful"
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", youTubeUploadURL: " + youTubeUploadURL
                        + ", responseCode: " + to_string(responseCode)
                    );

                    contentCompletelyUploaded = true;
                }
                else if (responseCode == 500 
                        || responseCode == 502
                        || responseCode == 503
                        || responseCode == 504
                        )
                {                    
                    _logger->warn(__FILEREF__
						+ "youTube upload failed, trying to resume"
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", youTubeUploadURL: " + youTubeUploadURL
                        + ", responseCode: " + to_string(responseCode)
                    );
                    
                    /*
                        PUT UPLOAD_URL HTTP/1.1
                        Authorization: Bearer AUTH_TOKEN
                        Content-Length: 0
                        Content-Range: bytes *\/CONTENT_LENGTH

                        308 Resume Incomplete
                        Content-Length: 0
                        Range: bytes=0-999999
                    */
                    {                
                        list<string> headerList;
                        headerList.push_back(string("Authorization: Bearer ")
							+ youTubeAccessToken);
                        headerList.push_back(string("Content-Length: 0"));
                        headerList.push_back(string("Content-Range: bytes */")
							+ to_string(sizeInBytes));

                        curlpp::Cleanup cleaner;
                        curlpp::Easy request;

                        request.setOpt(new curlpp::options::CustomRequest{"PUT"});
                        request.setOpt(new curlpp::options::Url(youTubeUploadURL));
                        request.setOpt(new curlpp::options::Timeout(
								_youTubeDataAPITimeoutInSeconds));

                        if (_youTubeDataAPIProtocol == "https")
                        {
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
                //                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
                //                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
                //                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;


                            // cert is stored PEM coded in file... 
                            // since PEM is default, we needn't set it for PEM 
                            // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
                            // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
                            // equest.setOpt(sslCertType);

                            // set the cert for client authentication
                            // "testcert.pem"
                            // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
                            // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
                            // request.setOpt(sslCert);

                            // sorry, for engine we must set the passphrase
                            //   (if the key has one...)
                            // const char *pPassphrase = NULL;
                            // if(pPassphrase)
                            //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

                            // if we use a key stored in a crypto engine,
                            //   we must set the key type to "ENG"
                            // pKeyType  = "PEM";
                            // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

                            // set the private key (file or ID in engine)
                            // pKeyName  = "testkey.pem";
                            // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

                            // set the file with the certs vaildating the server
                            // *pCACertFile = "cacert.pem";
                            // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

                            // disconnect if we can't validate server's cert
                            bool bSslVerifyPeer = false;
                            curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
                            request.setOpt(sslVerifyPeer);

                            curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
                            request.setOpt(sslVerifyHost);

                            // request.setOpt(new curlpp::options::SslEngineDefault());                                              

                        }
                        
                        for (string headerMessage: headerList)
                            _logger->info(__FILEREF__ + "Adding header message: " + headerMessage);
                        request.setOpt(new curlpp::options::HttpHeader(headerList));

                        ostringstream response;
                        request.setOpt(new curlpp::options::WriteStream(&response));

                        // store response headers in the response
                        // You simply have to set next option to prefix the header to the normal body output. 
                        request.setOpt(new curlpp::options::Header(true));
            
                        _logger->info(__FILEREF__ + "Calling youTube check status"
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", youTubeUploadURL: " + youTubeUploadURL
                            + ", _youTubeDataAPIProtocol: " + _youTubeDataAPIProtocol
                            + ", _youTubeDataAPIHostName: " + _youTubeDataAPIHostName
                            + ", _youTubeDataAPIPort: " + to_string(_youTubeDataAPIPort)
                        );
                        request.perform();

                        sResponse = response.str();
                        long responseCode = curlpp::infos::ResponseCode::get(request);

                        _logger->info(__FILEREF__ + "Called youTube check status"
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", youTubeUploadURL: " + youTubeUploadURL
                            + ", responseCode: " + to_string(responseCode)
                            + ", sResponse: " + sResponse
                        );

                        if (responseCode != 308 || sResponse.find("Range: bytes=") == string::npos)
                        {   
                            // error
                            string errorMessage (__FILEREF__ + "youTube check status failed"
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", youTubeUploadURL: " + youTubeUploadURL
                                + ", responseCode: " + to_string(responseCode)
                            );
                            _logger->error(errorMessage);

                            throw runtime_error(errorMessage);
                        }
                        
                        /* sResponse: 
                            HTTP/1.1 308 Resume Incomplete
                            X-GUploader-UploadID: AEnB2Ur8jQ5DSbXieg8krXWg0f7Bmawvf6XTacURJ7wbITyXdTv8ZeHpepaUwh6F9DB5TvBCzoS4quZMKegyo2x7H9EJOc6ozQ
                            Range: bytes=0-1572863
                            X-Range-MD5: d50bc8fc7ecc41926f841085db3909b3
                            Content-Length: 0
                            Date: Mon, 10 Dec 2018 13:09:51 GMT
                            Server: UploadServer
                            Content-Type: text/html; charset=UTF-8
                            Alt-Svc: quic=":443"; ma=2592000; v="44,43,39,35"
                        */
                        int rangeStartIndex = sResponse.find("Range: bytes=");
                        rangeStartIndex += string("Range: bytes=").length();
                        int rangeEndIndex = sResponse.find("\r", rangeStartIndex);
                        if (rangeEndIndex == string::npos)
                            rangeEndIndex = sResponse.find("\n", rangeStartIndex);
                        string rangeHeader;
                        if (rangeEndIndex == string::npos)
                            rangeHeader = sResponse.substr(rangeStartIndex);
                        else
                            rangeHeader = sResponse.substr(rangeStartIndex, rangeEndIndex - rangeStartIndex);

                        int rangeStartOffsetIndex = rangeHeader.find("-");
                        if (rangeStartOffsetIndex == string::npos)
                        {   
                            // error
                            string errorMessage (__FILEREF__ + "youTube check status failed"
								+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                                + ", youTubeUploadURL: " + youTubeUploadURL
                                + ", rangeHeader: " + rangeHeader
                            );
                            _logger->error(errorMessage);

                            throw runtime_error(errorMessage);
                        }

                        _logger->info(__FILEREF__ + "Resuming"
							+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                            + ", youTubeUploadURL: " + youTubeUploadURL
                            + ", rangeHeader: " + rangeHeader
                            + ", rangeHeader.substr(rangeStartOffsetIndex + 1): "
								+ rangeHeader.substr(rangeStartOffsetIndex + 1)
                        );
                        curlUploadData.lastByteSent = stoll(rangeHeader.substr(rangeStartOffsetIndex + 1)) + 1;
                        curlUploadData.mediaSourceFileStream.seekg(curlUploadData.lastByteSent, ios::beg);
                    }
                }
                else
                {   
                    // error
                    string errorMessage (__FILEREF__ + "youTube upload failed"
						+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                        + ", youTubeUploadURL: " + youTubeUploadURL
                        + ", responseCode: " + to_string(responseCode)
                    );
                    _logger->error(errorMessage);

                    throw runtime_error(errorMessage);
                }
            }
        }
    }
    catch (curlpp::LogicError & e) 
    {
        string errorMessage = __FILEREF__ + "Post video on YouTube failed (LogicError)"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", youTubeURL: " + youTubeURL
            + ", youTubeUploadURL: " + youTubeUploadURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

		throw runtime_error(errorMessage);
    }
    catch (curlpp::RuntimeError & e) 
    {
        string errorMessage = __FILEREF__ + "Post video on YouTube failed (RuntimeError)"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", youTubeURL: " + youTubeURL
            + ", youTubeUploadURL: " + youTubeUploadURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

		throw runtime_error(errorMessage);
    }
    catch (runtime_error e)
    {
        string errorMessage = __FILEREF__ + "Post video on YouTube failed (runtime_error)"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", youTubeURL: " + youTubeURL
            + ", youTubeUploadURL: " + youTubeUploadURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

		throw runtime_error(errorMessage);
    }
    catch (exception e)
    {
        string errorMessage = __FILEREF__ + "Post video on YouTube failed (exception)"
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", youTubeURL: " + youTubeURL
            + ", youTubeUploadURL: " + youTubeUploadURL
            + ", exception: " + e.what()
            + ", sResponse: " + sResponse
        ;
        _logger->error(errorMessage);

		throw runtime_error(errorMessage);
    }
}

string MMSEngineProcessor::getYouTubeAccessTokenByConfigurationLabel(
	int64_t ingestionJobKey,
    shared_ptr<Workspace> workspace, string youTubeConfigurationLabel)
{
    string youTubeURL;
    string sResponse;
    
    try
    {
        tuple<string, string, string> youTubeDetails =
			_mmsEngineDBFacade->getYouTubeDetailsByConfigurationLabel(
                workspace->_workspaceKey, youTubeConfigurationLabel);            

		string youTubeTokenType;
		string youTubeRefreshToken;
		string youTubeAccessToken;
		tie(youTubeTokenType, youTubeRefreshToken, youTubeAccessToken)
			= youTubeDetails;

		if (youTubeTokenType == "AccessToken")
		{
			_logger->info(__FILEREF__ + "Using the youTube access token"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", youTubeAccessToken: " + youTubeAccessToken
			);

			return youTubeAccessToken;
		}

        youTubeURL = _youTubeDataAPIProtocol
            + "://"
            + _youTubeDataAPIHostName
            + ":" + to_string(_youTubeDataAPIPort)
            + _youTubeDataAPIRefreshTokenURI;

        string body =
			string("client_id=") + _youTubeDataAPIClientId
			+ "&client_secret=" + _youTubeDataAPIClientSecret
			+ "&refresh_token=" + youTubeRefreshToken
			+ "&grant_type=refresh_token";

        list<string> headerList;

        {
            /*
            header = "Content-Length: " + to_string(body.length());
            headerList.push_back(header);
            */

            string header = "Content-Type: application/x-www-form-urlencoded";
            headerList.push_back(header);
        }

        curlpp::Cleanup cleaner;
        curlpp::Easy request;

        request.setOpt(new curlpp::options::PostFields(body));
        request.setOpt(new curlpp::options::PostFieldSize(body.length()));

        request.setOpt(new curlpp::options::Url(youTubeURL));
        request.setOpt(new curlpp::options::Timeout(_youTubeDataAPITimeoutInSeconds));

        if (_youTubeDataAPIProtocol == "https")
        {
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;
//                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;
//                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;
//                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;


            // cert is stored PEM coded in file...
            // since PEM is default, we needn't set it for PEM
            // curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
            // curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
            // equest.setOpt(sslCertType);

            // set the cert for client authentication
            // "testcert.pem"
            // curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
            // curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
            // request.setOpt(sslCert);

            // sorry, for engine we must set the passphrase
            //   (if the key has one...)
            // const char *pPassphrase = NULL;
            // if(pPassphrase)
            //  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

            // if we use a key stored in a crypto engine,
            //   we must set the key type to "ENG"
            // pKeyType  = "PEM";
            // curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

            // set the private key (file or ID in engine)
            // pKeyName  = "testkey.pem";
            // curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

            // set the file with the certs vaildating the server
            // *pCACertFile = "cacert.pem";
            // curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

            // disconnect if we can't validate server's cert
            bool bSslVerifyPeer = false;
            curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
            request.setOpt(sslVerifyPeer);

            curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
            request.setOpt(sslVerifyHost);

            // request.setOpt(new curlpp::options::SslEngineDefault());

        }
        request.setOpt(new curlpp::options::HttpHeader(headerList));

        ostringstream response;
        request.setOpt(new curlpp::options::WriteStream(&response));

        _logger->info(__FILEREF__ + "Calling youTube refresh token"
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", youTubeURL: " + youTubeURL
			+ ", body: " + body
		);
        request.perform();

        long responseCode = curlpp::infos::ResponseCode::get(request);

        sResponse = response.str();
        _logger->info(__FILEREF__ + "Called youTube refresh token"
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", youTubeURL: " + youTubeURL
			+ ", body: " + body
			+ ", responseCode: " + to_string(responseCode)
			+ ", sResponse: " + sResponse
        );

        if (responseCode != 200)
        {
            string errorMessage = __FILEREF__ + "YouTube refresh token failed"
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", responseCode: " + to_string(responseCode);
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }

        Json::Value youTubeResponseRoot;
        try
        {
            Json::CharReaderBuilder builder;
            Json::CharReader* reader = builder.newCharReader();
            string errors;

            bool parsingSuccessful = reader->parse(sResponse.c_str(),
                    sResponse.c_str() + sResponse.size(),
                    &youTubeResponseRoot, &errors);
            delete reader;

            if (!parsingSuccessful)
            {
                string errorMessage = __FILEREF__ + "failed to parse the youTube response"
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                    + ", errors: " + errors
                    + ", sResponse: " + sResponse
                 ;
                _logger->error(errorMessage);

                throw runtime_error(errorMessage);
            }
        }
        catch(...)
        {
            string errorMessage = string("youTube json response is not well format")
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", sResponse: " + sResponse
            ;
            _logger->error(__FILEREF__ + errorMessage);

            throw runtime_error(errorMessage);
        }

        /*
            {
              "access_token": "ya29.GlxvBv2JUSUGmxHncG7KK118PHh4IY3ce6hbSRBoBjeXMiZjD53y3ZoeGchIkyJMb2rwQHlp-tQUZcIJ5zrt6CL2iWj-fV_2ArlAOCTy8y2B0_3KeZrbbJYgoFXCYA",
              "expires_in": 3600,
              "scope": "https://www.googleapis.com/auth/youtube https://www.googleapis.com/auth/youtube.upload",
              "token_type": "Bearer"
            }
        */
        
        string field = "access_token";
        if (!JSONUtils::isMetadataPresent(youTubeResponseRoot, field))
        {
            string errorMessage = __FILEREF__ + "Field is not present or it is null"
                    + ", Field: " + field;
            _logger->error(errorMessage);

            throw runtime_error(errorMessage);
        }
        
        return youTubeResponseRoot.get(field, "").asString();
    }
    catch(runtime_error e)
    {
        string errorMessage = string("youTube refresh token failed")
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", youTubeURL: " + youTubeURL
            + ", sResponse: " + sResponse
            + ", e.what(): " + e.what()
        ;
        _logger->error(__FILEREF__ + errorMessage);

        throw runtime_error(errorMessage);
    }
    catch(exception e)
    {
        string errorMessage = string("youTube refresh token failed")
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", youTubeURL: " + youTubeURL
            + ", sResponse: " + sResponse
        ;
        _logger->error(__FILEREF__ + errorMessage);

        throw runtime_error(errorMessage);
    }
}

void MMSEngineProcessor::userHttpCallback(
	int64_t ingestionJobKey, string httpProtocol, string httpHostName,
	int httpPort, string httpURI, string httpURLParameters,
	string httpMethod, long callbackTimeoutInSeconds,
	Json::Value userHeadersRoot, 
	string& data, string userName, string password, int maxRetries
)
{

	_logger->info(__FILEREF__ + "userHttpCallback"
		+ ", _processorIdentifier: " + to_string(_processorIdentifier)
		+ ", ingestionJobKey: " + to_string(ingestionJobKey)
	);

	string errorMessage;

	int currentRetries = 0;
	bool callbackSuccessful = false;
	while (!callbackSuccessful && currentRetries < maxRetries)
	{
		currentRetries++;

		string userURL;

		try
		{
			errorMessage = "";

			_logger->info(__FILEREF__ + "userHttpCallback"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", httpProtocol: " + httpProtocol
				+ ", httpHostName: " + httpHostName
				+ ", httpPort: " + to_string(httpPort)
				+ ", httpURI: " + httpURI
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
			);

			userURL = httpProtocol
                + "://"
                + httpHostName
                + ":"
                + to_string(httpPort)
                + httpURI
                + httpURLParameters;

			/*
			string data;
			if (callbackMedatada != Json::nullValue)
			{
				Json::StreamWriterBuilder wbuilder;

				data = Json::writeString(wbuilder, callbackMedatada);
			}
			*/

			list<string> header;

			if ((httpMethod == "POST" || httpMethod == "PUT") && data != "")
				header.push_back("Content-Type: application/json");

			if (userName != "" && password != "")
			{
				string userPasswordEncoded = Convert::base64_encode(userName + ":" + password);
				string basicAuthorization = string("Authorization: Basic ")
					+ userPasswordEncoded;            

				header.push_back(basicAuthorization);
			}

			for (int userHeaderIndex = 0; userHeaderIndex < userHeadersRoot.size();
				++userHeaderIndex)
			{
				string userHeader = userHeadersRoot[userHeaderIndex].asString();

				header.push_back(userHeader);
			}

			curlpp::Cleanup cleaner;
			curlpp::Easy request;

			if (data != "")
			{
				// 2021-02: we do not have a requirement to send data in case of GET
				/*
				if (httpMethod == "GET")
				{
					if (httpURLParameters == "")
						userURL += "?";
					else
						userURL += "&";
					userURL += ("data=" + curlpp::escape(data));
				}
				else
				*/
				if (httpMethod == "POST" || httpMethod == "PUT")
				{
					request.setOpt(new curlpp::options::PostFields(data));
					request.setOpt(new curlpp::options::PostFieldSize(data.length()));
				}
			}

			request.setOpt(new curlpp::options::Url(userURL));
			if (httpMethod == "PUT")
				request.setOpt(new curlpp::options::CustomRequest("PUT"));
			request.setOpt(new curlpp::options::Timeout(callbackTimeoutInSeconds));

			if (httpProtocol == "https")
			{
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLCERTPASSWD> SslCertPasswd;                            
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEY> SslKey;                                          
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYTYPE> SslKeyType;                                  
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLKEYPASSWD> SslKeyPasswd;                              
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSLENGINE> SslEngine;                                    
//                typedef curlpp::NoValueOptionTrait<CURLOPT_SSLENGINE_DEFAULT> SslEngineDefault;                           
//                typedef curlpp::OptionTrait<long, CURLOPT_SSLVERSION> SslVersion;                                         
//                typedef curlpp::OptionTrait<std::string, CURLOPT_CAINFO> CaInfo;                                          
//                typedef curlpp::OptionTrait<std::string, CURLOPT_CAPATH> CaPath;                                          
//                typedef curlpp::OptionTrait<std::string, CURLOPT_RANDOM_FILE> RandomFile;                                 
//                typedef curlpp::OptionTrait<std::string, CURLOPT_EGDSOCKET> EgdSocket;                                    
//                typedef curlpp::OptionTrait<std::string, CURLOPT_SSL_CIPHER_LIST> SslCipherList;                          
//                typedef curlpp::OptionTrait<std::string, CURLOPT_KRB4LEVEL> Krb4Level;                                    


				// cert is stored PEM coded in file... 
				// since PEM is default, we needn't set it for PEM 
				// curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
				// curlpp::OptionTrait<string, CURLOPT_SSLCERTTYPE> sslCertType("PEM");
				// equest.setOpt(sslCertType);

				// set the cert for client authentication
				// "testcert.pem"
				// curl_easy_setopt(curl, CURLOPT_SSLCERT, pCertFile);
				// curlpp::OptionTrait<string, CURLOPT_SSLCERT> sslCert("cert.pem");
				// request.setOpt(sslCert);

				// sorry, for engine we must set the passphrase
				//   (if the key has one...)
				// const char *pPassphrase = NULL;
				// if(pPassphrase)
				//  curl_easy_setopt(curl, CURLOPT_KEYPASSWD, pPassphrase);

				// if we use a key stored in a crypto engine,
				//   we must set the key type to "ENG"
				// pKeyType  = "PEM";
				// curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, pKeyType);

				// set the private key (file or ID in engine)
				// pKeyName  = "testkey.pem";
				// curl_easy_setopt(curl, CURLOPT_SSLKEY, pKeyName);

				// set the file with the certs vaildating the server
				// *pCACertFile = "cacert.pem";
				// curl_easy_setopt(curl, CURLOPT_CAINFO, pCACertFile);

				// disconnect if we can't validate server's cert
				bool bSslVerifyPeer = false;
				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYPEER> sslVerifyPeer(bSslVerifyPeer);
				request.setOpt(sslVerifyPeer);

				curlpp::OptionTrait<bool, CURLOPT_SSL_VERIFYHOST> sslVerifyHost(0L);
				request.setOpt(sslVerifyHost);

				// request.setOpt(new curlpp::options::SslEngineDefault());                                              

			}
			request.setOpt(new curlpp::options::HttpHeader(header));

			ostringstream response;
			request.setOpt(new curlpp::options::WriteStream(&response));

			_logger->info(__FILEREF__ + "Calling user callback"
                + ", userURL: " + userURL
                + ", httpProtocol: " + httpProtocol
                + ", httpHostName: " + httpHostName
                + ", httpPort: " + to_string(httpPort)
                + ", httpURI: " + httpURI
                + ", httpURLParameters: " + httpURLParameters
                + ", httpProtocol: " + httpProtocol
                + ", data: " + data
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
			);
			request.perform();

			string sResponse = response.str();
			_logger->info(__FILEREF__ + "Called user callback"
                + ", userURL: " + userURL
                + ", data: " + data
                + ", sResponse: " + sResponse
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
			);        

			long responseCode = curlpp::infos::ResponseCode::get(request);
			if (responseCode != 200)
			{
				errorMessage = __FILEREF__ + "User callback failed (wrong responseCode)"
					+ ", userURL: " + userURL
					+ ", responseCode: " + to_string(responseCode)
					+ ", data: " + data
					+ ", sResponse: " + sResponse
					+ ", currentRetries: " + to_string(currentRetries)
					+ ", maxRetries: " + to_string(maxRetries)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			callbackSuccessful = true;
		}
		catch (curlpp::LogicError & e) 
		{
			errorMessage = __FILEREF__ + "User Callback URL failed (LogicError)"
				+ ", userURL: " + userURL
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
				+ ", exception: " + e.what()
			;
			_logger->error(errorMessage);

			// throw runtime_error(errorMessage);
		}
		catch (curlpp::RuntimeError & e) 
		{
			errorMessage = __FILEREF__ + "User Callback URL failed (RuntimeError)"
				+ ", userURL: " + userURL
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
				+ ", exception: " + e.what()
			;
			_logger->error(errorMessage);

			// throw runtime_error(errorMessage);
		}
		catch (runtime_error e)
		{
			errorMessage = __FILEREF__ + "User Callback URL failed (runtime_error)"
				+ ", userURL: " + userURL
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
				+ ", exception: " + e.what()
			;
			_logger->error(errorMessage);

			// throw runtime_error(errorMessage);
		}
		catch (exception e)
		{
			errorMessage = __FILEREF__ + "User Callback URL failed (exception)"
				+ ", userURL: " + userURL
				+ ", currentRetries: " + to_string(currentRetries)
				+ ", maxRetries: " + to_string(maxRetries)
				+ ", exception: " + e.what()
			;
			_logger->error(errorMessage);

			// throw runtime_error(errorMessage);
		}
	}

	if (!callbackSuccessful)
		throw runtime_error(errorMessage);
}

void MMSEngineProcessor::moveMediaSourceFileThread(
        shared_ptr<long> processorsThreadsNumber, string sourceReferenceURL, int m3u8TarGzOrM3u8Streaming,
        int64_t ingestionJobKey, shared_ptr<Workspace> workspace)
{

	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"moveMediaSourceFileThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);

    try 
    {
		_logger->info(__FILEREF__ + "moveMediaSourceFileThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(workspace);
        string destBinaryPathName =
			workspaceIngestionRepository
			+ "/"
			+ to_string(ingestionJobKey)
			+ "_source";
		// 0: no m3u8
		// 1: m3u8 by .tar.gz
		// 2: m3u8 by streaming (it will be saved as .mp4)
        if (m3u8TarGzOrM3u8Streaming == 1)
			destBinaryPathName = destBinaryPathName + ".tar.gz";

        string movePrefix("move://");
        if (!(sourceReferenceURL.size() >= movePrefix.size() && 0 == sourceReferenceURL.compare(0, movePrefix.size(), movePrefix)))
        {
            string errorMessage = string("sourceReferenceURL is not a move reference")
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey) 
                + ", sourceReferenceURL: " + sourceReferenceURL 
            ;
            
            _logger->error(__FILEREF__ + errorMessage);
            
            throw runtime_error(errorMessage);
        }
        string sourcePathName = sourceReferenceURL.substr(movePrefix.length());
                
        _logger->info(__FILEREF__ + "Moving"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", sourcePathName: " + sourcePathName
            + ", destBinaryPathName: " + destBinaryPathName
        );
        
		chrono::system_clock::time_point startMoving = chrono::system_clock::now();
        FileIO::moveFile(sourcePathName, destBinaryPathName);
        chrono::system_clock::time_point endMoving = chrono::system_clock::now();

		if (m3u8TarGzOrM3u8Streaming)
		{
			try
			{
				_mmsStorage->manageTarFileInCaseOfIngestionOfSegments(ingestionJobKey,
					destBinaryPathName, workspaceIngestionRepository,
					sourcePathName);
			}
			catch(runtime_error e)
			{
				string errorMessage = string("manageTarFileInCaseOfIngestionOfSegments failed")
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", sourceReferenceURL: " + sourceReferenceURL 
				;
           
				_logger->error(__FILEREF__ + errorMessage);
           
				throw runtime_error(errorMessage);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            // + ", movingCompleted: " + to_string(true)
            + ", sourcePathName: " + sourcePathName
            + ", destBinaryPathName: " + destBinaryPathName
			+ ", @MMS MOVE statistics@ - movingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endMoving - startMoving).count()) + "@"
        );                            
        _mmsEngineDBFacade->updateIngestionJobSourceBinaryTransferred (
            ingestionJobKey, true);
    }
    catch (runtime_error& e) 
    {
        _logger->error(__FILEREF__ + "Moving failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", sourceReferenceURL: " + sourceReferenceURL 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + re.what()
			);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + ex.what()
			);
		}
        
        return;
    }
    catch (exception e)
    {
        _logger->error(__FILEREF__ + "Moving failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", sourceReferenceURL: " + sourceReferenceURL 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + re.what()
			);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + ex.what()
			);
		}

        return;
    }
}

void MMSEngineProcessor::copyMediaSourceFileThread(
        shared_ptr<long> processorsThreadsNumber, string sourceReferenceURL, int m3u8TarGzOrM3u8Streaming,
        int64_t ingestionJobKey, shared_ptr<Workspace> workspace)
{
	ThreadsStatistic::ThreadStatistic threadStatistic(
		_mmsThreadsStatistic,
		"copyMediaSourceFileThread",
		_processorIdentifier,
		_processorsThreadsNumber.use_count(),
		ingestionJobKey);


    try 
    {
		_logger->info(__FILEREF__ + "copyMediaSourceFileThread"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey)
			+ ", _processorsThreadsNumber.use_count(): " + to_string(_processorsThreadsNumber.use_count())
		);

        string workspaceIngestionRepository = _mmsStorage->getWorkspaceIngestionRepository(workspace);
        string destBinaryPathName =
			workspaceIngestionRepository
			+ "/"
			+ to_string(ingestionJobKey)
			+ "_source";
		// 0: no m3u8
		// 1: m3u8 by .tar.gz
		// 2: m3u8 by streaming (it will be saved as .mp4)
        if (m3u8TarGzOrM3u8Streaming == 1)
			destBinaryPathName = destBinaryPathName + ".tar.gz";

        string copyPrefix("copy://");
        if (!(sourceReferenceURL.size() >= copyPrefix.size() && 0 == sourceReferenceURL.compare(0, copyPrefix.size(), copyPrefix)))
        {
            string errorMessage = string("sourceReferenceURL is not a copy reference")
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey) 
                + ", sourceReferenceURL: " + sourceReferenceURL 
            ;
            
            _logger->error(__FILEREF__ + errorMessage);
            
            throw runtime_error(errorMessage);
        }
        string sourcePathName = sourceReferenceURL.substr(copyPrefix.length());

        _logger->info(__FILEREF__ + "Coping"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", sourcePathName: " + sourcePathName
            + ", destBinaryPathName: " + destBinaryPathName
        );

		chrono::system_clock::time_point startCoping = chrono::system_clock::now();
        FileIO::copyFile(sourcePathName, destBinaryPathName);
        chrono::system_clock::time_point endCoping = chrono::system_clock::now();

        if (m3u8TarGzOrM3u8Streaming == 1)
		{
			try
			{
				_mmsStorage->manageTarFileInCaseOfIngestionOfSegments(ingestionJobKey,
					destBinaryPathName, workspaceIngestionRepository,
					sourcePathName);
			}
			catch(runtime_error e)
			{
				string errorMessage = string("manageTarFileInCaseOfIngestionOfSegments failed")
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", sourceReferenceURL: " + sourceReferenceURL 
				;
           
				_logger->error(__FILEREF__ + errorMessage);
           
				throw runtime_error(errorMessage);
			}
		}

        _logger->info(__FILEREF__ + "Update IngestionJob"
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            // + ", movingCompleted: " + to_string(true)
            + ", sourcePathName: " + sourcePathName
            + ", destBinaryPathName: " + destBinaryPathName
			+ ", @MMS COPY statistics@ - copingDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endCoping - startCoping).count()) + "@"
        );

        _mmsEngineDBFacade->updateIngestionJobSourceBinaryTransferred (
            ingestionJobKey, true);
    }
    catch (runtime_error& e) 
    {
        _logger->error(__FILEREF__ + "Coping failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", sourceReferenceURL: " + sourceReferenceURL 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + re.what()
			);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + ex.what()
			);
		}
        
        return;
    }
    catch (exception e)
    {
        _logger->error(__FILEREF__ + "Coping failed"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey) 
            + ", sourceReferenceURL: " + sourceReferenceURL 
            + ", exception: " + e.what()
        );

        _logger->info(__FILEREF__ + "Update IngestionJob"
            + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", IngestionStatus: " + "End_IngestionFailure"
            + ", errorMessage: " + e.what()
        );                            
		try
		{
			_mmsEngineDBFacade->updateIngestionJob (ingestionJobKey, 
                MMSEngineDBFacade::IngestionStatus::End_IngestionFailure, 
                e.what());
		}
		catch(runtime_error& re)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + re.what()
			);
		}
		catch(exception ex)
		{
			_logger->info(__FILEREF__ + "Update IngestionJob failed"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", IngestionStatus: " + "End_IngestionFailure"
				+ ", errorMessage: " + ex.what()
			);
		}

        return;
    }
}

/*
void MMSEngineProcessor::manageTarFileInCaseOfIngestionOfSegments(
		int64_t ingestionJobKey,
		string tarBinaryPathName, string workspaceIngestionRepository,
		string sourcePathName
	)
{
	// tarBinaryPathName like /var/catramms/storage/IngestionRepository/users/2/1449874_source.tar.gz
	// workspaceIngestionRepository like /var/catramms/storage/IngestionRepository/users/2
	// sourcePathName: /var/catramms/storage/MMSWorkingAreaRepository/Staging/2_1449859_virtualVOD_2022_08_11_12_41_46_0212/1449859_liveRecorderVirtualVOD.tar.gz

	string executeCommand;
	try
	{
		// tar into workspaceIngestion directory
		//	source will be something like <ingestion key>_source
		//	destination will be the original directory (that has to be the same name of the tar file name)
		executeCommand =
			"tar xfz " + tarBinaryPathName
			+ " --directory " + workspaceIngestionRepository;
		_logger->info(__FILEREF__ + "Start tar command "
			+ ", executeCommand: " + executeCommand
		);
		chrono::system_clock::time_point startTar = chrono::system_clock::now();
		int executeCommandStatus = ProcessUtility::execute(executeCommand);
		chrono::system_clock::time_point endTar = chrono::system_clock::now();
		_logger->info(__FILEREF__ + "End tar command "
			+ ", executeCommand: " + executeCommand
			+ ", @MMS statistics@ - tarDuration (millisecs): @" + to_string(chrono::duration_cast<chrono::milliseconds>(endTar - startTar).count()) + "@"
		);
		if (executeCommandStatus != 0)
		{
			string errorMessage = string("ProcessUtility::execute failed")
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
				+ ", executeCommandStatus: " + to_string(executeCommandStatus) 
				+ ", executeCommand: " + executeCommand 
			;

			_logger->error(__FILEREF__ + errorMessage);
          
			throw runtime_error(errorMessage);
		}

		// sourceFileName is the name of the tar file name that is the same
		//	of the name of the directory inside the tar file
		string sourceFileName;
		{
			string suffix(".tar.gz");
			if (!(sourcePathName.size() >= suffix.size()
				&& 0 == sourcePathName.compare(sourcePathName.size()-suffix.size(), suffix.size(), suffix)))
			{
				string errorMessage = __FILEREF__ + "sourcePathName does not end with " + suffix
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", sourcePathName: " + sourcePathName
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}

			size_t startFileNameIndex = sourcePathName.find_last_of("/");
			if (startFileNameIndex == string::npos)
			{
				string errorMessage = __FILEREF__ + "sourcePathName bad format"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", sourcePathName: " + sourcePathName
					+ ", startFileNameIndex: " + to_string(startFileNameIndex)
				;
				_logger->error(errorMessage);

				throw runtime_error(errorMessage);
			}
			sourceFileName = sourcePathName.substr(startFileNameIndex + 1);
			sourceFileName = sourceFileName.substr(0, sourceFileName.size() - suffix.size());
		}

		// remove tar file
		{
			string sourceTarFile = workspaceIngestionRepository + "/"
				+ to_string(ingestionJobKey)
				+ "_source"
				+ ".tar.gz";

			_logger->info(__FILEREF__ + "Remove file"
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", sourceTarFile: " + sourceTarFile
			);

			FileIO::remove(sourceTarFile);
		}

		// rename directory generated from tar: from user_tar_filename to 1247848_source
		// Example from /var/catramms/storage/IngestionRepository/users/1/9670725_liveRecorderVirtualVOD
		//	to /var/catramms/storage/IngestionRepository/users/1/9676038_source
		{
			string sourceDirectory = workspaceIngestionRepository + "/" + sourceFileName;
			string destDirectory = workspaceIngestionRepository + "/" + to_string(ingestionJobKey) + "_source";
			_logger->info(__FILEREF__ + "Start moveDirectory..."
				+ ", _processorIdentifier: " + to_string(_processorIdentifier)
				+ ", ingestionJobKey: " + to_string(ingestionJobKey)
				+ ", sourceDirectory: " + sourceDirectory
				+ ", destDirectory: " + destDirectory
			);
			// 2020-05-01: since the remove of the director could fails because of nfs issue,
			//	better do a copy and then a remove.
			//	In this way, in case the remove fails, we can ignore the error.
			//	The directory will be removed later by cron job
			{
				chrono::system_clock::time_point startPoint = chrono::system_clock::now();
				FileIO::copyDirectory(sourceDirectory, destDirectory,
					S_IRUSR | S_IWUSR | S_IXUSR |                                                                         
					S_IRGRP | S_IXGRP |                                                                                   
					S_IROTH | S_IXOTH);
				chrono::system_clock::time_point endPoint = chrono::system_clock::now();
				_logger->info(__FILEREF__ + "End copyDirectory"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", sourceDirectory: " + sourceDirectory
					+ ", destDirectory: " + destDirectory
					+ ", @MMS COPY statistics@ - copyDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endPoint - startPoint).count()) + "@"
				);
			}

			try
			{
				chrono::system_clock::time_point startPoint = chrono::system_clock::now();
				bool removeRecursively = true;
				FileIO::removeDirectory(sourceDirectory, removeRecursively);
				chrono::system_clock::time_point endPoint = chrono::system_clock::now();
				_logger->info(__FILEREF__ + "End removeDirectory"
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey)
					+ ", sourceDirectory: " + sourceDirectory
					+ ", @MMS REMOVE statistics@ - removeDuration (secs): @" + to_string(chrono::duration_cast<chrono::seconds>(endPoint - startPoint).count()) + "@"
				);
			}
			catch(runtime_error e)
			{
				string errorMessage = string("removeDirectory failed")
					+ ", _processorIdentifier: " + to_string(_processorIdentifier)
					+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
					+ ", e.what: " + e.what() 
				;
				_logger->error(__FILEREF__ + errorMessage);
         
				// throw runtime_error(errorMessage);
			}
		}
	}
	catch(runtime_error e)
	{
		string errorMessage = string("manageTarFileInCaseOfIngestionOfSegments failed")
			+ ", _processorIdentifier: " + to_string(_processorIdentifier)
			+ ", ingestionJobKey: " + to_string(ingestionJobKey) 
			+ ", e.what: " + e.what() 
		;
		_logger->error(__FILEREF__ + errorMessage);
         
		throw runtime_error(errorMessage);
	}
}
*/


int MMSEngineProcessor::progressDownloadCallback(
        int64_t ingestionJobKey,
        chrono::system_clock::time_point& lastTimeProgressUpdate, 
        double& lastPercentageUpdated, bool& downloadingStoppedByUser,
        double dltotal, double dlnow,
        double ultotal, double ulnow)
{

    chrono::system_clock::time_point now = chrono::system_clock::now();
            
    if (dltotal != 0 &&
            (dltotal == dlnow 
            || now - lastTimeProgressUpdate >= chrono::seconds(_progressUpdatePeriodInSeconds)))
    {
        double progress = (dlnow / dltotal) * 100;
        // int downloadingPercentage = floorf(progress * 100) / 100;
        // this is to have one decimal in the percentage
        double downloadingPercentage = ((double) ((int) (progress * 10))) / 10;

        _logger->info(__FILEREF__ + "Download still running"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", downloadingPercentage: " + to_string(downloadingPercentage)
            + ", dltotal: " + to_string(dltotal)
            + ", dlnow: " + to_string(dlnow)
            + ", ultotal: " + to_string(ultotal)
            + ", ulnow: " + to_string(ulnow)
        );
        
        lastTimeProgressUpdate = now;

        if (lastPercentageUpdated != downloadingPercentage)
        {
            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", downloadingPercentage: " + to_string(downloadingPercentage)
            );                            
            downloadingStoppedByUser = _mmsEngineDBFacade->updateIngestionJobSourceDownloadingInProgress (
                ingestionJobKey, downloadingPercentage);

            lastPercentageUpdated = downloadingPercentage;
        }

        if (downloadingStoppedByUser)
            return 1;   // stop downloading
    }

    return 0;
}

int MMSEngineProcessor::progressUploadCallback(
        int64_t ingestionJobKey,
        chrono::system_clock::time_point& lastTimeProgressUpdate, 
        double& lastPercentageUpdated, bool& uploadingStoppedByUser,
        double dltotal, double dlnow,
        double ultotal, double ulnow)
{

    chrono::system_clock::time_point now = chrono::system_clock::now();
            
    if (ultotal != 0 &&
            (ultotal == ulnow 
            || now - lastTimeProgressUpdate >= chrono::seconds(_progressUpdatePeriodInSeconds)))
    {
        double progress = (ulnow / ultotal) * 100;
        // int uploadingPercentage = floorf(progress * 100) / 100;
        // this is to have one decimal in the percentage
        double uploadingPercentage = ((double) ((int) (progress * 10))) / 10;

        _logger->info(__FILEREF__ + "Upload still running"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
            + ", ingestionJobKey: " + to_string(ingestionJobKey)
            + ", uploadingPercentage: " + to_string(uploadingPercentage)
            + ", dltotal: " + to_string(dltotal)
            + ", dlnow: " + to_string(dlnow)
            + ", ultotal: " + to_string(ultotal)
            + ", ulnow: " + to_string(ulnow)
        );
        
        lastTimeProgressUpdate = now;

        if (lastPercentageUpdated != uploadingPercentage)
        {
            _logger->info(__FILEREF__ + "Update IngestionJob"
                + ", _processorIdentifier: " + to_string(_processorIdentifier)
                + ", ingestionJobKey: " + to_string(ingestionJobKey)
                + ", uploadingPercentage: " + to_string(uploadingPercentage)
            );                            
            uploadingStoppedByUser = _mmsEngineDBFacade->updateIngestionJobSourceUploadingInProgress (
                ingestionJobKey, uploadingPercentage);

            lastPercentageUpdated = uploadingPercentage;
        }

        if (uploadingStoppedByUser)
            return 1;   // stop downloading
    }
        
    return 0;
}

